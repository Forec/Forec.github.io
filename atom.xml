<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Forec&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://forec.github.io/"/>
  <updated>2017-01-06T09:27:31.970Z</updated>
  <id>http://forec.github.io/</id>
  
  <author>
    <name>Forec</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统（十三）：I/O 输入系统</title>
    <link href="http://forec.github.io/2017/01/06/os-concepts-13/"/>
    <id>http://forec.github.io/2017/01/06/os-concepts-13/</id>
    <published>2017-01-06T04:17:33.000Z</published>
    <updated>2017-01-06T09:27:31.970Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十三章 I/O 输入系统部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;注：只包含第 13 章内核 I/O 子系统之前的内容。&lt;/p&gt;
&lt;h1 id=&quot;I-O-硬件&quot;&gt;&lt;a href=&quot;#I-O-硬件&quot; class=&quot;headerlink&quot; title=&quot;I/O 硬件&quot;&gt;&lt;/a&gt;I/O 硬件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备驱动程序（device drivers）&lt;/strong&gt; 为 I/O 子系统提供了统一设备的访问接口。&lt;/li&gt;
&lt;li&gt;设备和计算机的通信通过 &lt;strong&gt;端口（port）&lt;/strong&gt; ，一组被一个/多个设备共同使用的线称为 &lt;strong&gt;总线（bus）&lt;/strong&gt; 。总线是一组线和一组严格定义的描述在线上传输信息的协议。 &lt;strong&gt;链环（daisy chaine）&lt;/strong&gt; 形容的是多个设备相连，最终设备通过端口连接到计算机上的模式。链环常常按总线方式工作，一个典型的 PC 总线结构如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/typical-pc-bus.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;上图中包含一个 &lt;strong&gt;PCI 总线&lt;/strong&gt; （最常用的 PC 系统总线）用于连接 CPU 和内存子系统/快速设备， &lt;strong&gt;扩展总线（expansion bus）&lt;/strong&gt; 用于连接串/并行端口和相对慢的设备（键盘）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制器（controller）&lt;/strong&gt; 是用来操作端口、总线或者设备的一组电子器件，它的复杂程度和传输协议有关，如串行端口控制器比较简单，而 SCSI 总线控制器常实现为一个和计算机相连的独立的 &lt;strong&gt;主机适配器（host adapter）&lt;/strong&gt; ，这个适配器会有处理器、微码以及一定的私有内存，从而能够处理 SCSI 协议信息。&lt;/li&gt;
&lt;li&gt;控制器有一个/多个用于数据和控制信号的寄存器， &lt;strong&gt;处理器通过读写这些寄存器来来实现与控制器的通信&lt;/strong&gt; 。这种通信的可以通过特殊的 I/O 指令向指定的 I/O 端口地址传输一个字节/字，也可以通过 &lt;strong&gt;内存映射&lt;/strong&gt; I/O 模式（在 &lt;a href=&quot;http://blog.forec.cn/2017/01/04/os-concepts-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;虚拟内存&lt;/a&gt; 中介绍过），处理器能够通过标准数据传输指令完成对控制器的读写。部分系统同时采用这两种方式，例如图像控制器有 I/O 端口来完成基本控制操作，还有一个较大的内存映射区域来支持屏幕内容的接收和生成。&lt;/li&gt;
&lt;li&gt;I/O 端口通常有 4 种寄存器，寄存器通常为 1 ~ 4B：状态寄存器、控制寄存器、数据输入寄存器和数据输出寄存器。有的控制器有 FIFO 芯片从而可以保留多个输入/输出数据。上述四种寄存器的主要功能有：&lt;ul&gt;
&lt;li&gt;主机从 &lt;strong&gt;数据输入寄存器&lt;/strong&gt; 读出数据&lt;/li&gt;
&lt;li&gt;主机向 &lt;strong&gt;数据输出寄存器&lt;/strong&gt; 写入数据&lt;/li&gt;
&lt;li&gt;主机可从 &lt;strong&gt;状态寄存器&lt;/strong&gt; 读出设备当前的状态&lt;/li&gt;
&lt;li&gt;主机向 &lt;strong&gt;控制寄存器&lt;/strong&gt; 写入数据来发送命令、改变设备状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;轮询&quot;&gt;&lt;a href=&quot;#轮询&quot; class=&quot;headerlink&quot; title=&quot;轮询&quot;&gt;&lt;/a&gt;轮询&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;主机和控制器之间交互很复杂，但基本的 &lt;strong&gt;握手（handshaking）&lt;/strong&gt; 比较简单。假设控制器的状态寄存器中有一位用于说明设备当前是否在忙，控制器正忙时就将这一位置位。控制器的命令寄存器中有一位说明主机是否有任务准备就绪，当主机需要控制器执行某个操作时，需要将命令寄存器的这一位置位。主机和控制器交互输出一个字节时的握手流程如下：&lt;ol&gt;
&lt;li&gt;主机不断读取状态寄存器，直到状态寄存器中的 &lt;em&gt;忙位&lt;/em&gt; 为 0&lt;/li&gt;
&lt;li&gt;主机设置命令寄存器中的 &lt;em&gt;写位&lt;/em&gt; 并把一个字节写到数据输出寄存器&lt;/li&gt;
&lt;li&gt;主机设置命令寄存器中的 &lt;em&gt;就绪位&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;控制器注意到命令寄存器中的就绪位被置位，因此将状态寄存器中的 &lt;em&gt;忙位&lt;/em&gt; 置位&lt;/li&gt;
&lt;li&gt;控制器读取命令寄存器并发现 &lt;em&gt;写位&lt;/em&gt; 被置位，因此了解到需要执行一条写命令。它从数据输出寄存器读出一个字节，并向设备执行 I/O 操作&lt;/li&gt;
&lt;li&gt;控制器操作完成后将命令寄存器中的 &lt;em&gt;就绪位&lt;/em&gt; 清除，并清除状态寄存器中的 &lt;em&gt;故障位&lt;/em&gt; （这说明 I/O 设备成功完成任务），最后清除状态寄存器中的 &lt;em&gt;忙位&lt;/em&gt; 表示本次字节传输操作结束&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在步骤 1 中主机将处于 &lt;strong&gt;忙等待（busy-waiting）&lt;/strong&gt; 或者 &lt;strong&gt;轮询（polling）&lt;/strong&gt; 状态。多数计算机体系只需要三个 CPU 指令周期就可以完成基本的轮询操作，但不断地重复轮询会浪费处理器资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中断（interrupt）&lt;/strong&gt; 是使外设通知 CPU 的硬件机制。CPU 硬件有一条 &lt;strong&gt;中断请求线（Interrupt-request line，IRL）&lt;/strong&gt; ，CPU 执行完每条指令都会检测 IRL 判断是否有控制器通过 IRL 发送了信号。如果有，CPU 会保存当前的状态并且跳转到 &lt;strong&gt;中断处理程序（interrupt-handler）&lt;/strong&gt; 。中断处理程序会判断中断原因、进行处理、恢复状态并执行中断返回指令使 CPU 返回中断之前的执行状态。整个流程大致为：&lt;ul&gt;
&lt;li&gt;设备控制器通过中断请求线 &lt;strong&gt;发送中断信号引起（raise）中断&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;CPU &lt;strong&gt;捕获（catch）中断并分发（dispatch）到中断处理程序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;中断处理程序处理设备请求以 &lt;strong&gt;清除中断&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU 和 &lt;strong&gt;中断控制器（interrupt-controller）&lt;/strong&gt; 硬件提供了以下三个特性：&lt;ul&gt;
&lt;li&gt;在 CPU 执行关键指令时可以延迟对中断的处理&lt;/li&gt;
&lt;li&gt;能够将中断快速转发给适当的中断处理程序，而不必检查所有设备以确定是哪个设备引发了中断&lt;/li&gt;
&lt;li&gt;支持多级中断，可以根据紧迫性来相应中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数 CPU 有两个中断请求线： &lt;strong&gt;非屏蔽中断（nonmaskable）&lt;/strong&gt; 用于处理非常严重的，不可以恢复的内存错误等问题， &lt;strong&gt;可屏蔽中断（maskable）&lt;/strong&gt; 可被设备控制器用来请求服务，如果 CPU 正在执行关键、不可中断指令，则可以屏蔽这一类中断线上的请求。&lt;/li&gt;
&lt;li&gt;中断机制根据 &lt;strong&gt;中断向量（interrupt vector）&lt;/strong&gt; 来选择中断服务程序。中断向量和中断服务程序被维护在一张表中，中断向量支持的地址数量有限（例如 8 位中断向量只能对应 256 个中断服务程序，奔腾即为 256 个中断向量，0~31 用于各种错误等非屏蔽中断，剩下的为可屏蔽中断）， &lt;strong&gt;中断链接（interrupt chaining）&lt;/strong&gt; 可解决这个问题：中断向量指向的不再是单一的中断服务程序，而是一个中断服务程序的链表，中断一旦发生，对应链表中的全部中断处理程序都会一一调用，直到发现了能够处理请求的中断服务程序为止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断优先级（interrupt priority）&lt;/strong&gt; 使 CPU 可以在不屏蔽所有中断的情况下延迟处理低优先级的中断，并且也允许高优先级的中断抢占低优先级的中断处理。&lt;/li&gt;
&lt;li&gt;现代操作系统启动时会探查硬件总线、确定哪些设备存在并将对应的中断处理程序安装到中断向量中。操作系统对于中断机制的应用非常广泛：&lt;ul&gt;
&lt;li&gt;设备控制器通过中断表明自己已经准备好服务&lt;/li&gt;
&lt;li&gt;通过中断机制处理例如被 0 除、违例内存访问等 &lt;strong&gt;异常（Exception）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用中断进行虚拟内存分页，页错误会引发中断异常，这个中断会挂起当前进程并跳转到内核的页错误处理程序&lt;/li&gt;
&lt;li&gt;程序执行系统调用会触发 &lt;strong&gt;软中断（software interrupt）&lt;/strong&gt; 或者 &lt;strong&gt;陷阱指令（trap）&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;直接内存访问&quot;&gt;&lt;a href=&quot;#直接内存访问&quot; class=&quot;headerlink&quot; title=&quot;直接内存访问&quot;&gt;&lt;/a&gt;直接内存访问&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用通用处理器不断监听设备控制器的寄存器并按字节传输（ &lt;strong&gt;程序控制 I/O&lt;/strong&gt; ，Programmed I/O，PIO）是对计算资源的非常过分的浪费。计算机为了避免 PIO 增加 CPU 负担，将一部分数据传输任务交付 &lt;strong&gt;直接内存访问（direct-memory access，DMA）&lt;/strong&gt; 控制器。&lt;/li&gt;
&lt;li&gt;开始 DMA 传输时，主机向内存写入 DMA 命令块，块中包含传输的源、目的地址指针以及传输的字节数。 &lt;strong&gt;CPU 将该命令块的地址写到 DMA 控制器中&lt;/strong&gt; 并继续其他工作，DMA 控制器会根据命令块直接操作内存总线完成传输（这段时间 CPU 无法使用总线）。传输完成后 DMA 控制器会中断 CPU 并交还给  CPU 总线控制权。&lt;/li&gt;
&lt;li&gt;DMA 和设备控制器之间的握手通过 &lt;strong&gt;DMA-request&lt;/strong&gt; 和 &lt;strong&gt;DMA-acknowledge&lt;/strong&gt; 线进行，设备有数据需要传输时，设备控制器就通过 DMA-request 线通知 DMA 控制器，DMA 控制器会发出申请中断 CPU，在从 CPU 获取所需要的地址后将地址放到内存地址总线上，并通过 DMA-acknowledge 线通知设备控制器。设备控制器收到这个信号，向内存地址总线上的地址写入数据。交互过程如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/steps-dma-transfer.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;DMA 控制总线传输期间 CPU 不能访问主存（仍可访问 L1、L2 缓存），这称为 &lt;strong&gt;周期挪用（cycle stealing）&lt;/strong&gt; ，会放慢 CPU 计算，当往往能够改善系统总体性能。有的 DMA 使用物理内存地址，有的使用虚拟内存地址（这时候需要有一个虚拟到物理地址的转换），使用虚拟内存地址的 DMA 称为 &lt;strong&gt;直接虚拟内存访问（direct virtual-memory access，DVMA）&lt;/strong&gt; 。DVMA 可以直接实现两个内存映射设备之间的传输而无需 CPU 干涉。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;I-O-应用接口摘要&quot;&gt;&lt;a href=&quot;#I-O-应用接口摘要&quot; class=&quot;headerlink&quot; title=&quot;I/O 应用接口摘要&quot;&gt;&lt;/a&gt;I/O 应用接口摘要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;设备在很多方面有很大差异：&lt;ul&gt;
&lt;li&gt;字符流或块：字符流设备按字节传输，块设备以块为单位传输&lt;/li&gt;
&lt;li&gt;顺序访问或随机访问&lt;/li&gt;
&lt;li&gt;同步或异步：同步设备按照一定响应时间进行数据传输，异步设备则呈现无规则/不可预测的响应时间&lt;/li&gt;
&lt;li&gt;共享或专用：共享设备可以被多个进程/线程并发使用，专用设备则不可以&lt;/li&gt;
&lt;li&gt;操作速度：设备速度不同&lt;/li&gt;
&lt;li&gt;读写/只读/只写：设备支持的数据传输方向不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;块设备（block-device）&lt;/strong&gt; 接口规定了访问磁盘驱动器以及其它块设备所需的各个方面。操作系统本身和特殊的应用程序（如数据库）倾向于将块设备当作简单的线性块数组访问，这种访问方式称为 &lt;strong&gt;原始（raw） I/O&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞和非阻塞 I/O&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;应用程序发出 &lt;strong&gt;阻塞（blocking） I/O&lt;/strong&gt; 类型的系统调用时，应用程序就会被挂起，移动到进程等待队列中。因为阻塞式的 I/O 容易理解，并且 I/O 设备执行所需的时间是异步的，执行时间不可预估，因此绝大多数操作系统给应用程序预留的接口都是阻塞系统调用。&lt;/li&gt;
&lt;li&gt;有的用户级进程需要 &lt;strong&gt;非阻塞（nonblocking） I/O&lt;/strong&gt; ，例如用户接口，它用来接收键盘/鼠标输入，同时还要在屏幕回显，又或者视频应用程序，他需要从磁盘读取帧并解码到显示器上。非阻塞 I/O 通常使用多线程实现，有的线程执行阻塞系统调用，其他线程继续执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步系统调用（asynchronous system call）&lt;/strong&gt; 不必等待 I/O 完成就可以立刻返回，应用程序继续执行。I/O 完成时会通知应用程序，比如设置程序空间里某个变量，或者触发信号/软件中断等。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/two-io-methods.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十二）：大容量存储器结构&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（专题）：信号量编程&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-13/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-13/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/06/os-concepts-13/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十三章 I/O 输入系统部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（十二）：大容量存储器结构</title>
    <link href="http://forec.github.io/2017/01/05/os-concepts-12/"/>
    <id>http://forec.github.io/2017/01/05/os-concepts-12/</id>
    <published>2017-01-05T15:23:30.000Z</published>
    <updated>2017-01-06T04:23:51.029Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十二章大容量存储器结构部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;大容量存储器结构&quot;&gt;&lt;a href=&quot;#大容量存储器结构&quot; class=&quot;headerlink&quot; title=&quot;大容量存储器结构&quot;&gt;&lt;/a&gt;大容量存储器结构&lt;/h1&gt;&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;磁盘（magnetic disk）&lt;/strong&gt; 是现代计算机系统使用的大容量外存。磁盘片为扁平原盘，两面均涂有磁质材料，读写头在磁盘片的表面飞行，磁头和 &lt;strong&gt;磁臂（disk arm）&lt;/strong&gt; 相连 ，磁臂将每个盘面两侧的全部磁头作为一个整体一起移动。磁盘片表面被逻辑划分为圆形 &lt;strong&gt;磁道（track）&lt;/strong&gt; ，一圈磁道被进一步划分为 &lt;strong&gt;扇区（sector）&lt;/strong&gt; 。同一圈磁道在不同盘片的集合组成了 &lt;strong&gt;柱面（cylinder）&lt;/strong&gt; 。磁盘结构如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/moving-head-disk-machanism.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;多数驱动器每秒可旋转 60~200 圈，磁盘速度由 &lt;strong&gt;传输速率（transfer rate）&lt;/strong&gt; 和 &lt;strong&gt;定位时间（positioning time）&lt;/strong&gt; 决定。其中传输速率指驱动器和计算机之间的数据传输速率；定位时间又称 &lt;strong&gt;随机访问时间（random access time）&lt;/strong&gt; ，包括 &lt;strong&gt;寻道时间（seek time）&lt;/strong&gt; （移动磁臂到所需柱面所需的时间） 和 &lt;strong&gt;旋转等待时间（rotational latency）&lt;/strong&gt; （等待磁盘驱动器将所需扇区旋转到磁头下的时间）。寻道时间和旋转等待时间通常为几毫秒，典型的磁盘能够以几兆每秒的速率传输。&lt;/li&gt;
&lt;li&gt;磁盘的传输速率总是低于有效的传输速率。 &lt;strong&gt;磁盘表现的传输速率是磁盘头从磁性介质读取比特的速率&lt;/strong&gt; ，这不同于给操作系统传输块的速率（与操作系统之间传输的速率才是决定磁盘速度的传输速率）。&lt;/li&gt;
&lt;li&gt;磁头飞行在盘片数微米上的空气层中，一旦磁头和盘片接触就会损坏磁盘表面，这称为 &lt;strong&gt;磁头碰撞（head crash）&lt;/strong&gt; 。磁头碰撞不能修复，整个磁盘必须替换。&lt;/li&gt;
&lt;li&gt;磁盘可移动或更换。 &lt;strong&gt;软盘（floppy disk）&lt;/strong&gt; 是便宜的可移动磁盘，存储容量在 1.44MB 左右。&lt;/li&gt;
&lt;li&gt;磁盘驱动器通过 &lt;strong&gt;I/O总线&lt;/strong&gt; 和计算机相连，可用的总线包括 &lt;strong&gt;EIDE（enhanced integrated drive electronics）&lt;/strong&gt; 、 &lt;strong&gt;ATA（advanced technology attachment）&lt;/strong&gt; 和 &lt;strong&gt;串行 ATA（serial ATA，SATA）&lt;/strong&gt; 、 &lt;strong&gt;USB（universal serial bus）&lt;/strong&gt; 、 &lt;strong&gt;FC（fiber channel）&lt;/strong&gt; 和 SCSI 总线。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制器（controller）&lt;/strong&gt; 是一个特殊处理器，用于执行总线上的数据传输。其中， &lt;strong&gt;主机（host）&lt;/strong&gt; 控制器是计算机上位于总线末端的控制器，而 &lt;strong&gt;磁盘（disk）&lt;/strong&gt; 控制器位于磁盘驱动器内。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁带（magnetic tape）&lt;/strong&gt; 是早期次级存储介质，但访问速度过慢。典型磁带可以存储 20~200GB。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;火线（FireWire）&lt;/strong&gt; 指一个接口，这个接口可以讲外部设备如磁盘驱动器、DVD 驱动器等连接到计算机系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;磁盘结构和附属&quot;&gt;&lt;a href=&quot;#磁盘结构和附属&quot; class=&quot;headerlink&quot; title=&quot;磁盘结构和附属&quot;&gt;&lt;/a&gt;磁盘结构和附属&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;现代磁盘驱动器可以看作一个一维的 &lt;strong&gt;逻辑块（logical blocks）&lt;/strong&gt; 数组，逻辑块是最小的传输单位，通常为 512B，部分磁盘可以通过 &lt;strong&gt;低级格式化（low-level formatted）&lt;/strong&gt; 来选择不同的逻辑块大小。&lt;/li&gt;
&lt;li&gt;一维逻辑块数组按顺序映射到磁盘的扇区， &lt;strong&gt;扇区 0 是最外面柱面的第一个磁道的第一个扇区&lt;/strong&gt; ，这个映射关系先按磁道内的扇区顺序，之后按这一柱面上各个盘面的磁道顺序，最后按照 &lt;strong&gt;从外向内&lt;/strong&gt; 的柱面顺序排序。通过这种映射， &lt;strong&gt;可以将逻辑块号转换为磁盘内的柱面号、柱面内的磁道号以及磁道内的扇区号&lt;/strong&gt; 。这种转换有一些问题，原因在于：&lt;ul&gt;
&lt;li&gt;多数磁盘有一些缺陷扇区，这时候映射需要用其它空闲扇区替代这些缺陷扇区&lt;/li&gt;
&lt;li&gt;有些磁盘每个磁道上的扇区数不是常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于使用 &lt;strong&gt;常量线性速度（constant linear velocity，CLV）&lt;/strong&gt; 的介质，每个磁道的位密度均匀，离盘片中心更远的磁道的长度更长，容纳的扇区也就更多，这样从内向外的磁道所包含的扇区数就会逐渐增多，外部磁道的扇区数通常比内部磁道的扇区数多 40%。这时，盘片驱动器在磁头的不同位置的旋转速度将不同，磁头越靠近盘片中心则旋转速度越快。&lt;/li&gt;
&lt;li&gt;硬盘中通常采用 &lt;strong&gt;恒定圆角速度（constant angular velocity，CAV）&lt;/strong&gt; ，这时内磁道到外磁道的位密度会不断降低，以使磁盘驱动器转速恒定的情况下也能维持恒定的数据率。&lt;/li&gt;
&lt;li&gt;计算机访问磁盘可通过 I/O 端口，或称 &lt;strong&gt;主机附属存储（host-attached storage）&lt;/strong&gt; ，这一般在小系统中采用；或者通过分布式文件系统的远程主机，这称为 &lt;strong&gt;网络附属存储（network-attached storage）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;磁盘调度&quot;&gt;&lt;a href=&quot;#磁盘调度&quot; class=&quot;headerlink&quot; title=&quot;磁盘调度&quot;&gt;&lt;/a&gt;磁盘调度&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;强调磁盘的几个参数：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寻道时间&lt;/strong&gt; 是磁臂旋转以使磁头位于目标扇区所属的柱面上的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;旋转延迟&lt;/strong&gt; 是磁盘驱动器将盘片旋转以使目标扇区转动到磁头下的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁盘带宽&lt;/strong&gt; 是传输的总字节数除以从 &lt;em&gt;服务&lt;/em&gt; 请求开始到传递结束的总时间。可以通过磁盘 I/O 请求调度来排列访问顺序，从而提高访问速度和带宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程需要磁盘 I/O 操作时会向操作系统发出系统调用，这个调用请求包括：&lt;ul&gt;
&lt;li&gt;操作类型：输入/输出&lt;/li&gt;
&lt;li&gt;本次传输的磁盘地址、内存地址、扇区数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多个进程的多道程序系统，磁盘队列可能有多个待处理请求，此时操作系统需对磁盘请求进行调度，包括 FCFS、SSTF、SCAN、C-SCAN、LOOK、C-LOOK。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;FCFS-调度&quot;&gt;&lt;a href=&quot;#FCFS-调度&quot; class=&quot;headerlink&quot; title=&quot;FCFS 调度&quot;&gt;&lt;/a&gt;FCFS 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;先来先服务算法，此算法比较公平但无法提供最快的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SSTF-调度&quot;&gt;&lt;a href=&quot;#SSTF-调度&quot; class=&quot;headerlink&quot; title=&quot;SSTF 调度&quot;&gt;&lt;/a&gt;SSTF 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最短寻道时间优先法（shortest-seek-time-first，SSTF）&lt;/strong&gt; 会先处理最靠近当前磁头位置的请求，即选择距离当前磁头位置所需寻道时间最短的请求来处理。&lt;/li&gt;
&lt;li&gt;本质上是最短作业优先（SJF）调度，但与 SJF 类似，它可能导致一些请求得不到服务，如果待处理请求队列比较长，很有可能某个请求会产生饥饿。SSTF 调度相比 FCFS 调度有很大改善，但仍不是最优的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SCAN-和-C-SCAN-调度&quot;&gt;&lt;a href=&quot;#SCAN-和-C-SCAN-调度&quot; class=&quot;headerlink&quot; title=&quot;SCAN 和 C-SCAN 调度&quot;&gt;&lt;/a&gt;SCAN 和 C-SCAN 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SCAN 算法有时称为 &lt;strong&gt;电梯算法（elevator algorithm）&lt;/strong&gt; ，磁臂会从磁盘的一端向另一端移动（按一维逻辑块数组的顺序），当磁头移动过每个柱面时就会处理这个柱面的服务请求。到达另一端后磁头会反向继续移动，如此往返。&lt;/li&gt;
&lt;li&gt;如果一个请求刚好在磁头移动到请求位置之前加入磁盘请求队列，则它会马上得到服务&lt;/li&gt;
&lt;li&gt;如果一个请求刚好在磁头移动过请求位置后加入队列，则它需要等待磁头到达另一端并调转方向、返回后才能得到服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-SCAN（circular SCAN）&lt;/strong&gt; 调度和 SCAN 类似，但当磁头从磁盘的 0 号扇区移动到磁盘的最后一个扇区（或者柱面）后不会调转方向，而是从 0 号重新开始扫描整个磁盘。&lt;/li&gt;
&lt;li&gt;这两种算法都不会导致饥饿现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;LOOK-和-C-LOOK-调度&quot;&gt;&lt;a href=&quot;#LOOK-和-C-LOOK-调度&quot; class=&quot;headerlink&quot; title=&quot;LOOK 和 C-LOOK 调度&quot;&gt;&lt;/a&gt;LOOK 和 C-LOOK 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;LOOK 和 SCAN 算法类似，磁头向一个方向移动，但不会一直移动到最后一个柱面才折返，而是处理完这个方向上最后一个请求后就掉头。&lt;/li&gt;
&lt;li&gt;C-LOOK 和 C-SCAN 类似，处理完最后一个请求后就会将磁头恢复到磁盘一端重新开始按固定顺序扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;算法选择&quot;&gt;&lt;a href=&quot;#算法选择&quot; class=&quot;headerlink&quot; title=&quot;算法选择&quot;&gt;&lt;/a&gt;算法选择&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘服务请求很大程度上受文件分配方法影响：一个连续分配文件会产生几个磁盘上相近位置的请求，而链接/索引文件会产生很多分散在磁盘上的块。&lt;/li&gt;
&lt;li&gt;目录和索引块在磁盘上的位置也很重要，如果目录位于第一个柱面而文件数据位于最后一个柱面，则磁头需要横跨整个磁盘宽度。如果目录在中央柱面，则磁头只需要移动不到一半的磁盘宽度。&lt;/li&gt;
&lt;li&gt;磁盘调度算法应该作为一个操作系统的独立模块，在必要的时候模块应该可以被替换。SSTF 或 LOOK 算法是比较合理的默认算法。&lt;/li&gt;
&lt;li&gt;调度算法只考虑了寻道距离。旋转延迟几乎和寻道时间一样，但操作系统无法通过调度改善旋转延迟，因为现代磁盘并不透露逻辑块的物理位置。磁盘制造商会在磁盘控制器中加入磁盘调度算法缓解寻道时间和旋转延迟问题。&lt;/li&gt;
&lt;li&gt;因为操作系统对请求服务的顺序有更多限制（如按需分页的 I/O 请求比普通应用程序的 I/O 请求优先级高），因此操作系统不能完全将磁盘调度交给磁盘控制器，而是选择自己的磁盘调度算法，将请求按调度好的顺序、按批次交给磁盘控制器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;磁盘管理&quot;&gt;&lt;a href=&quot;#磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;磁盘管理&quot;&gt;&lt;/a&gt;磁盘管理&lt;/h1&gt;&lt;h2 id=&quot;磁盘格式化&quot;&gt;&lt;a href=&quot;#磁盘格式化&quot; class=&quot;headerlink&quot; title=&quot;磁盘格式化&quot;&gt;&lt;/a&gt;磁盘格式化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;新磁盘仅仅是含有磁性记录材料的盘片，需要通过 &lt;strong&gt;低级格式化（物理格式化，physical formatting）&lt;/strong&gt; 分为扇区。&lt;/li&gt;
&lt;li&gt;低级格式化将磁盘的每个扇区按特定的数据结构填充数据，扇区的数据结构包括头、数据区（通常 512B）和尾部。头部和尾部包含磁盘控制器需要的信息，如扇区号码和 &lt;strong&gt;纠错代码（error-correcting code，ECC）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;操作系统需要将自己的数据结构记录到磁盘上，首先需要将磁盘分为一个或多个柱面组成的分区，操作系统可以将每个分区视作独立的磁盘。分区之后，操作系统需要通过 &lt;strong&gt;逻辑格式化（logical formatting）&lt;/strong&gt; 来创建文件系统，操作系统会将初始的文件系统数据结构存储到磁盘上。这些数据结构包括那些仍空闲的和已经分配的空间（如分配给 FAT 或者 inode）和一个初始为空的目录。&lt;/li&gt;
&lt;li&gt;为提高效率，多数操作系统将多个块集中到一大块，称为 &lt;strong&gt;簇（cluster）&lt;/strong&gt; 。磁盘 I/O 通过块完成，文件系统 I/O 通过簇完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;引导块&quot;&gt;&lt;a href=&quot;#引导块&quot; class=&quot;headerlink&quot; title=&quot;引导块&quot;&gt;&lt;/a&gt;引导块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机开始运行时需要初始化（自举，bootstrap）程序，它负责初始化系统所需的各个方面，并找到磁盘上的操作系统内核，将其装入内存开始执行。&lt;/li&gt;
&lt;li&gt;自举程序保存在 &lt;strong&gt;只读存储器（ROM）&lt;/strong&gt; 中，其位置固定，并且只读（不受病毒影响），但改变自举代码就需要改变 ROM 硬件芯片。因此操作系统只在启动 ROM 中保留一个非常小的自举程序，这个小自举程序会从磁盘上调入更完整的自举程序。更完整的自举程序可以修改，并且保存在磁盘的启动块上。&lt;/li&gt;
&lt;li&gt;磁盘的 &lt;strong&gt;启动块（boot blocks）&lt;/strong&gt; 位于磁盘的固定位置，拥有启动分区的磁盘称为 &lt;strong&gt;启动磁盘（boot disk）&lt;/strong&gt; 或者 &lt;strong&gt;系统磁盘（system disk）&lt;/strong&gt; 。启动 ROM 中的代码将启动块中的代码装入内存并执行，启动块中的完整自举程序会从 &lt;strong&gt;非固定位置&lt;/strong&gt; 装入整个操作系统并执行。&lt;/li&gt;
&lt;li&gt;以 Windows 2000 为例，其启动代码放置在硬盘的第一个扇区，被称为 &lt;strong&gt;主引导记录（master boot record，MBR）&lt;/strong&gt; ，MRB 中除了包含自举程序的代码，还包含硬盘分区列表和系统引导分区的具体标识。Win 2000 将硬盘分成多个分区，其中一个为 &lt;strong&gt;引导分区（boot partition）&lt;/strong&gt; ，该分区包括了操作系统和设备驱动程序。MBR 确定引导分区的位置后就会读取引导分区的第一个扇区（引导扇区，boot sector）并继续剩余的启动过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;坏块&quot;&gt;&lt;a href=&quot;#坏块&quot; class=&quot;headerlink&quot; title=&quot;坏块&quot;&gt;&lt;/a&gt;坏块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘有移动部件且容错能力小，容易出问题。多数磁盘从工厂出来就有 &lt;strong&gt;坏块（bad blocks）&lt;/strong&gt; 。坏块中的数据会丢失。&lt;/li&gt;
&lt;li&gt;简单磁盘可手动处理坏扇区。如 MS-DOS 的 &lt;code&gt;format&lt;/code&gt; 命令执行逻辑格式化时，会扫描磁盘查找坏扇区，如果找到就在 FAT 的条目中写上特殊值以标明该块已损毁。&lt;/li&gt;
&lt;li&gt;复杂磁盘（高端 PC、WorkStation 或服务器上的 SCSI 磁盘）需要控制器维护一个磁盘坏块链表，这个链表在磁盘出厂前进行低级格式化时就已经初始化，并在磁盘使用过程中不断更新。低级格式化会将一些块备用，操作系统无法看到这些块。当坏块出现时，控制器会用备用块替换这些坏块。这种方案称为 &lt;strong&gt;扇区备用（sector sparing）&lt;/strong&gt; 或 &lt;strong&gt;转寄（forwarding）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;典型的坏块区事务处理：&lt;ul&gt;
&lt;li&gt;操作系统访问逻辑块 87&lt;/li&gt;
&lt;li&gt;控制器计算该块的 ECC 值，发现该块已经损坏，因此将结果通知操作系统&lt;/li&gt;
&lt;li&gt;下次操作系统重启时运行特殊程序告知 SCSI 控制器用备用块替代坏块&lt;/li&gt;
&lt;li&gt;之后的每次系统访问逻辑块 87，请求都会被转换成替代后的备用块地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扇区备用的另一方案是 &lt;strong&gt;扇区滑动（sector slipping）&lt;/strong&gt; ：假定逻辑块 17 损坏，第一个可用的备用块是扇区 203，则将 18 ~ 202 扇区向下滑动一个扇区，变为 19 ~ 203 扇区。这样原本的扇区 18 变为空，用来替换扇区 17。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十一）：文件系统实现&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-13/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十三）：I/O 输入系统&lt;/a&gt;     &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/05/os-concepts-12/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十二章大容量存储器结构部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（十一）：文件系统实现</title>
    <link href="http://forec.github.io/2017/01/05/os-concepts-11/"/>
    <id>http://forec.github.io/2017/01/05/os-concepts-11/</id>
    <published>2017-01-05T09:11:59.000Z</published>
    <updated>2017-01-05T15:37:01.809Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十一章文件系统实现部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;文件系统结构&quot;&gt;&lt;a href=&quot;#文件系统结构&quot; class=&quot;headerlink&quot; title=&quot;文件系统结构&quot;&gt;&lt;/a&gt;文件系统结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;磁盘具有如下两个特点因而成为大容量多文件存储的方便介质：&lt;ul&gt;
&lt;li&gt;可以原地重写&lt;/li&gt;
&lt;li&gt;可以直接访问磁盘上任意一块信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存和磁盘之间的 I/O 转移以 &lt;strong&gt;块&lt;/strong&gt; 为单位而非字节。每块为一个或多个扇区，扇区大小从 32 ~ 4096B 不等，通常是 512B。&lt;/li&gt;
&lt;li&gt;文件系统包括多层，下图是一个分层的例子，每一层利用较低层的功能创建新功能以为更高层提供服务。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I/O 控制&lt;/strong&gt; 是最底层，由 &lt;strong&gt;设备驱动程序（device drivers）&lt;/strong&gt; 组成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本文件系统（basic file system）&lt;/strong&gt; 只需要向设备驱动程序发送一般指令就可以对磁盘上的物理块做读写，每个块由它的磁盘地址标识（驱动器 1，柱面 73，磁道 3，扇区 10）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件组织模块（file-organization module）&lt;/strong&gt; 直到文件和它的逻辑块、物理块。因为文件组织模块知道文件类型和位置，因此可以将逻辑块地址转换成基本文件系统用的物理块地址。它也包括 &lt;strong&gt;空闲空间管理器&lt;/strong&gt; 用来追踪未分配的块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑文件系统（logical file system）&lt;/strong&gt; 管理元数据，元数据包括文件系统的全部结构数据而不包括文件的具体内容。逻辑文件系统为文件组织模块提供所需的信息，通过 &lt;strong&gt;文件控制块（file-control block，FCB）&lt;/strong&gt; 来维护文件结构，同时也负责保护和安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目前多数操作系统都支持多个文件系统，UNIX 使用 UNIX文件系统（UFS），基于伯克利快速文件系统（FFS）。标准的 Linux 文件系统是 &lt;strong&gt;可扩展文件系统（extended file system）&lt;/strong&gt; ，常见版本有 ext2 和 ext3。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h1&gt;&lt;h2 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a&gt;基本结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘上的文件系统涉及如下一些结构：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;（每个卷的）引导控制块（boot control block）&lt;/strong&gt; ：从这个卷引导操作系统所需要的信息，如果这个卷没有安装操作系统则这一块内容为空。它通常是卷的第一块，UFS 称之为 &lt;strong&gt;引导块（boot block）&lt;/strong&gt; ，NTFS 系统称之为 &lt;strong&gt;分区引导扇区（partition boot sector）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;（每个卷的）卷控制块（volume control block）&lt;/strong&gt; ：包括卷或分区的详细信息，如分区块数、块大小、空闲块数量和指针、空闲 FCB 的数量和指针等。UFS 称之为 &lt;strong&gt;超级块（superblock）&lt;/strong&gt; ，在 NTFS 中存储在 &lt;strong&gt;主控文件表（Master File Table）&lt;/strong&gt; 。主控文件表采用关系型数据库，每个文件占据一行。&lt;/li&gt;
&lt;li&gt;每个文件的 FCB 包含文件的详细信息（文件权限、拥有者、大小、位置）等，UFS 称之为 &lt;strong&gt;索引节点（inode）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;每个文件系统的目录结构，这些目录结构用于组织文件。UFS 中目录结构包括文件名和相关的索引节点号，NTFS 则保存在主控文件表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存内信息用于文件系统管理，可以通过缓存来提高性能。这部分数据在文件系统挂载（安装）的时候被加在，文件系统卸载的时候丢弃，可能包括：&lt;ul&gt;
&lt;li&gt;内存中的安装表，含有所有已安装卷的信息&lt;/li&gt;
&lt;li&gt;内存中的目录结构缓存，保存最近访问过的目录信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统范围内的打开文件表&lt;/strong&gt; ，在 &lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文件系统接口&lt;/a&gt; 中介绍过，包括每个打开文件的 FCB 副本和其它信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单个进程的打开文件表&lt;/strong&gt; ，每个条目包括指向系统范围内打开文件表的条目的指针以及与进程相关的其它文件信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打开文件表的索引有多种名称，UFS 称之为 &lt;strong&gt;文件描述符（file descriptor）&lt;/strong&gt; ，Windows 称之为 &lt;strong&gt;文件句柄（file handle）&lt;/strong&gt; ，只要文件没有关闭，所有对文件的操作都是通过打开文件表执行的。文件系统中用户进程读文件的操作形式如下图所示。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/in-memory-file-system-read.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分区和挂载&quot;&gt;&lt;a href=&quot;#分区和挂载&quot; class=&quot;headerlink&quot; title=&quot;分区和挂载&quot;&gt;&lt;/a&gt;分区和挂载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个磁盘可以分成多个分区，一个卷也可能横跨多个磁盘上的多个分区（RAID 的一种形式）。&lt;/li&gt;
&lt;li&gt;没有文件系统的分区称作 &lt;strong&gt;生（raw）&lt;/strong&gt; 磁盘，含有文件系统的分区称为 &lt;strong&gt;熟（cooked）&lt;/strong&gt; 的。生磁盘通常用于没有合适的文件系统可以使用的地方，例如 UNIX 的交换空间，或者有的数据库使用生磁盘并将其格式化来满足自己的需求。&lt;/li&gt;
&lt;li&gt;引导信息可以包含在多个分区中，通常是一组有序块，并作为镜像文件读入内存。镜像文件会按照预先指定的位置开始执行，它除了可以启动一个特定的操作系统，还可以支持 &lt;strong&gt;双引导（dual-booted）&lt;/strong&gt; ，即启动加载器知道有哪些操作系统、文件系统位于引导区，并可以引导磁盘上不同分区的不同类型的操作系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根分区（root partition）&lt;/strong&gt; 包括操作系统内核以及其它系统文件，它们在引导时装载到内存中，其它卷会根据操作系统的设定，要么在引导时自动装入，要么通过用户手动装入。当有一个新设备挂载（安装）时，操作系统会验证设备上的文件系统是否有效，并根据需要自动/手动纠正。验证通过后，操作系统会在内存中的 &lt;strong&gt;挂载表/装入表（mount table）&lt;/strong&gt; 中标注该文件系统已经装入，并且存储与此文件系统有关的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟文件系统（Virtual File System，VFS）&lt;/strong&gt; 是文件系统接口和文件系统之间的一层，它的目的有：&lt;ul&gt;
&lt;li&gt;定义一个 VFS 接口将文件系统的通用操作和具体实现划分，多个 VFS 接口的实现能够在同一台机器共存，因此它允许访问安装在本地的多种类型的文件系统；&lt;/li&gt;
&lt;li&gt;VFS 提供了在网络上唯一标识一个文件的机制。它基于 vnode 文件表示结构（包括一个唯一的数值标识符，它能够表明位于整个网络范围内的唯一文件，例如 UNIX 的索引节点 inode 在文件系统内是唯一的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;目录实现&quot;&gt;&lt;a href=&quot;#目录实现&quot; class=&quot;headerlink&quot; title=&quot;目录实现&quot;&gt;&lt;/a&gt;目录实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性列表（linear list）&lt;/strong&gt; 是实现目录最简单的方法，运行非常低效。查找文件需要线性搜索，排序列表可以二分搜索，但排序的需求使文件创建/删除复杂化，它的优点在于可直接生成排序目录信息，可用 B 树实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表（hash table）&lt;/strong&gt; ：在线性列表存储目录之上使用哈希表，根据文件名哈希出一个指向线性列表中元素的指针，需要一些措施避免 &lt;strong&gt;冲突（collision）&lt;/strong&gt; 。其困难在于，如果使用固定大小的哈希表，当条目超出哈希表容量时需要扩充哈希表大小，并且设计新的哈希函数将文件名映射到新的范围内。可以使用 &lt;strong&gt;chained-overflow&lt;/strong&gt; 哈希表，使表中元素为一个链表而非单个记录。虽然冲突将使每个链表长度较大，查找可能变慢，但仍比线性搜索快得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;分配方法&quot;&gt;&lt;a href=&quot;#分配方法&quot; class=&quot;headerlink&quot; title=&quot;分配方法&quot;&gt;&lt;/a&gt;分配方法&lt;/h1&gt;&lt;h2 id=&quot;连续分配&quot;&gt;&lt;a href=&quot;#连续分配&quot; class=&quot;headerlink&quot; title=&quot;连续分配&quot;&gt;&lt;/a&gt;连续分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连续分配（contiguous allocation）&lt;/strong&gt; 要求每个文件在磁盘上占据连续的块。磁盘地址有一个线性序列，如果只有一个作业按照这个序列的顺序访问磁盘，在访问了块 b 后访问块 b+1 就无需移动磁头，即使需要移动磁头也只需要移动一个磁道（从一个柱面的最后扇区到下个柱面第一扇区）。因此， &lt;strong&gt;访问连续分配文件所需的寻道数最小，即使确实需要寻道，所花费的寻道时间也最小&lt;/strong&gt; 。在文件连续分配中，一个文件的目录条目包括文件占有的第一个块的地址，以及该文件分配的块的数量（分配区域的长度）。&lt;/li&gt;
&lt;li&gt;连续分配文件访问非常容易，既可以顺序访问也可以随机访问。它也存在问题，例如如何为新文件寻找空间，这个问题可看作 &lt;a href=&quot;http://blog.forec.cn/2017/01/03/os-concepts-8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存管理&lt;/a&gt; 中 &lt;strong&gt;动态存储分配&lt;/strong&gt; 问题的一个具体应用，即如何从一个空闲的孔列表中寻找一个满足大小为 n 的空间，常用首次适应和最佳适应。&lt;/li&gt;
&lt;li&gt;连续分配方案的另一个问题是需要确定文件需要多少空间，这个知识是无法预知的。如果为一个文件分配的空间过小则文件可能无法原地扩展文件，这时要么终止用户程序并通知用户必须分配更多空间才能运行（这样用户就会过高的预估所需的磁盘空间造成浪费），要么找一个更大的孔，将文件复制到新空间，释放旧空间，但这比较耗时。&lt;/li&gt;
&lt;li&gt;修正的连续分配方案：开始时为文件分配一块连续空间，一旦空间不够，另一块称为 &lt;strong&gt;扩展（extent）&lt;/strong&gt; 的 &lt;strong&gt;连续空间&lt;/strong&gt; 就会被分配给文件。这种情况下，文件块的位置就需要通过开始块地址、块数、指向下一个扩展的指针三项来确定。如果扩展太大，内部碎片会变得严重；随着扩展的分配、删除，外部碎片也将变得严重。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;链接分配&quot;&gt;&lt;a href=&quot;#链接分配&quot; class=&quot;headerlink&quot; title=&quot;链接分配&quot;&gt;&lt;/a&gt;链接分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;链接分配（linked allocation）&lt;/strong&gt; 解决了连续分配的全部问题。链接分配中，每个文件由分布在磁盘上各个位置的多个磁盘块组成，文件目录条目记录了一个文件第一块的指针和最后一块的指针。每一块都会有一个指向下一块的指针，用户无法使用存储这些指针的空间（例如一块有 512B，磁盘地址为 4B，则用户只可用 508B）。&lt;/li&gt;
&lt;li&gt;链接分配对于创建/读/写文件的操作如下：&lt;ul&gt;
&lt;li&gt;创建新文件时只要简单的在目录中增加一个新条目，条目中有指向文件第一块的指针，初始化为 &lt;code&gt;nil&lt;/code&gt; 以表明这是空文件，大小字段也是 0。&lt;/li&gt;
&lt;li&gt;写文件时通过空闲空间管理器寻找一个空闲块，这个块会被写入数据、链接到文件最后一个块的尾部，同时要更新这个文件在目录中条目的记录值（大小、最后一个块的地址）。&lt;/li&gt;
&lt;li&gt;读文件通过条目中存储的第一个块的地址，逐个向后寻找。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接分配的缺点在于：&lt;ul&gt;
&lt;li&gt;只能用于文件的顺序访问，要找到文件的第 i 块必须要从第一块开始寻找，每次访问都需要读磁盘，这还需要涉及磁盘寻道的延迟。因此 &lt;strong&gt;链接分配无法有效支持文件直接访问&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;指针需要空间，每一块都有一定空间被指针占用。这个问题的解决方法是将多个块组成 &lt;strong&gt;簇（cluster）&lt;/strong&gt; ，按簇而不是块来分配（如一个簇有 4 块）。这样指针占用的磁盘空间百分比会下降，但增加了内部碎片。簇可以改善多数算法中的磁盘访问时间，因此在绝大多数操作系统中得到应用。&lt;/li&gt;
&lt;li&gt;可靠性：文件通过指针链接，一旦有一个指针丢失/损坏，整个文件都将崩溃。一个逃避性的解决方案是采用双向链表，或者给每个块存上文件名和相对块数（相对第一块是第几块），但这又增加了过多的额外开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接分配方法的一个变种是 &lt;strong&gt;文件分配表（file-allocation table，FAT）&lt;/strong&gt; ，它被应用于 MS-DOS 和 OS/2 操作系统。每个卷的开始部分存储文件分配表，卷内的每一块都在表中占有一项，这个表可以通过块号码索引， &lt;strong&gt;表中存储的值是这一块指向的下一块块号&lt;/strong&gt; 。&lt;ul&gt;
&lt;li&gt;文件在目录中的条目只含有文件第一块的块号，访问文件时按照 FAT 表中存储的链接关系一直向下寻找，直到最后一块（最后一块在 FAT 表中标记为一个特殊的文件结束值，可以根据这个值判断是否为最后一块）。&lt;/li&gt;
&lt;li&gt;要分配一个新的块，只需要在 FAT 表中找到第一个值为 0（值为 0 表示一个块没有被使用）的块，用新块的地址替换掉此前最后一块的文件结束值，并且用文件结束值替换 FAT 表中的 0。&lt;/li&gt;
&lt;li&gt;FAT 需要采用缓存才能提高效率，否则可能导致大量的磁头寻道时间：磁头要移动到卷的开头读入 FAT  以获得块的位置，然后才能移动到块本身。最坏情况下每块的读取都要移动两次。但它的优点在于改善了随机访问时间， &lt;strong&gt;因为 FAT 的存在，操作系统可以快速找到文件任意一块的位置&lt;/strong&gt; 。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/file-allocation-table.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;索引分配&quot;&gt;&lt;a href=&quot;#索引分配&quot; class=&quot;headerlink&quot; title=&quot;索引分配&quot;&gt;&lt;/a&gt;索引分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果不采用 FAT，链接分配就无法有效支持直接访问，因为块指针散布在整个磁盘，必须顺序读取。 &lt;strong&gt;索引分配（indexed allocation）&lt;/strong&gt; 把所有指针放到一起，通过 &lt;strong&gt;索引块（index block）&lt;/strong&gt; 解决此问题。&lt;/li&gt;
&lt;li&gt;每个文件都有自己的索引块，它是一个磁盘块地址的数组。索引块的第 i 个条目代表文件的第 i 个块，条目中含有索引块的磁盘地址。要读取第 i 块只需要通过索引块第 i 个条目存储的指针来访问（类似第八章分页）。&lt;ul&gt;
&lt;li&gt;创建文件：索引块中所有指针设为 nil。&lt;/li&gt;
&lt;li&gt;第一次写入第 i 块：从空闲空间管理器获取一个空闲块，将数据写入块，并将块地址写到索引块的第 i 个条目中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引分配支持直接访问且没有外部碎片问题，但索引分配会浪费空间&lt;/strong&gt; ：如果一个文件只有两块长，链接分配只需要每块浪费一个指针，而索引分配需要为这个只有两块的文件创建一个完整的索引块，这个索引块里只有两个指针被使用到。&lt;/li&gt;
&lt;li&gt;索引块的大小需要经过仔细考量：每个文件都有一个索引块，索引块太大会造成浪费，太小又不足以满足大文件存储需求。针对这一问题的处理机制有如下几点：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;链接方案（Linked scheme）&lt;/strong&gt; ：一个索引块就是一个磁盘块。它本身能够直接读写，当遇到大文件存储时可以将多个索引块链接。例如一个索引块可以包含一个头部（头部包含文件名）以及 100 个磁盘块的地址。索引块的最后一个存储单元存储着指向下一个索引块的地址如果是小文件则这个指针为 &lt;code&gt;nil&lt;/code&gt;，如果是大文件则指向了另一个索引块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多层索引（Multilevel index）&lt;/strong&gt; ：设置两层索引块，第一层指向第二层，第二层指向文件块。根据最大文件大小的不同，可以继续到第三/四层。对于块大小为 4KB 的情况，可以在一个索引块里装入 1024 个 4B 指针，两层索引就可以容纳 1048 576 个数据块，即最大文件为 4GB。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合方案（Combined scheme）&lt;/strong&gt; ：在 UFS 中使用了这种方案。将索引块的前 15 个指针存在文件的 inode 里，这 15 个指针中：前 12 个直接指向了数据块，这样不超过 12 块的文件就不需要其它索引块；后 3 个指针分别是一级间接块、二级间接块、三级间接块指针。这种方法允许一个文件的块数超过 4B 文件指针能访问的空间。许多 UNIX 系统支持 64 位文件指针，这时允许文件/文件系统达到数 T 字节。UNIX 的inode 大致如下：&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/unix-inode-indexed.jpg&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引分配方案和链接分配方案在性能上都有欠缺，虽然索引块能够缓存在内存里，但数据块会分布到整个分区中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;性能&quot;&gt;&lt;a href=&quot;#性能&quot; class=&quot;headerlink&quot; title=&quot;性能&quot;&gt;&lt;/a&gt;性能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;连续分配对于任意类型的访问都只需要访问一次，链接分配可以将下一块的地址放到内存中并能直接读取，但对于直接访问需要读多次磁盘。所以有些系统通过使用连续分配支持文件直接访问，通过链接分配支持顺序访问。这种系统在创建文件时就要指明文件的类型（顺序访问还是直接访问），如果是直接访问还必须说明最大文件大小。&lt;/li&gt;
&lt;li&gt;索引分配非常复杂。如果索引块已在内存中则可以直接访问，但将索引块保存在内存中需要非常大的空间。尤其是多级索引，对于一个大文件来说，如果要访问文件末尾部分的数据，可能需要将所有索引块读入内存才能读到需要的数据库。所以索引分配的性能依赖于索引结构、文件大小和所需要的块的位置。&lt;/li&gt;
&lt;li&gt;有的系统把连续分配和索引分配结合，对于小文件（3、4块大小的）采用连续分配，大文件切换到索引分配。因为文件系统中大多数文件较小，所以小文件连续分配效率较高，平均性能较好。&lt;/li&gt;
&lt;li&gt;由于 CPU 和磁盘速度不等，花费数千条 CPU 指令来节省一些磁头移动都是值得的，随着时间推移，这种不等程度还会增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;空闲空间管理&quot;&gt;&lt;a href=&quot;#空闲空间管理&quot; class=&quot;headerlink&quot; title=&quot;空闲空间管理&quot;&gt;&lt;/a&gt;空闲空间管理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;系统需要维护 &lt;strong&gt;空闲空间链表（free-space list）&lt;/strong&gt; 以记录空闲磁盘空间，创建文件时会从空闲空间链表分配，删除文件时磁盘空间会加回到空闲空间链表上（称之为链表但不一定表现为链表）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;位向量&quot;&gt;&lt;a href=&quot;#位向量&quot; class=&quot;headerlink&quot; title=&quot;位向量&quot;&gt;&lt;/a&gt;位向量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将空闲空间用 &lt;strong&gt;位图（bit map）&lt;/strong&gt; 或 &lt;strong&gt;位向量（bit vector）&lt;/strong&gt; 表示，每块用一位说明是否为空闲，1 表示空闲，0 表示已经分配。&lt;/li&gt;
&lt;li&gt;此方式查找磁盘上第 1 个空闲块和 n 个连续空闲块时简单高效：&lt;ul&gt;
&lt;li&gt;按顺序检查位图中的每个字是否为 0 即可确定对应的块是否已经全部分配，第一个非 0 的字中，第一个 1 位偏移旧对应着第一个空闲块；&lt;/li&gt;
&lt;li&gt;连续 n 个空闲块只需要判断是否有连续 &lt;code&gt;[n / 字的位数]&lt;/code&gt; 个字均为最大值（如一个字就是一个字节时，只要连续有 &lt;code&gt;[n / 8]&lt;/code&gt; 个字节全为 255 就说明这部分块都空闲）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除非整个位向量都能保存在内存中，否则位向量的效率不高。对于小磁盘，位向量的大小可以接受，但对于大磁盘而言（如 40GB，每块 1KB）就需要超过 5MB 空间存储位图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;链表和组&quot;&gt;&lt;a href=&quot;#链表和组&quot; class=&quot;headerlink&quot; title=&quot;链表和组&quot;&gt;&lt;/a&gt;链表和组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将所有空闲磁盘块用 &lt;strong&gt;链表（Linked List）&lt;/strong&gt; 链接，将指向第一个空闲块的指针放在磁盘的一个特殊位置，同时也缓存到内存里。第一块空闲块中包含了指向下一个空闲磁盘块的指针。&lt;/li&gt;
&lt;li&gt;此方案效率不高，要遍历整个空闲块列表需要从磁盘读出每一块，这要耗费大量 I/O 时间。不过通常操作系统只需要获得一个空闲块以提供给文件，因此一般只需要分配空闲表的第一块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组（grouping）&lt;/strong&gt; 是对空闲链表的改进：将 n 个空闲块的地址存在第一个空闲块里，前 n-1 个地址都指向真正的空闲块， &lt;strong&gt;最后一个地址指向了另一个包含另外 n 个空闲块的块地址&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;计数&quot;&gt;&lt;a href=&quot;#计数&quot; class=&quot;headerlink&quot; title=&quot;计数&quot;&gt;&lt;/a&gt;计数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通常会有多个连续的块需要同时分配、释放，尤其是采用了连续分配或簇的情况下。因此可以不记录 n 个空闲块地址，而是记录连续多块空闲块的第一块的地址，以及连续的空闲块的数量。这样空闲空间表的每个条目包含了第一个空闲块地址和连续空闲块数量，虽然每个条目占用的空间增长了，但表的总长度会缩短（连续空闲块的数量往往大于 1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UNIX-成组链接（补充）&quot;&gt;&lt;a href=&quot;#UNIX-成组链接（补充）&quot; class=&quot;headerlink&quot; title=&quot;UNIX 成组链接（补充）&quot;&gt;&lt;/a&gt;UNIX 成组链接（补充）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将文件存储设备中的所有的空闲块 &lt;strong&gt;从后向前&lt;/strong&gt; 按 50 块为一组进行划分，每组的第一块用于存放 &lt;strong&gt;前一组&lt;/strong&gt; 的总块数和每块的块号，因为第一组前面已经没有其他组存在，所以第一组实际有 49 块。因为存储空间不一定正好是 50 的整数倍，所以最后一组可能不足 50 块。因为最后一组后面没有其他组，所以最后一组的总块数和每块块号的信息存放到管理文件存储设备的文件资源表中。如下图所示。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/unix-group-linked.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;操作系统启动时将文件资源表复制到内存，此时文件资源表中包含了最后一组的空闲块总数以及空闲块的块号。操作系统还会设置一个用于空闲块分配、回收的堆栈，堆栈存储着空闲块的块号，栈指针 ptr 的初值等于最后一组的空闲块的总块数。&lt;/li&gt;
&lt;li&gt;成组链接分配方法：申请者请求获得 n 块空闲块，操作系统将按照先进先出的原则，将栈顶指向的块号分配给请求者，同时 ptr 自减。重复此操作直到 n 块分配完毕，或者堆栈中只剩下最后一个空闲块的块号（此块实际存储的是下一组的空闲块块数和各块块号）。当堆栈只剩下最后一个空闲块的块号时：&lt;ul&gt;
&lt;li&gt;从堆栈中弹出该块的块号，系统启动 I/O 设备，将该块存放的内容读入内存（即将下一组空闲块号和总块数读入空闲资源表），并设置 ptr 为下一组的空闲块数&lt;/li&gt;
&lt;li&gt;文件存储设备的最后一个空闲块中设置有尾部标识，表示空闲块已经分配完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成组链接回收方法：用户删除某个文件时，ptr 自增并将空闲块号入栈。若 ptr 为 50 则表明当前已经凑足一组，该组回收结束。&lt;ul&gt;
&lt;li&gt;如果还有空闲物理块 F 需要回收，则将块 F 回收，并且启动设备 I/O，把栈中记录的 50 个块号和块数（50）写入到块 F 中。设置 ptr 为 1，将块 F 的块号入栈，开始新的一组空闲块回收。&lt;/li&gt;
&lt;li&gt;对空闲块的分配和回收操作必须互斥进行（栈操作要互斥）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十）：文件系统接口&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十二）：大容量存储器结构&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/05/os-concepts-11/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十一章文件系统实现部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（十）：文件系统接口</title>
    <link href="http://forec.github.io/2017/01/05/os-concepts-10/"/>
    <id>http://forec.github.io/2017/01/05/os-concepts-10/</id>
    <published>2017-01-05T03:55:47.000Z</published>
    <updated>2017-01-05T15:32:02.765Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十章文件系统接口部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h1&gt;&lt;h2 id=&quot;概念、属性和操作&quot;&gt;&lt;a href=&quot;#概念、属性和操作&quot; class=&quot;headerlink&quot; title=&quot;概念、属性和操作&quot;&gt;&lt;/a&gt;概念、属性和操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;信息可以在多种介质上存储，为了方便使用，操作系统为不同的信息存储设备提供了统一的逻辑接口：对存储设备的各类属性加以抽象，定义了逻辑存储单元（文件），之后再将文件映射到非易失性的物理设备上。&lt;/li&gt;
&lt;li&gt;文件是 &lt;strong&gt;一系列有名称的、记录在二级存储器上的信息集合&lt;/strong&gt; 。在用户眼里，文件是逻辑外存的最小分配单元，数据必须通过文件的形式才能写入到外存。文件根据不同的类型有一定 &lt;strong&gt;结构（structure）&lt;/strong&gt; ，例如 &lt;em&gt;文本文件&lt;/em&gt; 由行（页）组成，每行又由字符组成； &lt;em&gt;源文件&lt;/em&gt; 由子程序和函数组成，子程序和函数又由声明、执行语句组成； &lt;em&gt;目标文件&lt;/em&gt; 是一系列字节序列，按目标系统链接器所能理解的方式组成； &lt;em&gt;可执行文件&lt;/em&gt; 为一系列可以装入程序调入内存执行的代码段。&lt;/li&gt;
&lt;li&gt;所有文件的信息都保存在文件系统的目录结构中，目录结构（必须也是非易失性的）也保存在外存中。 &lt;strong&gt;文件属性（file attributes）&lt;/strong&gt; 通常包括：&lt;ul&gt;
&lt;li&gt;名称：文件符号名称，按人类理解方式保存&lt;/li&gt;
&lt;li&gt;标识符：文件系统内标识此文件的唯一标签，通常为数字&lt;/li&gt;
&lt;li&gt;类型：此字段仅对于支持多类型文件系统有效&lt;/li&gt;
&lt;li&gt;位置：指向设备和设备上该文件位置的指针&lt;/li&gt;
&lt;li&gt;大小：文件当前大小，也可表示文件允许的最大容量&lt;/li&gt;
&lt;li&gt;保护：读、写、执行控制权限&lt;/li&gt;
&lt;li&gt;时间、日期、用户标识：文件创建、上次修改、最近访问等信息，用于保护、安全以及使用记录的追踪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件属于 &lt;strong&gt;抽象数据类型（abstract data type）&lt;/strong&gt; ，文件操作的最小集合包括如下六条，这六条基本操作可以组合以实现其他文件操作：&lt;ul&gt;
&lt;li&gt;创建文件：包括在文件系统中为文件找到空间并分配、在文件目录中为新文件创建条目；&lt;/li&gt;
&lt;li&gt;写文件：系统要为文件维护一个写位置的指针，一旦发生写操作就需要更新写指针（写方式 &lt;code&gt;fopen&lt;/code&gt; 返回值就是一个写指针）；&lt;/li&gt;
&lt;li&gt;读文件：系统也需要为文件维护读指针，一个进程通常只对一个文件读或写，故当前操作位置（读/写指针）可作为每个进程 &lt;strong&gt;当前文件位置指针（current-file-position pointer）&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;文件内重定位（repositioning within a file）：修改文件位置指针的值（seek 操作，文件寻址），这不需要执行真正的 I/O；&lt;/li&gt;
&lt;li&gt;删除文件：需要在目录中搜索给定名称文件，释放其空间并删除文件目录中的条目；&lt;/li&gt;
&lt;li&gt;截短（truncating）：删除文件内容而保留属性，将文件长度设为 0 并释放空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统维护一个 &lt;strong&gt;打开文件表（open-file table）&lt;/strong&gt; ，当需要一个文件时，操作系统根据这个表的索引来指定文件，避免了每次文件操作都要搜索文件目录。有的系统会在首次引用文件时隐式地打开它，绝大多数操作系统要求程序员通过 &lt;code&gt;open()&lt;/code&gt; 操作显示地打开文件，并将文件条目复制到打开文件表中。档文件不再使用时，进程可以 &lt;em&gt;关闭&lt;/em&gt; 这个文件，操作系统会从打开文件表删除文件对应的条目。系统调用 &lt;code&gt;open()&lt;/code&gt; 会返回一个 &lt;strong&gt;指向打开文件表中一个条目的指针&lt;/strong&gt; ，所有 I/O 操作会通过使用该指针来进行。&lt;/li&gt;
&lt;li&gt;多个进程同时打开同一文件的情况下，操作系统通常采用 &lt;strong&gt;两级内部表&lt;/strong&gt; ：单个进程的表和整个系统的表。其中单个进程的表追踪单个进程打开的所有文件（该进程对文件的使用信息，如该进程对该文件操作的指针位置、权限等），表中的每一个条目指向整个操作系统打开文件表中相对应的一项。而操作系统的打开文件表（整个系统的表）包含着与进程无关的文件信息（文件在磁盘的位置、大小等），一旦一个文件第一次被进程打开，操作系统会在打开文件表中增加相应的条目；而 &lt;strong&gt;一个已经被打开的文件再次被其它进程打开时，仅仅在进程的打开文件表中增加一个指向整个系统表的相应条目&lt;/strong&gt; 。一般系统维护的打开文件表中，每个文件会有一个文件打开计数器，用来记录多少进程打开了该文件，当计数器降到 0 时标识文件不再使用，可以从打开文件表删除。&lt;/li&gt;
&lt;li&gt;以上，每个打开文件应当包括如下信息：&lt;ul&gt;
&lt;li&gt;文件指针：这个属性对于每个进程都可能不同，因此它保存在进程各自的打开文件表中，每个进程都需要为自己打开的每个文件维护一个文件指针。&lt;/li&gt;
&lt;li&gt;文件打开计数器：此属性保存在操作系统的文件打开表中，操作系统等待所有进程均不在引用某文件（计数器为 0）后才会将其条目删除。&lt;/li&gt;
&lt;li&gt;文件磁盘位置：这一属性用于定位磁盘上的文件位置，保存在操作系统的打开文件表中。&lt;/li&gt;
&lt;li&gt;访问权限：此属性保存在进程各自的打开文件表中，操作系统根据进程各自的访问模式决定是否允许进程的 I/O 请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部分操作系统提供了 &lt;strong&gt;文件锁&lt;/strong&gt; 以允许一个进程锁住文件，禁止其他进程访问。文件锁可以用于多个进程共享的文件（如多个进程访问、修改的系统日志）。其中， &lt;strong&gt;共享锁（shared lock）&lt;/strong&gt; 类似 &lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程同步&lt;/a&gt; 中读者-写者问题的读者锁，它允许多个进程并发获取； &lt;strong&gt;专用锁（exclusive lock）&lt;/strong&gt; 类似写者锁，只有一个进程可以获取此锁。有的操作系统只提供专用锁。另外，操作系统可以提供 &lt;strong&gt;强制（mandatory）&lt;/strong&gt; 或者 &lt;strong&gt;建议（advisory）&lt;/strong&gt; 文件加锁机制，如果文件锁是强制的，那么操作系统会禁止其它进程访问一个已经加锁的文件；如果文件锁是建议的，则操作系统不会禁止。因此，对于建议加锁，程序开发者要确保进程适当的获取、释放锁。通常 Windows 系统采用强制加锁，而 UNIX 系统采用建议加锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类型和结构&quot;&gt;&lt;a href=&quot;#类型和结构&quot; class=&quot;headerlink&quot; title=&quot;类型和结构&quot;&gt;&lt;/a&gt;类型和结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不同的应用程序可以使用不同的扩展名来指明文件。UNIX 系统采用 &lt;strong&gt;幻数（magic number）&lt;/strong&gt; 表明文件类型，这部分数据保存在文件的开始位置（不是所有的文件都具有幻数）。UNIX 也不记录文件创建程序的名称，但仍允许通过文件扩展名来确定文件内容类型。&lt;/li&gt;
&lt;li&gt;文件类型可用于表示文件的内部结构（例如源代码文件和目标文件都有一定的结构来适应对应处理程序的要求），这些文件必须符合操作系统要求的结构。随着操作系统支持文件结构种类的增加，操作系统也会增大。很多操作系统 &lt;strong&gt;支持最少数量的文件结构&lt;/strong&gt; （包括 UNIX、MS-DOS），如 UNIX 认为每个文件是 8 位字节序列组成，操作系统不会去试着解释这些位。这样的方案提供了很高的灵活性（但是操作系统本身并不提供任何支持），应用程序必须通过自己的代码去解释输入的文件。当然操作系统必须至少支持可执行文件结构。&lt;/li&gt;
&lt;li&gt;磁盘系统通常有明确定义的块（由扇区大小决定），所有磁盘 I/O 均按块执行。因为物理块大小通常不会和文件操作的逻辑记录长度相同，因此文件系统将若干个逻辑记录 &lt;strong&gt;打包（packing）&lt;/strong&gt; 成块再执行 I/O 操作。同样，由于磁盘空间按块划分，文件最后一块的部分空间通常会被浪费，产生内部碎片，块越大内部碎片也越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;访问方法和文件系统挂载&quot;&gt;&lt;a href=&quot;#访问方法和文件系统挂载&quot; class=&quot;headerlink&quot; title=&quot;访问方法和文件系统挂载&quot;&gt;&lt;/a&gt;访问方法和文件系统挂载&lt;/h1&gt;&lt;h2 id=&quot;访问方法&quot;&gt;&lt;a href=&quot;#访问方法&quot; class=&quot;headerlink&quot; title=&quot;访问方法&quot;&gt;&lt;/a&gt;访问方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序访问（Sequential Access）&lt;/strong&gt; ：文件信息按顺序处理。这种访问模式最常用，如编辑器、编译器等均按此种方式访问。大量文件操作都是读写操作，两种操作都会向某一方向移动文件指针。顺序访问基于文件的磁带模型（读写/倒回），对顺序访问设备和随机访问设备都适用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接访问（Direct Access）&lt;/strong&gt; ：也称 &lt;strong&gt;相对访问（relative access）&lt;/strong&gt; ，文件由固定长度的 &lt;strong&gt;逻辑记录（logical records）&lt;/strong&gt; 组成，因此程序可以直接计算出文件所在的块并快速读写（磁盘允许对任意块进行随机读写）。数据库通常使用这种类型的文件。因为随机读写以块为目标，故文件操作要经过修改从而将块号作为参数。有两种方式：一是将 &lt;em&gt;读下一个字节&lt;/em&gt; 变成 &lt;em&gt;读 n&lt;/em&gt; ，将 &lt;em&gt;写下一个字节&lt;/em&gt; 变成 &lt;em&gt;写 n&lt;/em&gt; ；另一种则是仍使用 &lt;em&gt;读下一个&lt;/em&gt; 和 &lt;em&gt;写下一个&lt;/em&gt; ，但是增加了 &lt;em&gt;定位文件到 n&lt;/em&gt; 的操作。用户向操作系统提交的块号是 &lt;strong&gt;相对块号（relative block number）&lt;/strong&gt; ，是相对于文件开始的索引。&lt;/li&gt;
&lt;li&gt;不是所有的操作系统都支持顺序访问和直接访问，部分系统只允许顺序或随机访问，有的则再文件创建时指定文件是顺序还是随机访问。对于直接访问的文件，可以非常容易的模拟出顺序访问，而在顺序访问文件中模拟直接访问是非常低效的。&lt;/li&gt;
&lt;li&gt;其他访问方式通常建立在直接访问智商，涉及文件 &lt;strong&gt;索引（index）&lt;/strong&gt; ，索引包含了各个块的指针。要查找文件记录，要先搜索索引，然后根据指针直接访问文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;文件系统挂载&quot;&gt;&lt;a href=&quot;#文件系统挂载&quot; class=&quot;headerlink&quot; title=&quot;文件系统挂载&quot;&gt;&lt;/a&gt;文件系统挂载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文件系统在使用前必须 &lt;strong&gt;挂载（mount）&lt;/strong&gt; ，中文版翻译称为 &lt;strong&gt;安装&lt;/strong&gt; 。操作系统需要知道设备名称，以及这个设备在文件系统中的挂载（安装）位置，这个位置称为挂载点（mount point），通常是一个空目录。&lt;/li&gt;
&lt;li&gt;操作系统会验证一个挂载（安装）的设备是否包含一个有效文件系统，验证流程如下：通过设备驱动程序读入设备目录，验证目录是否符合操作系统期待的格式。验证通过后操作系统会在目录结构中记录这个文件系统已经被安装在挂载点上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;磁盘（或其他大存储设备）可以当作整体运用在一个文件系统中，但有时需要在一个磁盘上安装多种文件系统。磁盘上各个部分称为 &lt;strong&gt;分区（partitions）&lt;/strong&gt; 或 &lt;strong&gt;片（slices）&lt;/strong&gt; ，或称为 &lt;strong&gt;小型磁盘（minidisk，IBM）&lt;/strong&gt; 。每个磁盘分区可以创建一个文件系统，这些部分可以组合起来成为更大的结构 &lt;strong&gt;卷（volume）&lt;/strong&gt; ，也可以在卷上创建文件系统。下面将 &lt;strong&gt;存储文件系统的一大块空间作为卷&lt;/strong&gt; ，卷可以存放多个操作系统。包含文件系统的卷需要记录文件系统中的信息，这些信息保存在 &lt;strong&gt;设备目录（device directory）&lt;/strong&gt; 或 &lt;strong&gt;卷表（volume table of contents）&lt;/strong&gt; 中，它记录了卷上所有文件信息（名称、位置、大小、类型等）。&lt;/li&gt;
&lt;li&gt;目录可以视作符号表，将文件名称转换成目录条目。目录需要支持如下操作：&lt;ul&gt;
&lt;li&gt;在目录中搜索文件&lt;/li&gt;
&lt;li&gt;创建文件&lt;/li&gt;
&lt;li&gt;删除文件&lt;/li&gt;
&lt;li&gt;遍历目录&lt;/li&gt;
&lt;li&gt;重命名文件&lt;/li&gt;
&lt;li&gt;跟踪文件系统：定期备份整个文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组织目录结构的要求（补充）：&lt;ul&gt;
&lt;li&gt;高效（能够快速定位文件）&lt;/li&gt;
&lt;li&gt;命名（用户要方便命名、不同用户可以有同名文件、同一文件可以有多个名称）&lt;/li&gt;
&lt;li&gt;成组（可以按照文件属性划分成组）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单层结构目录（single-level directory）&lt;/strong&gt; ：所有文件保存在同一目录中，便于理解和支持。但当文件类型增加或者系统需要为多个用户提供服务时，必须保证所有文件名称唯一。文件名称长度有限，MS-DOS 只允许 11 个字符，UNIX 允许 255 个字符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双层结构目录（two-level）&lt;/strong&gt; ：单层目录结构会在不同用户直接引起文件名混淆，双层结构目录中，每个用户有自己的 &lt;strong&gt;用户文件目录（user file directory，UFD）&lt;/strong&gt; ，每个 UFD 都有相似的结构，但只包含所属用户的文件。用户作业执行/用户注册时，搜索主系统的 &lt;strong&gt;主文件目录（master file directory，MFD）&lt;/strong&gt; 来检索到用户的 UFD，这允许多个用户拥有相同名称的文件。&lt;ul&gt;
&lt;li&gt;双层结构目录能够有效地对用户隔离，但不利于用户之间的合作和文件共享。双层结构目录等价于一棵高度为 2 地倒置树。&lt;/li&gt;
&lt;li&gt;对于系统库等每个进程都需要的文件，双层结构目录必须将这些系统文件复制到每个 UFD 下，这导致大量空间浪费，解决方法是修改搜索步骤，在根目录下定义一个特殊的用户目录，目录中包含所有的系统文件。当进程在 UFD 查找不到需要的文件时会搜索这个特殊用户目录。给定一个文件，搜索的一系列目录称为 &lt;strong&gt;搜索路径（search path）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树状目录结构（tree-structured directories）&lt;/strong&gt; ：允许用户创建自己的子目录，系统内每个文件有唯一路径名。目录包括一组文件和子目录，目录实际也是一个按特殊方式访问的文件，文件系统中每个条目都需要一位定义其为文件（0）还是子目录（1），并且删除目录条目需要特殊的系统调用。&lt;ul&gt;
&lt;li&gt;通常每个进程有一个当前目录， &lt;strong&gt;当前目录（current directory）&lt;/strong&gt; 包括进程当前感兴趣的多数文件，引用文件时也会先搜索当前目录。&lt;/li&gt;
&lt;li&gt;路径名分 &lt;strong&gt;绝对路径名（absolute path name）&lt;/strong&gt; 和 &lt;strong&gt;相对路径名（relative path name）&lt;/strong&gt; 。绝对路径名从根开始给出路径上的目录名，一直到指定文件；相对路径名从进程的当前目录开始定义路径。&lt;/li&gt;
&lt;li&gt;删除目录：如果目录为空可以直接删除，若目录不为空，有的系统不允许删除不为空的目录（MS-DOS，要删除一个有内容的目录就必须先清空整个目录内的文件），有的系统则提供了选择（选择是否允许删除全部子目录和文件，这样更危险，比如 &lt;code&gt;rm /* -rf&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;用户除了可以访问自己的文件，还可以通过路径名访问其他用户文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无环图目录（acyclic graph）&lt;/strong&gt; ： &lt;strong&gt;树状结构禁止共享文件和目录&lt;/strong&gt; ，无环图允许目录含有共享子目录和文件。无环图是树状结构目录的扩展。&lt;ul&gt;
&lt;li&gt;共享目录不同于文件复制，共享情况下任何一个用户对文件做出的改动都对其它共享用户可见。&lt;/li&gt;
&lt;li&gt;实现 &lt;strong&gt;共享目录方法&lt;/strong&gt; 1：创建一种称为 &lt;strong&gt;链接（link）&lt;/strong&gt; 的新目录条目，链接实际是另一个文件/目录的指针，操作系统可以通过链接保存的路径名定位真实文件（这一行为称为 &lt;strong&gt;解析（resolve）&lt;/strong&gt;  。&lt;/li&gt;
&lt;li&gt;实现共享目录方法 2：每个用户都有共享文件的副本，但这些副本时刻更新着所有被共享文件的信息。但这样做会使副本和原始的文件无法区分，并且一旦有用户修改了副本/原始文件，所有其它副本都需要修改以维护一致性。&lt;/li&gt;
&lt;li&gt;实现 &lt;strong&gt;共享目录问题&lt;/strong&gt; 1：一个文件被共享，因此可能会有多个绝对路径指向了同一个文件，这时对于遍历文件系统/查找文件/统计文件数量/备份文件等操作，需要解决不重复计算的问题。&lt;/li&gt;
&lt;li&gt;实现共享目录问题 2：分配给共享文件的空间何时可以删除？若用户删除文件即删除，则会留下很多悬挂链接指向不存在的文件，如果删除部分的空间被其它文件使用，这样链接又会指向其他文件的某个部分。可以在文件删除时搜索并删除这些悬挂的链接，但相对耗时；或者直到某个进程使用了某个悬挂链接时再去清理（UNIX 和 Windows 系统均不会在删除文件时删除链接，而由用户意识到原来文件已经删除）&lt;/li&gt;
&lt;li&gt;实现共享目录问题 3：删除共享文件的另一种方式是保留文件直到所有指向该文件的引用都删除为止。这样需要为每个文件维护一个引用列表，这个引用列表可能很大。因此可以用一个计数器代替引用列表。UNIX 操作系统对 &lt;strong&gt;硬链接（hard links，非符号链接）&lt;/strong&gt; 采用了这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用图目录（general graph）&lt;/strong&gt; ：无环图结构必须确保没有环，而对于无环图的共享部分，如果搜索一个共享子目录没有找到文件，就应该避免通过其它链接再次搜索这个共享子目录（浪费时间）。如果目录中甚至有环存在（例如子目录又包含了到父目录的链接），就更要避免循环搜索。&lt;ul&gt;
&lt;li&gt;避免循环搜索：限制搜索时访问目录的次数。&lt;/li&gt;
&lt;li&gt;删除文件：可能出现文件自我引用，这时需要垃圾收集机制确定什么时候可以删除引用。垃圾收集需要遍历整个文件系统并将所有能够访问到的空间标记，之后第二次遍历将第一遍没有标记的位置收集到空闲空间链表上。&lt;/li&gt;
&lt;li&gt;如何避免无环：仅允许链接到一个没有子目录的文件；垃圾回收；每次新链接加入都运行环检测算法判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;文件共享&quot;&gt;&lt;a href=&quot;#文件共享&quot; class=&quot;headerlink&quot; title=&quot;文件共享&quot;&gt;&lt;/a&gt;文件共享&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;多用户操作系统必须控制文件共享。系统可以默认允许一个用户访问其他用户文件，也可以要求一个用户授予文件固定的访问权限。多用户系统需要比但用户系统维护更多的文件和目录属性，现在绝大多数系统采用了文件（目录） &lt;strong&gt;拥有者（owner，user）&lt;/strong&gt; 和 &lt;strong&gt;组（group）&lt;/strong&gt; 的概念，其中拥有者控制权最高，拥有者的 ID 会和文件属性一起保存。同一组的成员具有相同的权限，并只能执行拥有者具有权限的子集。&lt;/li&gt;
&lt;li&gt;远程文件系统的实现方式包括：&lt;ul&gt;
&lt;li&gt;用户通过程序（ftp）在机器之间传输文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式文件系统（Distributed Information System）&lt;/strong&gt; ：远程目录可以从本机直接访问&lt;/li&gt;
&lt;li&gt;万维网（和 ftp 类似，基本是 ftp 的包装）：用浏览器下载文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C/S模型（客户机-服务器模型）：服务器包含文件，客户机访问文件。服务器需要表明目录和卷的哪些文件可用，而客户机的身份需要通过网络名称/IP 或者其它标识符鉴别（这些可能被欺骗/模仿），因此客户机需要通过加密密钥向服务器进行安全验证，安全验证也会遇到很多问题，所以多数情况还是使用不太安全的验证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障模式（Failure Modes）&lt;/strong&gt; ：本地文件系统可能因为某些原因出错，比如包含文件系统的磁盘老化，目录结构或者其它磁盘管理信息（统称为 &lt;strong&gt;元数据，metadata&lt;/strong&gt; ）损坏等。用户或管理员的冒失也会导致文件丢失/整个目录删除等。远程文件系统因为网络因素，需要有更多的故障模式，客户机和服务器之间 &lt;strong&gt;需要对每一次远程请求记录信息&lt;/strong&gt; 以在故障发生时能够恢复。类似 NFS 的协议对每个请求的信息都加以记录，因此能够很容易的从故障中恢复，但安全性较差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性语义（Consistency Semantics）&lt;/strong&gt; ：描述多用户同时访问共享文件时的语义，规定了一个用户修改的数据什么时候对另一个用户可见。&lt;ul&gt;
&lt;li&gt;UNIX 语义（UFS）：用户对已经打开的文件进行写操作会立刻被其它同时打开这一文件的用户可见，还有一种共享模式会共享文件指针的位置，一个文件移动了文件指针会影响其他用户，文件有一个映像，这个映像允许来自不同用户的交替访问（映像是互斥资源）。&lt;/li&gt;
&lt;li&gt;AFS 文件系统：用户对打开文件的写操作不会立刻被其他用户可见，一旦文件关闭，对文件的修改只能被以后打开的会话所见，已经打开文件的用户无法看到这些修改。一个文件会有多个物理映像，用户允许对自己的映像进行不受限制的读写操作（没有互斥）。&lt;/li&gt;
&lt;li&gt;不可修改共享文件语义：文件不可修改，即只读（文件名不能重用、文件内容不可修改）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;保护&quot;&gt;&lt;a href=&quot;#保护&quot; class=&quot;headerlink&quot; title=&quot;保护&quot;&gt;&lt;/a&gt;保护&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;计算机系统中保存的信息必须能够免受物理损坏（可靠性）和非法访问（保护）。对于多用户系统尤其需要某些机制。&lt;/li&gt;
&lt;li&gt;访问类型：需要 &lt;strong&gt;控制访问（controlled access）&lt;/strong&gt; 来限制可以进行的文件访问类型，访问类型包括：读、写、执行、添加、删除、列表清单（获取文件名称、属性等）。更多操作（重命名、编辑等）都是这些底层操作的组合，因此保护只需要在底层提供，高层操作涉及的底层操作如果不满足保护的要求就会被拒绝。&lt;/li&gt;
&lt;li&gt;访问控制：根据用户身份判断能否对某个文件访问。每个文件/目录都增加一个 &lt;strong&gt;访问控制列表（access-control list，ACL）&lt;/strong&gt; 来指定每个用户对这个文件/目录具有的合法的访问类型。缺点是访问控制列表会较长，并且一般事先无法知道系统的用户列表，这将导致更复杂的空间管理。&lt;/li&gt;
&lt;li&gt;操作系统为每个文件提供了三种用户类型：拥有者、组（一组需要共享文件并且具有相同访问需求的用户集合）、其他用户。Linux 中每种类型的用户都有 &lt;code&gt;rwx&lt;/code&gt; 三个位。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/04/os-concepts-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（九）：虚拟内存&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十一）：文件系统实现&lt;/a&gt;        &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/05/os-concepts-10/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十章文件系统接口部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>顶点云（应用）用户代理</title>
    <link href="http://forec.github.io/2016/12/03/zenith-cloud-7/"/>
    <id>http://forec.github.io/2016/12/03/zenith-cloud-7/</id>
    <published>2016-12-03T13:44:07.000Z</published>
    <updated>2016-12-23T17:28:14.844Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;设计用户代理，实现 &lt;code&gt;DealWithRequests()&lt;/code&gt; 中的几种简单逻辑指令，如文件列表获取、文件拷贝、Fork操作等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/zenith-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）设计与实现&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/23/zenith-cloud-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）服务器逻辑实现&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：TODO  &lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计用户代理，实现 &lt;code&gt;DealWithRequests()&lt;/code&gt; 中的几种简单逻辑指令，如文件列表获取、文件拷贝、Fork操作等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="Golang" scheme="http://forec.github.io/tags/Golang/"/>
    
      <category term="云存储" scheme="http://forec.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
      <category term="线程" scheme="http://forec.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 中的高效 I/O</title>
    <link href="http://forec.github.io/2016/11/30/efficient-haskell-io/"/>
    <id>http://forec.github.io/2016/11/30/efficient-haskell-io/</id>
    <published>2016-11-30T14:54:30.000Z</published>
    <updated>2016-11-30T15:39:16.182Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Haskell 提高 I/O 效率的技巧及资源控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;二进制-I-O&quot;&gt;&lt;a href=&quot;#二进制-I-O&quot; class=&quot;headerlink&quot; title=&quot;二进制 I/O&quot;&gt;&lt;/a&gt;二进制 I/O&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Data.ByteString&lt;/code&gt; ：定义严格求值的 ByteString 类型，将一串二进制数据或文本数据用一个数组表示。适合不在意内存限制并要求随机存取的情况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data.ByteString.Lazy&lt;/code&gt;：提供了 &lt;code&gt;ByteString&lt;/code&gt; 的惰性类型，将一串数据分块组成列表，每块大小 64KB 。该方式惰性执行，对于体积较大的数据，惰性的 ByteString 类型会更好，其块大小针对现代 CPU L1缓存调整过，已处理过的、不会再被使用的流数据会被垃圾处理器快速回收。&lt;/li&gt;
&lt;li&gt;以上两种类型均提供了和 &lt;code&gt;String&lt;/code&gt; 类型兼容的接口函数，但元素类型为字节 &lt;code&gt;Word8&lt;/code&gt;，该类型在 &lt;code&gt;Data.Word&lt;/code&gt; 模块中声明。&lt;/li&gt;
&lt;li&gt;可使用 &lt;code&gt;pack&lt;/code&gt; 函数将字节数组装载为 &lt;code&gt;ByteString&lt;/code&gt;：&lt;code&gt;L.pack :: [Word.Word8] -&amp;gt; L.ByteString&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ByteString&lt;/code&gt; 库提供了两个功能有限的 I/O 功能模块：&lt;code&gt;Data.ByteString.Char8&lt;/code&gt; 和 &lt;code&gt;Data.ByteString.Lazy.Char8&lt;/code&gt;，其中的函数仅适用于单字节大小的 Char 值（ASCII和某些欧洲字符集，大于 255 会被截断）。这两个模块提供了较多方便的函数，如 &lt;code&gt;readInt&lt;/code&gt;、&lt;code&gt;split&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Haskell 的正则通过 &lt;code&gt;Text.Regex.Posix&lt;/code&gt; 模块提供，其中 &lt;code&gt;=~&lt;/code&gt; 操作符是正则表达式匹配函数。其参数和返回值都使用了类型类，第一个参数是要被匹配的文本，第二个参数是正则表达式，每个参数都可以用为 &lt;code&gt;String&lt;/code&gt; 或者 &lt;code&gt;ByteString&lt;/code&gt; 类型。其返回值是多态的，但文本匹配的结果必须和被匹配的字符串一致，我们可以将 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;ByteString&lt;/code&gt; 组合，但结果类型必须和被匹配字符串一样。正则表达式可以使 &lt;code&gt;String&lt;/code&gt; 或者 &lt;code&gt;ByteString&lt;/code&gt;，没有限制。根据返回类型签名不同，返回结果也有区别：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bool&lt;/code&gt;：字符串和正则式是否匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Int&lt;/code&gt;：正则式在字符串中成功匹配的次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(Int, Int)&lt;/code&gt;：格式为（首次匹配在字符串中的偏移量，首次匹配结果的长度），偏移量为 -1 时表示字符串和正则式不匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[(Int, Int)]&lt;/code&gt;：得到所有匹配子串的（偏移量，匹配长度），列表为空代表无匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;：得到第一个匹配的子串，或者无匹配的空字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[String]]&lt;/code&gt;：返回由所有匹配的字符串组成的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(String, String, String)&lt;/code&gt;：匹配成功时为（首次匹配之前的部分，首次匹配的子串，首次匹配之后的部分），匹配失败时为（整个字符串，””,””）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(String, String, String, [String])&lt;/code&gt;：前三个元素和三元组相同，第四个元素是包含了模式中所有分组的列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则函数可配合其他函数如 &lt;code&gt;getAllTextMatchs&lt;/code&gt; 来获取更多结果：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;ghci&lt;/span&gt;&amp;gt; (&lt;span class=&quot;string&quot;&gt;&quot;foo buot&quot;&lt;/span&gt; =~ &lt;span class=&quot;string&quot;&gt;&quot;(oo|uo)&quot;&lt;/span&gt;) :: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;oo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;uo&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;文件系统路径&quot;&gt;&lt;a href=&quot;#文件系统路径&quot; class=&quot;headerlink&quot; title=&quot;文件系统路径&quot;&gt;&lt;/a&gt;文件系统路径&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Haskell 的文件系统处理函数主要由 &lt;code&gt;System.Directory&lt;/code&gt; 提供，如 &lt;code&gt;doesDirectoryExist&lt;/code&gt;、&lt;code&gt;doesFileExist&lt;/code&gt;、&lt;code&gt;getCurrentDirectory&lt;/code&gt;、&lt;code&gt;getDirectoryContents&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.FilePath&lt;/code&gt; 主要处理文件路径，由两个模块构成：&lt;code&gt;System.FilePath.Posix&lt;/code&gt; 和 &lt;code&gt;System.FilePath.Windows&lt;/code&gt;，二者接口完全相同，适配平台不同。包含函数如：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getSearchPath&lt;/code&gt;：获得 $PATH 环境变量内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;/&amp;gt;&lt;/code&gt;：将两个字符串用 &lt;code&gt;/&lt;/code&gt; 合为一个路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;.&amp;gt;&lt;/code&gt;：将后缀名结合，等价于 &lt;code&gt;addExtension&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&amp;lt;.&amp;gt;&lt;/code&gt;：去掉后缀名并添加一个新的后缀名，等价于 &lt;code&gt;replaceExtension&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dropTrailingPathSeparator&lt;/code&gt;：去掉文件路径后的分隔符，如 &lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splitFileName&lt;/code&gt;：返回将路径切割为父级目录和文件名的二元组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;常见-I-O-异常处理&quot;&gt;&lt;a href=&quot;#常见-I-O-异常处理&quot; class=&quot;headerlink&quot; title=&quot;常见 I/O 异常处理&quot;&gt;&lt;/a&gt;常见 I/O 异常处理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;异常处理的几个常用函数包含在 &lt;code&gt;Control.Exception&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle :: (Exception -&amp;gt; IO a) -&amp;gt; IO a -&amp;gt; IO a&lt;/code&gt; 接收的第一个参数是一个函数，该函数接受一个异常值并且返回 IO Monad，第二个参数是可能抛出异常的 IO Monad。当第二个 IO Monad 执行出现异常时，作为 &lt;code&gt;handle&lt;/code&gt; 第一个参数的函数会接收产生的异常值，并返回自己的 IO Monad；当第二个参数执行无异常时， &lt;code&gt;handle&lt;/code&gt; 返回值与第二个参数相同。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;handle&lt;/code&gt; 的使用中可使用 &lt;code&gt;const&lt;/code&gt; 忽略传入的异常。const 接收两个参数，无论第二个参数是什么都返回第一个参数：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;handle (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [])) (code_may_cause_exception)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []) :: Monad &lt;span class=&quot;keyword&quot;&gt;m&lt;/span&gt; =&amp;gt; b -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;m&lt;/span&gt; [t]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;也可以使用 &lt;code&gt;finally&lt;/code&gt; 捕获异常，其类型签名为 &lt;code&gt;finally:: IO a-&amp;gt; IO b -&amp;gt; IO a&lt;/code&gt;，无论第一个 IO Monad 成功或失败，第二个 IO Monad 都会执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bracket&lt;/code&gt; 可以看作 Haskell 中的 &lt;code&gt;defer&lt;/code&gt;：如果你试图获取一个资源，对该资源做一些操作，并想在操作结束后释放这个资源，则可以使用 &lt;code&gt;bracket&lt;/code&gt; 来保证最终资源的释放。&lt;br&gt;&lt;code&gt;bracket&lt;/code&gt; 接收三个参数，第一个参数用于资源的获取，它的返回值会传给第二、三个参数，而第二个参数对应资源的释放，第三个参数为对资源的操作，它的返回值也是整个 &lt;code&gt;bracket&lt;/code&gt; 函数的返回值。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bracket :: IO a&lt;span class=&quot;function&quot;&gt; -&amp;gt;&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(a -&amp;gt; IO b)&lt;/span&gt; -&amp;gt;&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(a -&amp;gt; IO c)&lt;/span&gt; -&amp;gt;&lt;/span&gt; IO c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bracket&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (openFile &lt;span class=&quot;string&quot;&gt;&quot;filename&quot;&lt;/span&gt; ReadMode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (hClose)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;string&quot;&gt;\fileHandle&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123; ... &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;当不需要获取第一个参数的返回值时，或这几个操作之间并无关系，使用 &lt;code&gt;bracket_ :: IO a -&amp;gt; IO b -&amp;gt; IO c -&amp;gt; IO c&lt;/code&gt; 替代 &lt;code&gt;bracket&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果仅希望释放操作在执行操作出现异常时调用，则使用 &lt;code&gt;bracketOnError:: IO a -&amp;gt; (a -&amp;gt; IO b) -&amp;gt; (a -&amp;gt; IO c) -&amp;gt; IO c&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/30/efficient-haskell-io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/30/efficient-haskell-io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/30/efficient-haskell-io/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Haskell 提高 I/O 效率的技巧及资源控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Language" scheme="http://forec.github.io/categories/Language/"/>
    
    
      <category term="Haskell" scheme="http://forec.github.io/tags/Haskell/"/>
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
      <category term="函数式编程" scheme="http://forec.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（七）：死锁</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-7/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-7/</id>
    <published>2016-11-24T14:16:22.000Z</published>
    <updated>2017-01-05T15:47:07.998Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版死锁部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;死锁模型&quot;&gt;&lt;a href=&quot;#死锁模型&quot; class=&quot;headerlink&quot; title=&quot;死锁模型&quot;&gt;&lt;/a&gt;死锁模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;多道程序环境下，多个进程竞争有限资源。如果某个进程需求的资源被其他进程占用，则该进程可能被永久阻塞，这种情况称为 &lt;strong&gt;死锁（deadlock）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;进程按照如下顺序使用资源：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;申请（Request）&lt;/strong&gt; ：如果申请不能被允许（如资源正在被其他进程占用），则申请进程必须等待直到获得资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用（Use）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放（Release）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源的申请和释放都是系统调用，如设备的 &lt;code&gt;request()/release()&lt;/code&gt;，文件的 &lt;code&gt;open()/close()&lt;/code&gt;，内存的 &lt;code&gt;allocate()/free()&lt;/code&gt; 等。对于进程或线程的每次执行，操作系统会检查并确保它们以获得所需资源。系统维护一张记录表，说明某个资源是否空闲，被分配给哪个进程。&lt;/li&gt;
&lt;li&gt;永久性资源可分为：&lt;ul&gt;
&lt;li&gt;可剥夺资源（可重用资源）：当进程所占有的并使用的资源被剥夺时，对进程不产生破坏性影响（如内存、CPU）&lt;/li&gt;
&lt;li&gt;不可剥夺资源：如打印机等，一旦剥夺则任务执行失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;死锁特征&quot;&gt;&lt;a href=&quot;#死锁特征&quot; class=&quot;headerlink&quot; title=&quot;死锁特征&quot;&gt;&lt;/a&gt;死锁特征&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;以下四个条件（四个条件并不完全独立）同时成立时，死锁产生：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥（mutual exclusion）&lt;/strong&gt; ：至少有一个资源处于互斥模式，即该资源同时只能由一个进程使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;占有并等待（hold and wait）&lt;/strong&gt; ：进程必须占有至少一个资源，并且等待另一资源，且等待的资源已被其他进程占有。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非抢占（no preemptive）&lt;/strong&gt; ：资源不能被抢占。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环等待（circular wait）&lt;/strong&gt; ：一组等待进程 &lt;code&gt;{P0, p1, ..., pn}&lt;/code&gt;，其中 Pi 等待的资源被 Pi+1 占有，Pn 等待的资源被 P0 占有。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁问题可用 &lt;strong&gt;系统资源分配图（system resource-allocation  graph）&lt;/strong&gt; 描述：&lt;ul&gt;
&lt;li&gt;该图的节点集合 V 分为系统活动进程集合 &lt;code&gt;P = {P1, P2, ..., Pn}&lt;/code&gt; 和系统资源类型集合 &lt;code&gt;R = {R1, R2, ..., Rm}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从进程 Pi 到资源类型 Rj 的有向边记为 &lt;code&gt;Pi → Rj&lt;/code&gt;，称为 &lt;strong&gt;申请边（request edge）&lt;/strong&gt; ，表示进程 Pi 已经申请并正在等待资源类型 Rj 的一个实例。&lt;/li&gt;
&lt;li&gt;从资源类型 Rj 到进程 Pi 的有向边记为 &lt;code&gt;Rj → Pi&lt;/code&gt;，称为 &lt;strong&gt;分配边（assignment edge）&lt;/strong&gt; ，表示资源类型 Rj 的一个实例已经分配给进程 Pi。&lt;/li&gt;
&lt;li&gt;在图上用圆形表示进程 Pi，用矩形表示资源类型 Rj，资源类型的多个实例在矩形中用圆点表示。&lt;/li&gt;
&lt;li&gt;申请边只需指向矩形 Rj，分配边的源点需要指定矩形内部的某个圆点。&lt;/li&gt;
&lt;li&gt;当进程 Pi 申请资源类型 Rj 的一个实例时，在资源分配图中加入一条申请边，当该申请可以满足时将该申请边 &lt;strong&gt;立即&lt;/strong&gt; 转换为分配边。当进程释放资源时，该分配边从图中删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可证明：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果分配图中不存在环，则系统未发生进程死锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果分配图中存在环且每个资源类型仅有一个实例，则系统已处于进程死锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果分配图中存在环，且存在某个资源类型有多个实例，则系统可能处于进程死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个带有死锁的资源分配图如下图所示：&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/resource-allocation-graph-with-deadlock.jpg&quot; width=&quot;200px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;死锁处理&quot;&gt;&lt;a href=&quot;#死锁处理&quot; class=&quot;headerlink&quot; title=&quot;死锁处理&quot;&gt;&lt;/a&gt;死锁处理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;三种方法可以处理死锁：&lt;ul&gt;
&lt;li&gt;使用某种协议预防或避免死锁，确保系统不进入死锁状态&lt;/li&gt;
&lt;li&gt;允许系统进入死锁状态，且系统可以检测到死锁并恢复&lt;/li&gt;
&lt;li&gt;忽视死锁问题，认为系统中不可能发生死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数操作系统采用第三种（包括 UNIX 和 Windows），因此死锁由应用程序员处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁预防&quot;&gt;&lt;a href=&quot;#死锁预防&quot; class=&quot;headerlink&quot; title=&quot;死锁预防&quot;&gt;&lt;/a&gt;死锁预防&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据死锁特征，只要破坏四个条件中的一个使之不同时成立即可实现 &lt;strong&gt;死锁预防（prevention）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;破坏互斥：非共享资源必须满足互斥条件，因此此条件无法破坏&lt;/li&gt;
&lt;li&gt;破坏占有并等待：必须保证一个进程不能在已经占有其他资源的情况下再申请一个资源，两种方法可选（两种方法 &lt;strong&gt;&lt;em&gt;资源利用率均较低&lt;/em&gt;&lt;/strong&gt; ，且 &lt;strong&gt;&lt;em&gt;可能导致饥饿&lt;/em&gt;&lt;/strong&gt; ，需要多个常用资源的进程可能会永久等待）：&lt;ul&gt;
&lt;li&gt;每个进程在执行前申请并获得执行期间所需的全部资源；&lt;/li&gt;
&lt;li&gt;仅允许进程在没有资源时才可申请资源，在它申请更多资源前必须释放全部已持有资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;破坏非抢占：如果一个进程在占有一些资源的同时申请了另一个不能立刻被分配的资源（等待列表中的其他进程也没有持有该资源），则该进程目前已获得的所有资源都可被其它正在等待的进程抢占。也就是说，该进程持有的资源被隐式释放了。该进程要想重新执行，必须分配到要申请的资源，同时还要恢复自己在等待时被抢占的资源。此协议通常用于状态可以保存和恢复的资源，如 CPU 寄存器和内存，对于不可剥夺资源无效。&lt;/li&gt;
&lt;li&gt;破坏循环等待：系统定义一个函数 &lt;code&gt;F: R → N&lt;/code&gt; 为资源类型集合编号，不同资源类型的编号不同。每个 &lt;strong&gt;进程只能按照递增顺序申请资源&lt;/strong&gt; ，进程开始执行时可以申请任意数量的资源类型 Ri 的实例，之后若想申请资源类型 Rj 的实例，则必须满足 &lt;code&gt;F(Rj) &amp;gt; F(Ri)&lt;/code&gt; 才可申请，否则它必须释放所有编号 &lt;strong&gt;大于&lt;/strong&gt; F(Rj) 的资源后才能再申请。&lt;ul&gt;
&lt;li&gt;证明：若存在循环等待，设循环等待的进程集合为 &lt;code&gt;{P0, P1, ..., Pn}&lt;/code&gt; ，其中 Pi 等待资源 Ri，且 Ri 被进程 Pi+1 占有，因为 Pi+1 占有资源 Ri 且申请资源 Ri+1，所以对所有 i 有 &lt;code&gt;F(Ri) &amp;lt; F(Ri+1)&lt;/code&gt;，即 &lt;code&gt;F(R0) &amp;lt; F(R1) &amp;lt; ... &amp;lt; F(Rn) &amp;lt; F(R0)&lt;/code&gt;，假设不成立。&lt;/li&gt;
&lt;li&gt;按照此协议，程序员必须按系统为资源定义的顺序来编写程序才可防止死锁。有些软件（如 Witness）可以验证资源锁是否按顺序获取，并对不按顺序获取的代码做出警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以上通过限制资源申请来预防死锁的方法可行，但会降低设备使用率和系统吞吐率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁避免&quot;&gt;&lt;a href=&quot;#死锁避免&quot; class=&quot;headerlink&quot; title=&quot;死锁避免&quot;&gt;&lt;/a&gt;死锁避免&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;死锁避免（deadlock-avoidance）&lt;/strong&gt; 算法动态监测资源分配状态以保证循环等待条件无法成立，同时它要求进程提供一定的 &lt;strong&gt;先验信息&lt;/strong&gt; ，例如进程执行期间可能需要使用的每种资源类型实例的最大数量。&lt;/li&gt;
&lt;li&gt;若系统中的进程按照某个特定顺序执行不会产生死锁，则此时系统处于安全状态，这个进程执行的顺序称为 &lt;strong&gt;安全序列（safe sequence）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;安全状态必然不会导致死锁，不安全状态可能会导致死锁状态，死锁状态必然是不安全状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源分配图算法&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;适用于每个资源只有一个实例的系统；&lt;/li&gt;
&lt;li&gt;向系统资源分配图中加入一种新类型的边，称为 &lt;strong&gt;需求边（claim edge）&lt;/strong&gt; 。需求边 &lt;code&gt;Pi-&amp;gt;Rj&lt;/code&gt; 表示进程 Pi 可能在将来某时刻申请资源 Rj，需求边用虚线表示。当 Pi 申请资源 Rj 时，需求边 &lt;code&gt;Pi-&amp;gt;Rj&lt;/code&gt;变为申请边，当进程 Pi 释放资源 Rj 时，分配边 &lt;code&gt;Rj-&amp;gt;Pi&lt;/code&gt; 变成需求边；&lt;/li&gt;
&lt;li&gt;若进程 Pi 试图申请资源 Rj，则系统需要检查：如果需求边 &lt;code&gt;Pi-&amp;gt;Rj&lt;/code&gt; 变成分配边 &lt;code&gt;Rj-&amp;gt;Pi&lt;/code&gt; 后，资源分配图中不存在环（虚实线无所谓），则允许申请，否则进程 Pi 必须等待。&lt;/li&gt;
&lt;li&gt;系统检查是否存在环可使用 Tarjan 等求联通子图的 n² 级算法。&lt;/li&gt;
&lt;li&gt;一个资源分配图算法的实例如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/resource-allocation-graph-algorithm.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;银行家（Banker’s）算法&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;适用于每种资源类型有多个实例的情形，效率低于资源分配图&lt;/li&gt;
&lt;li&gt;银行家算法需要在进程请求资源时检查分配后的状态是否保持安全。使用下面的安全性算法可确定系统是否处于安全状态，算法的时间复杂度为 mn²。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;银行家算法使用的数据结构：&lt;ul&gt;
&lt;li&gt;Available：长度为 m 的向量，表示每种资源当前可用的（未被分配给进程的）实例数量&lt;/li&gt;
&lt;li&gt;Max：n × m 的矩阵，&lt;code&gt;Max[i][j]&lt;/code&gt; 表示进程 Pi 在整个生命周期中需要申请资源类型 Rj 实例的最大数量&lt;/li&gt;
&lt;li&gt;Allocation：n × m 矩阵，&lt;code&gt;Allocation[i][j]&lt;/code&gt; 表示进程 Pi 当前已经持有（已被分配）的资源类型 Rj 的实例数量；Allocation 的第 i 行记作 &lt;code&gt;Allocation[i,]&lt;/code&gt;，表示进程 Pi 当前持有的不同资源类型的数量。&lt;/li&gt;
&lt;li&gt;Need：n × m 矩阵，&lt;code&gt;Need[i][j] = Max[i][j] - Allocation[i][j]&lt;/code&gt;，表示进程 Pi 还可能申请多少个 Rj 类型的资源实例；Need 的第 i 行记作 &lt;code&gt;Need[i,]&lt;/code&gt;，表示进程 Pi 结束前可能仍要申请的不同资源数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性算法&lt;/strong&gt; ：&lt;ol&gt;
&lt;li&gt;令 &lt;code&gt;Work = Available&lt;/code&gt; 为长度为 m 的行向量，表示每种资源当前剩余可用的实例数量；令 &lt;code&gt;Finish=[False for i = 0 to n-1]&lt;/code&gt; 为长度为 n 的行向量，初始化全部为 False，表示进程当前是否已结束执行。&lt;/li&gt;
&lt;li&gt;寻找一个正在执行的进程 Pi，并且 &lt;code&gt;Need[i,] ≤ Work&lt;/code&gt;，即：&lt;code&gt;Finish[i] == False &amp;amp;&amp;amp; Need[i,] ≤ Work&lt;/code&gt;，这意味着当前系统剩余资源能够满足 Pi 的全部需求。若不存在这样的进程，则调到第 4 步。&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;Work = Work + Allocation[i,]&lt;/code&gt; ，令 &lt;code&gt;Finish[i] = True&lt;/code&gt; 并跳回第 2 步。这意味着进程 Pi 已经执行结束，并且它所持有的资源全部释放，因此系统可用资源数量 &lt;code&gt;Work&lt;/code&gt; 增加。注意这一步实际 &lt;strong&gt;等价于对资源分配图的化简&lt;/strong&gt; ，它将一个可消去的进程（即该进程可以得到资源并执行完）和所有该进程与相关资源连接的边从资源分配图中删去。&lt;/li&gt;
&lt;li&gt;检查所有的 i，是否都有 &lt;code&gt;Finish[i] == True&lt;/code&gt;，若是则系统处于安全状态，否则系统处于不安全状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;安全性算法的 C 语言大致表述：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; NUM_PROCESS &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; NUM_RESOURCE &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; TRUE &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; FALSE &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; Boolean &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Available[NUM_PROCESS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Max[NUM_PROCESS][NUM_RESOURCE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Allocation[NUM_PROCESS][NUM_RESOURCE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Need[NUM_PROCESS][NUM_RESOURCE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Boolean &lt;span class=&quot;title&quot;&gt;safe&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean Finish[NUM_PROCESS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Work[NUM_PROCESS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, j, k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(Finish, FALSE, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(Boolean) * NUM_PROCESS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;memcpy&lt;/span&gt;(Work, Available, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) * NUM_PROCESS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; NUM_PROCESS; k++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NUM_PROCESS; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 寻找满足条件的 Pi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Finish[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Boolean flag = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Need[i][j] &amp;gt; Work[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    flag = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (flag)&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 寻找到进程 Pi 满足条件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Work[j] += Allocation[i][j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Finish[i] = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 进程 Pi 结束执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; NUM_PROCESS; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!Finish[k])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源请求算法&lt;/strong&gt; ：判断进程对资源的申请是否可以维持安全性。设申请资源的进程为 Pi，&lt;code&gt;Request[i,]&lt;/code&gt; 为一个长度为 m 的行向量，表示进程 Pi 要申请的不同资源实例数量。&lt;ol&gt;
&lt;li&gt;若 &lt;code&gt;Request[i,] ≤ Need[i,]&lt;/code&gt; 则转到第 2 步，否则产生出错条件（进程 Pi 要申请的资源数量超过了它此前声明的可能使用的最大资源数量）&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;Request[i,] ≤ Available&lt;/code&gt; 则转第 3 步，否则 Pi 等待（剩余资源不满足 Pi 的请求）&lt;/li&gt;
&lt;li&gt;假设系统剩余资源足够 Pi 使用，则系统计算修改后的状态是否安全，若安全则允许修改，不安全则 Pi 必须等待。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;资源请求算法的 C 语言大致表述为：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Boolean &lt;span class=&quot;title&quot;&gt;allocate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *Request)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Request[j] &amp;gt; Need[i][j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; False;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Request[j] &amp;gt; Allocation[i][j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            wait();    &lt;span class=&quot;comment&quot;&gt;// 进程 Pi 必须等待资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Available[j] -= Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Allocation[i][j] += Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Need[i][j] -= Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 假设可以分配&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!safe())&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 分配后不安全，恢复状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Available[j] += Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Allocation[i][j] -= Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Need[i][j] += Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;死锁检测&quot;&gt;&lt;a href=&quot;#死锁检测&quot; class=&quot;headerlink&quot; title=&quot;死锁检测&quot;&gt;&lt;/a&gt;死锁检测&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果一个系统既不采用死锁预防算法，也不采用死锁避免算法，则该系统可能出现死锁。此时，系统应当提供：&lt;ul&gt;
&lt;li&gt;检查系统是否出现死锁的算法&lt;/li&gt;
&lt;li&gt;从死锁状态中恢复的算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个资源类型仅存在一个实例：可以使用资源分配图的变种 &lt;strong&gt;等待（wait-for）图&lt;/strong&gt; ，该图删去了资源分配图中的资源节点，而将原图中所有 &lt;code&gt;Pi-&amp;gt;Rj-&amp;gt;Pk&lt;/code&gt;　的边转化为 &lt;code&gt;Pi-&amp;gt;Pk&lt;/code&gt;，即进程 Pi 正在等待进程 Pk 掌握的资源。如果等待图中有环存在，则系统存在死锁。为了检测死锁，系统要维护这个等待图，并且周期性的在图中调用检测算法，该算法时间复杂度为 n²，n 为系统中进程数。&lt;/li&gt;
&lt;li&gt;每种资源类型存在多个实例：算法与银行家算法类似，仍采用 &lt;code&gt;Available&lt;/code&gt;，&lt;code&gt;Allocation&lt;/code&gt; 和 &lt;code&gt;Request&lt;/code&gt; 三个变量保存系统状态，其中此处的 &lt;code&gt;Request&lt;/code&gt; 是一个 n × m 的矩阵，&lt;code&gt;Request[i][j]&lt;/code&gt; 表示进程 Pi 当前正在申请的资源类型 Rj 的数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁检测算法&lt;/strong&gt; ，时间复杂度为 mn²：&lt;ol&gt;
&lt;li&gt;令 &lt;code&gt;Work = Available&lt;/code&gt; 为长度为 m 的行向量，表示每种资源当前剩余可用的实例数量；令 &lt;code&gt;Finish&lt;/code&gt; 为长度为 n 的行向量，若进程 Pi 当前未持有任何资源（Allocation[i,] == 0）则 &lt;code&gt;Finish[i] = True&lt;/code&gt;，否则 &lt;code&gt;Finish[i] = False&lt;/code&gt;。这里将不持有资源的进程设置 Finish 为 True 是因为，不持有资源的进程不会对死锁产生影响，不会有其它进程在等待该进程，这实际 &lt;strong&gt;等价于等待图中的孤立点&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;寻找一个正在执行的进程 Pi，并且 &lt;code&gt;Request[i,] ≤ Work&lt;/code&gt;，即：&lt;code&gt;Finish[i] == False &amp;amp;&amp;amp; Request[i,] ≤ Work&lt;/code&gt;，这意味着当前系统剩余资源能够满足 Pi 此刻的需求。若不存在这样的进程，则调到第 4 步。&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;Work = Work + Allocation[i,]&lt;/code&gt; 且令 &lt;code&gt;Finish[i] = True&lt;/code&gt;；跳回第 2 步。&lt;/li&gt;
&lt;li&gt;检查是否存在某个 i 有 &lt;code&gt;Finish[i] == False&lt;/code&gt;，若存在则系统处于死锁状态，且进程 Pi 死锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;注意上面的死锁检测算法的第 2 步：如果 &lt;code&gt;Request[i,] ≤ Work&lt;/code&gt; 就回收进程 Pi 的资源。这是基于如下假定，如果 Pi 不会参与到死锁中（因为 &lt;code&gt;Request[i,] ≤ Work&lt;/code&gt;，Pi的需求可以被满足所以此时一定不会被死锁），则 &lt;strong&gt;乐观地认为 Pi 直到执行结束都不会再申请更多的资源&lt;/strong&gt; 。这里的假定可能不正确，如果假定不正确，Pi 在之后又申请了更多的资源，则在系统下次运行死锁检测算法时仍然会发现，所以这里的假定不影响算法正确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用检测算法的频率&lt;/strong&gt; 受如下两个因素影响：&lt;ul&gt;
&lt;li&gt;死锁可能发生的概率多少：如果经常发生死锁则应该经常调用检测算法&lt;/li&gt;
&lt;li&gt;死锁发生时有多少进程会受影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;考虑极端情况：每当出现进程请求资源不能被立刻允许的情况时就调用死锁检测算法，则系统不仅能确定哪些进程处于死锁，还能确定导致死锁的特定进程（实际上是死锁环上的每个节点共同导致了死锁）。此种方式会导致巨大的计算开销。但如果使用较低的频率调用检测算法，或当 CPU 使用率低于某个阈值时，则调用检测算法无法确定涉及死锁的进程中是哪些导致了死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁恢复&quot;&gt;&lt;a href=&quot;#死锁恢复&quot; class=&quot;headerlink&quot; title=&quot;死锁恢复&quot;&gt;&lt;/a&gt;死锁恢复&lt;/h2&gt;&lt;h3 id=&quot;进程终止&quot;&gt;&lt;a href=&quot;#进程终止&quot; class=&quot;headerlink&quot; title=&quot;进程终止&quot;&gt;&lt;/a&gt;进程终止&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;两种方法通过终止进程来取消死锁，被终止的进程所持有的所有资源都会被系统回收：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;终止所有死锁进程&lt;/strong&gt; ：代价较大，有些进程可能已经运行很长时间而不得不放弃&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每次终止一个进程，直到死锁状态取消&lt;/strong&gt; ：开销较大，每终止一个进程都需要重新调用死锁检测算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当采用部分终止时，确定终止哪个进程/哪个进程可以打破死锁的因素涉及：&lt;ul&gt;
&lt;li&gt;进程优先级&lt;/li&gt;
&lt;li&gt;进程已运行的时间和完成任务所需要的剩余时间&lt;/li&gt;
&lt;li&gt;进程使用了哪些、多少资源，以及资源是否可抢占&lt;/li&gt;
&lt;li&gt;进程仍需多少资源&lt;/li&gt;
&lt;li&gt;有多少进程需要被终止&lt;/li&gt;
&lt;li&gt;交互进程还是批处理进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;资源抢占&quot;&gt;&lt;a href=&quot;#资源抢占&quot; class=&quot;headerlink&quot; title=&quot;资源抢占&quot;&gt;&lt;/a&gt;资源抢占&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;死锁的恢复也可以通过抢占资源来逐步取消死锁状态，需要处理三个问题：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择被抢占对象（victim）&lt;/strong&gt; ：抢占哪些进程和资源，这和死锁恢复中部分终止要考虑的因素类似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回滚（rollback）&lt;/strong&gt; ：如果从某个进程抢占资源，则被抢占的进程需要回滚到某个安全状态以便之后重新执行。完全回滚（终止被抢占的进程并重启该进程）比较容易，更有效的方式是将进程回滚到足够打破死锁的状态，但这需要系统维护更多关于进程状态的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;饥饿&lt;/strong&gt; ：如何确保不会总从同一个进程抢占资源。通常会考虑回滚次数，确保一个进程只能被抢占有限次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（六）：管程（Monitor）&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/03/os-concepts-8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（八）：内存管理&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-7/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版死锁部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（六）：管程（Monitor）</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-6/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-6/</id>
    <published>2016-11-24T12:47:03.000Z</published>
    <updated>2017-01-06T12:34:52.416Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章 Monitor 部分的理论和概念，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;信号量提供了方便的机制处理进程同步，但不正确的使用信号量仍会导致时序错误，且难以检测。如：&lt;ul&gt;
&lt;li&gt;先对信号量 &lt;code&gt;signal()&lt;/code&gt; 再 &lt;code&gt;wait()&lt;/code&gt; 违反了互斥请求&lt;/li&gt;
&lt;li&gt;对信号量始终调用 &lt;code&gt;wait()&lt;/code&gt; 将导致死锁&lt;/li&gt;
&lt;li&gt;一个进程遗漏了 &lt;code&gt;wait()&lt;/code&gt; 或 &lt;code&gt;signal()&lt;/code&gt; 将导致死锁且可能破坏互斥&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管程（monitor）&lt;/strong&gt; 类型提供了一组由程序员定义的、在管程内互斥的操作。管程内定义的子程序只能访问位于管程内的局部变量和形式参数，管程内的局部变量也只能被管程内部的局部子程序访问。 &lt;strong&gt;管程结构确保了同时只能有一个进程在管程内活动&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;管程内部可定义 &lt;code&gt;condition&lt;/code&gt; 类型的变量以提供同步机制，称其为条件变量。条件变量可执行操作 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;我个人对条件变量的理解和信号量类似：&lt;ul&gt;
&lt;li&gt;条件变量存在于管程内部，对同一个条件变量调用操作的进程将和条件变量建立一定的联系，或者称之为绑定。对于管程内的条件变量 x，进程 P 调用 &lt;code&gt;x.wait()&lt;/code&gt; 将时自身挂起到条件变量 x 上；当另一个进程调用 &lt;code&gt;x.signal()&lt;/code&gt;时，在 x 上悬挂的进程会被重启，如果此时没有进程悬挂在 x 上，则 &lt;code&gt;x.signal()&lt;/code&gt; 操作将被忽略。&lt;/li&gt;
&lt;li&gt;管程模式下的 &lt;code&gt;x.signal()&lt;/code&gt; 和信号量的 &lt;code&gt;signal()&lt;/code&gt; 区别在于： &lt;strong&gt;信号量操作 &lt;code&gt;signal()&lt;/code&gt; 会影响信号量的状态&lt;/strong&gt; ，而管程下的 &lt;code&gt;x.signal()&lt;/code&gt; 在 x 不存在挂起进程的情况下没有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;举例：进程 P 调用 &lt;code&gt;x.signal()&lt;/code&gt;，且存在悬挂进程 Q 与条件变量 x 关联。根据管程的性质，若进程 Q 开始执行，则进程 P 必须等待。此时可能存在两种可能性，且两种可能性均有合理解释：&lt;ul&gt;
&lt;li&gt;进程 Q 重启且进程 P 等待：进程 P 将等待，直到进程 Q 离开管程或者等待另一个进程调用 &lt;code&gt;x.signal()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进程 P 唤醒进程 Q 且进程 P 继续执行：进程 Q 被唤醒，但仍然会等待，直到进程 P 离开管程，或者另一个触发条件。因为 P 已经在管程中执行，看起来此种方案更合理，但这破坏了进程 Q 正在等待的逻辑条件，进程 Q 已被触发但又未执行，因此状态难以描述&lt;/li&gt;
&lt;li&gt;Pascal 语言采用折中方式，当进程 P 执行 &lt;code&gt;x.signal()&lt;/code&gt; 时，它会立刻离开管程，且进程 Q 会立刻重新执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;哲学家进餐问题的管程解法&quot;&gt;&lt;a href=&quot;#哲学家进餐问题的管程解法&quot; class=&quot;headerlink&quot; title=&quot;哲学家进餐问题的管程解法&quot;&gt;&lt;/a&gt;哲学家进餐问题的管程解法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;strong&gt;&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程同步&lt;/a&gt;&lt;/strong&gt; 中的一种策略：当哲学家在两只筷子均可用的情况下才拿起筷子，且拿起两只筷子的动作是非抢占的。&lt;/li&gt;
&lt;li&gt;为哲学家设置三种状态：&lt;code&gt;enum {THINKING, HUNGRY, EATING} state[5]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;哲学家 i 只有在两个邻居都不进餐时才能将变量 &lt;code&gt;state[i]&lt;/code&gt; 设置为 &lt;code&gt;EATING&lt;/code&gt;，当他处在饥饿状态又无法进餐时可以使自己忍耐一段时间：&lt;code&gt;(state[(i-1)%5] != EATING) &amp;amp;&amp;amp; (state[(i+1)%5] != EATING)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下面给出用管程解决的哲学家进餐问题，只解决了互斥问题，不会导致死锁，但可能导致某个哲学家过度饥饿而死。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor dp&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &amp;#123;THINKING, HUNGRY, EATING&amp;#125; state[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition self[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[i] = HUNGRY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (state[i] != EATING)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[i].wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[i] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test((i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test((i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state[(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] != EATING) &amp;amp;&amp;amp; (state[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] != EATING))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = EATING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[i].signal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initialization_code()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;一个改进版的 Monitor 解决方案如下。筷子本身并不属于 monitor 的一部分，否则同时只能有一个哲学家在进餐。代码中 &lt;code&gt;NUM_PHILS&lt;/code&gt; 是哲学家数目。此代码解决了哲学家饥饿问题，来自&lt;a href=&quot;http://www.csee.wvu.edu/~jdm/classes/cs550/notes/tech/mutex/dp-mon.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西弗吉尼亚大学&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor dp&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition self[NUM_PHILS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; states &amp;#123;THINKING, HUNGRY, EATING&amp;#125; state[NUM_PHILS-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initialization_code()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (index=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; index&amp;lt;NUM_PHILS; index++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            flags[index] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[i] = HUNGRY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state[(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] != EATING) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (state[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] != EATING))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = EATING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 挂起，等待相邻哲学家改变状态时唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[i].wait;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// wait 操作被唤醒后可以改变状态为 EATING&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = EATING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[i] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 唤醒左侧哲学家&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state [(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] == HUNGRY) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (state [(i-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)%NUM_PHILS] != EATING))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS].signal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 唤醒右侧哲学家&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state [(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] == HUNGRY) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (state [(i+&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)%NUM_PHILS] != EATING))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS].signal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;使用信号量实现管程&quot;&gt;&lt;a href=&quot;#使用信号量实现管程&quot; class=&quot;headerlink&quot; title=&quot;使用信号量实现管程&quot;&gt;&lt;/a&gt;使用信号量实现管程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;要实现的管程对于重启进程采用的策略是： &lt;strong&gt;调用 &lt;code&gt;x.signal()&lt;/code&gt; 的进程挂起自己，直到重新启动的进程离开或者等待&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;每个管程都有一个信号量 &lt;code&gt;mutex&lt;/code&gt; 初始化为 1，进程进入管程之前必须通过 &lt;code&gt;wait()&lt;/code&gt; 获得允许，离开时需要调用 &lt;code&gt;signal()&lt;/code&gt; 释放权限。&lt;/li&gt;
&lt;li&gt;信号量 &lt;code&gt;next&lt;/code&gt; 初始化为 0，供线程在唤醒重启进程时挂起自己，整数变量 &lt;code&gt;next_count&lt;/code&gt; 用于对挂起在 &lt;code&gt;next&lt;/code&gt; 上的进程数量计数。&lt;/li&gt;
&lt;li&gt;进入管程的外部子程序结构 F 如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 子程序执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 子程序执行结束&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (next_count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(next);    &lt;span class=&quot;comment&quot;&gt;//     此前有进程挂起，重启该进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(mutex);   &lt;span class=&quot;comment&quot;&gt;//     管程内无进程挂起，释放控制权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;对每个管程内的条件变量 &lt;code&gt;x&lt;/code&gt;，引入信号量 &lt;code&gt;x_sem&lt;/code&gt; 和整数变量 &lt;code&gt;x_count&lt;/code&gt; 记录信号量 x 上挂起的进程数量，均初始化为 0。&lt;code&gt;x.wait()&lt;/code&gt; 和 &lt;code&gt;x.signal()&lt;/code&gt; 实现如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; x.wait()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x_count++;            &lt;span class=&quot;comment&quot;&gt;// 将进程挂起到 x 上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (next_count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;// 当前仍有进程挂起在管程中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(mutex);    &lt;span class=&quot;comment&quot;&gt;// 无进程在等待，释放管程控制权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(x_sem);          &lt;span class=&quot;comment&quot;&gt;// 等待信号量 x_sem，由信号量决定唤醒哪个挂起进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x_count--;            &lt;span class=&quot;comment&quot;&gt;// 等待结束，进程被唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; x.signal()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x_count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;     &lt;span class=&quot;comment&quot;&gt;// 当前有程序挂起在条件变量 x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_count ++;    &lt;span class=&quot;comment&quot;&gt;// 自己将要被阻塞，故管程挂起数增加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(x_sem);    &lt;span class=&quot;comment&quot;&gt;// 释放信号量，唤醒一个挂起进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(next);       &lt;span class=&quot;comment&quot;&gt;// 将自身阻塞到管程中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_count--;     &lt;span class=&quot;comment&quot;&gt;// 被唤醒，继续执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 没有程序挂起在条件变量 x，不产生任何影响&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（五）：进程同步&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（七）：死锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-6/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章 Monitor 部分的理论和概念，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（五）：进程同步</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-5/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-5/</id>
    <published>2016-11-24T10:41:33.000Z</published>
    <updated>2017-01-05T04:56:48.082Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程同步部分的理论和概念，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;信号量&quot;&gt;&lt;a href=&quot;#信号量&quot; class=&quot;headerlink&quot; title=&quot;信号量&quot;&gt;&lt;/a&gt;信号量&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基于硬件的 &lt;code&gt;TestAndSet()&lt;/code&gt; 和 &lt;code&gt;Swap()&lt;/code&gt; 对应用程序员而言相对复杂，可使用 &lt;strong&gt;信号量（semaphore）&lt;/strong&gt; 作为同步工具。信号量 S 是整数变量，除初始化外只能通过两个原子操作访问：&lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt;，在有些地方使用 &lt;code&gt;P&lt;/code&gt;（测试） 和 &lt;code&gt;V&lt;/code&gt;（增加）表示。所有关于信号量的讨论均已具备以下前提：在这两个原子访问操作中，对信号量整型值的测试和修改都是不可分的，也就是说，当一个进程修改某个信号量时，其他进程都不能同时操作该信号量。&lt;/li&gt;
&lt;li&gt;信号量按值域可分为&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;计数信号量（counting semaphore）&lt;/strong&gt; ：信号量值域不受限制。此类信号量用于控制访问具有若干个实例的某类资源，初始化信号量为可用资源的数量，进程通过调用 &lt;code&gt;wait()&lt;/code&gt; 操作获取资源（此时信号量计数也随之减少），进程使用资源后通过 &lt;code&gt;signal()&lt;/code&gt; 操作释放资源（信号量计数随之增加）。当信号量的值小于等于 0 时，所有调用 &lt;code&gt;wait()&lt;/code&gt; 操作的进程会被阻塞，直到某个进程调用了 &lt;code&gt;signal()&lt;/code&gt; 释放了可用资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二进制信号量（binary semaphore）&lt;/strong&gt; ：信号量的值只能为 0 或者 1，该类信号量也称为 &lt;strong&gt;互斥锁（mutex locks）&lt;/strong&gt; ，可提供互斥操作。对于多进程的临界区问题，可以使所有进程共享一个二进制信号量 mutex，每个进程进入临界区之前调用 &lt;code&gt;waiting(mutex)&lt;/code&gt; ，离开临界区之前调用 &lt;code&gt;signal(mutex)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号量按功能可分：&lt;ul&gt;
&lt;li&gt;公有（互斥）信号量：多个进程均需要同一个信号量所代表的资源，信号量起到了互斥的作用&lt;/li&gt;
&lt;li&gt;私有（同步）信号量：部分进程向信号量释放资源，其他进程向信号量请求资源，信号量起到了同步的作用，保证了进程之间执行的先后顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;信号量的主要缺点是 &lt;strong&gt;忙等待（busy waiting）&lt;/strong&gt; ，当一个进程位于临界区内时，其它试图进入临界区的进程都陷入循环检查的状态。这样的信号量也称为 &lt;strong&gt;旋转锁（spinlock）&lt;/strong&gt; ，它也具有优点：进程在等待锁时不会进行上下文切换（上下文切换可能会花费很长的时间），因此如果等待锁的时间较短则旋转锁更有效。旋转锁通常用于多处理器系统，一个线程在某个处理器旋转时，另一个线程在另一个处理器的临界区内执行。&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;进程执行 &lt;code&gt;wait()&lt;/code&gt; 时若信号量值不为正则调用 &lt;code&gt;block()&lt;/code&gt; 操作将其阻塞，阻塞操作包括：将该进程状态切换为等待，将该进程放到信号量内部的一个等待队列中。之后 CPU 调度程序选择另一个进程执行。&lt;/li&gt;
&lt;li&gt;进程执行 &lt;code&gt;signal()&lt;/code&gt; 操作后，信号量值会增加。同时若存在进程阻塞在信号量上，则操作系统从信号量内部等待队列中选取一个进程，调用 &lt;code&gt;wakeup()&lt;/code&gt; 操作将其唤醒，唤醒操作包括：将该进程从等待状态切换到就绪状态、放入就绪队列中（根据 CPU 调度算法，CPU 不一定会选择这个线程立刻执行）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号量的 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt; 操作可定义如下，每个信号量包括一个整型值和一个 PCB 链表指针，使用 FIFO 队列可确保有限等待，但一般来说链表可以使用任何排队策略，信号量的使用方式和链表排队策略无关：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; process *&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// PCB 块链表指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; semaphore;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(semaphore *S)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    S-&amp;gt;value--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (S-&amp;gt;value &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 无可用资源，将进程加入信号量等待列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(semaphore *S)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    S-&amp;gt;value++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (S-&amp;gt;value &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 从信号量等待列表中选取一个进程唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wakeup(P);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;信号量的 &lt;em&gt;关键在于它们的执行具有原子性&lt;/em&gt; 。在单处理器上，可在调用 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt; 时禁止中断，而在多处理器系统上，仍需要使用其它加锁计数（如旋转锁）来确保信号量的原子性，因此信号量本身的实现还是没有完全取消忙等，仅仅是 &lt;em&gt;把忙等的状态从等待进入临界区转移到了临界区执行时&lt;/em&gt; ，因为经过合理设计的临界区通常比较短，因此比简单的忙等效率高一些。但在临界区很长的情况下，因为采用了忙等，导致信号量极为低效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁和饥饿&quot;&gt;&lt;a href=&quot;#死锁和饥饿&quot; class=&quot;headerlink&quot; title=&quot;死锁和饥饿&quot;&gt;&lt;/a&gt;死锁和饥饿&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当两个或多个进程无限等待一个事件，而该事件只能由等待该事件的某个进程来触发（执行 signal 操作），这种情况下，这些进程称为 &lt;strong&gt;死锁（deadlocked）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;链表的出入顺序对信号量有影响，如果采用 LIFO 顺序增加、取出进程，则可能导致 &lt;strong&gt;无穷阻塞（indefinite blocking）&lt;/strong&gt; 或 &lt;strong&gt;饥饿（starvation）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;经典同步问题&quot;&gt;&lt;a href=&quot;#经典同步问题&quot; class=&quot;headerlink&quot; title=&quot;经典同步问题&quot;&gt;&lt;/a&gt;经典同步问题&lt;/h1&gt;&lt;h2 id=&quot;有限缓冲问题&quot;&gt;&lt;a href=&quot;#有限缓冲问题&quot; class=&quot;headerlink&quot; title=&quot;有限缓冲问题&quot;&gt;&lt;/a&gt;有限缓冲问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程互斥&lt;/a&gt;&lt;/strong&gt; 中的生产者-消费者问题可以通过三个信号量解决：&lt;ul&gt;
&lt;li&gt;二进制信号量 &lt;code&gt;mutex&lt;/code&gt; 保证了对缓冲池访问的互斥&lt;/li&gt;
&lt;li&gt;计数信号量 &lt;code&gt;empty&lt;/code&gt; 和 &lt;code&gt;full&lt;/code&gt; 表示缓冲区中空余数量和已有数据数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生产者和消费者进程使用如下架构保证互斥和同步：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// producer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// produce an item&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(empty);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// put item into buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(full);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// consumer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(full);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// remove an item from buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(empty);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;读者-写者问题&quot;&gt;&lt;a href=&quot;#读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;读者-写者问题&quot;&gt;&lt;/a&gt;读者-写者问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个数据库可以被多个并发进程共享，有的进程只需要读数据库，而有的进程需要读或写数据库。将只需要读权限的进程称为 &lt;strong&gt;读者（Reader）&lt;/strong&gt; ，需要写权限的进程称为 &lt;strong&gt;写者（Writer）&lt;/strong&gt; 。如果一个写者和其它进程（无论读写）同时访问共享对象，则可能导致混乱。&lt;/li&gt;
&lt;li&gt;有多种优先级方案：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一读者-写者问题&lt;/strong&gt; ：读者优先，如果当前获得数据库权限的是读者进程，则其它读者进程无需等待，读者进程只有在当前操作数据库的进程是写者的情况下才需要阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二读者-写者问题&lt;/strong&gt; ：写者优先，任何在等待获取数据库权限的写者进程都将比其它正在等待的读者进程先获得权限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三读者-写者问题&lt;/strong&gt; ：前两种策略都会导致写者或者读者的饥饿，此策略将保证没有任何进程会被无限阻塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读者-写者问题在以下情况非常有效：&lt;ul&gt;
&lt;li&gt;当进程可以按照对共享对象所需的读写权限划分时&lt;/li&gt;
&lt;li&gt;当读者进程数比写者进程数多时：因为读写锁的建立开销比信号量或互斥锁要大，此开销可通过允许多个读者并发来弥补&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第一读者-写者问题&quot;&gt;&lt;a href=&quot;#第一读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;第一读者-写者问题&quot;&gt;&lt;/a&gt;第一读者-写者问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;读优先，只要当前有读者在操作对象，所有读者都可以加入操作而不必等待。&lt;/li&gt;
&lt;li&gt;进程共享如下数据：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;semaphore mutex, wrt&lt;/code&gt;：二者均初始化为 1，信号量 &lt;code&gt;wrt&lt;/code&gt; 用作读写进程的互斥锁，信号量 &lt;code&gt;mutex&lt;/code&gt; 则用于确保更新变量 &lt;code&gt;readcount&lt;/code&gt; 时互斥。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int readcount&lt;/code&gt;：跟踪当前有多少个进程正在读对象，初始化为 0。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写者-读者进程结构如下，代码来自原书（英文版）第 206 页。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行写操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 若此读进程为等待的第一个读者，则需要先获取对象的权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行读操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 若此读进程为最后一个离开的读者，则需要释放对象权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;第二读者-写者问题&quot;&gt;&lt;a href=&quot;#第二读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;第二读者-写者问题&quot;&gt;&lt;/a&gt;第二读者-写者问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;写优先，只要当前有写者在操作对象，所有写者都将排队等待，中间不允许读者插入。只有所有写者完成处理后，读者才有机会访问。&lt;/li&gt;
&lt;li&gt;进程之间共享如下数据：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int readcount, writecount&lt;/code&gt;：&lt;code&gt;readcount&lt;/code&gt; 记录当前正在等待读对象的读者数量，&lt;code&gt;writecount&lt;/code&gt; 记录当前正在等待写对象的写者数量，均初始化为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore rmutex, wmutex&lt;/code&gt;：确保更新变量 &lt;code&gt;readcount&lt;/code&gt; 和 &lt;code&gt;writecount&lt;/code&gt; 时的互斥，均初始化为 1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore readTry&lt;/code&gt;：&lt;code&gt;readTry&lt;/code&gt; 信号量用于声明有读者加入等待队列，确保读者和写者之间的互斥，初始化为 1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore resource&lt;/code&gt;：&lt;code&gt;resource&lt;/code&gt; 信号量用于确保写者和写者之间的互斥，初始化为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读者-写者结构如下，基本算法来自维基百科。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 读者必须在当前没有写者在操作对象时才可进入等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保证了写优先&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个读者需要获取资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最后一个离开的读者需要释放资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writecount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (writecount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个写者需要禁止其他读者进入等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 进入临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 写操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 离开临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writecount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (writecount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最后一个离开的写者需要释放资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;第三读者-写者问题&quot;&gt;&lt;a href=&quot;#第三读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;第三读者-写者问题&quot;&gt;&lt;/a&gt;第三读者-写者问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;保证读者和写者均不会出现饥饿现象。&lt;/li&gt;
&lt;li&gt;进程之间共享的信号量有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int readCount&lt;/code&gt;：当前正在访问对象的读者数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore resourceAccess&lt;/code&gt;：资源的控制权限，使读者、写者互斥，初始化为 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore readCountAccess&lt;/code&gt;：保证对 &lt;code&gt;readCount&lt;/code&gt; 操作的互斥，初始化为 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore serviceQueue&lt;/code&gt;：保持请求的顺序，维护先进先出特性，初始化为 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读者-写者结构如下，基本算法来自维基百科。可能有多个进程在服务队列中等待，当前进入临界区的进程离开后，等待的进程就会接替离开的进程。当 &lt;code&gt;serviceQueue&lt;/code&gt; 中阻塞了多个进程时，选择进程唤醒的顺序取决于信号量的链表，因此 &lt;strong&gt;&lt;code&gt;serviceQueue&lt;/code&gt; 的链表必须维持 FIFO 特性才能保证不会导致饥饿&lt;/strong&gt; 。因此，解决饥饿问题实际是由链表的 FIFO 带来的。另一个值得注意的地方是，无论写者还是读者，获得了服务队列的权限后，在获取资源控制权前都将禁止其他任何进程接受服务，而因为只有紧随写者进程的读者才需要获取资源权限，所以在此算法中读者可以同时并发访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在服务队列中等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readCount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个读者要从写者手中接管资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 允许下一个进程进入服务队列等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readCount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readCount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最后一个离开的读者要释放资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;哲学家进餐问题&quot;&gt;&lt;a href=&quot;#哲学家进餐问题&quot; class=&quot;headerlink&quot; title=&quot;哲学家进餐问题&quot;&gt;&lt;/a&gt;哲学家进餐问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题描述：假设有 5 个哲学家共用一个圆桌，每人左右两边各有一根筷子，哲学家之间不互相交流。当哲学家感到饥饿时会依次拿起自己身边的筷子（一次只能拿起一根筷子、不能从其它哲学家手中拿筷子），当哲学家同时拥有两根筷子时可以开始进餐，否则将等待空闲的筷子（且并不放下已握在手中的筷子），吃完后他将放下两只筷子。&lt;/li&gt;
&lt;li&gt;一种简单方法是每根筷子使用一个信号量，哲学家通过 &lt;code&gt;wait()&lt;/code&gt; 请求相应的筷子，通过 &lt;code&gt;signal()&lt;/code&gt; 释放相应的筷子。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(chopstick[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(chopstick[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 进餐&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(chopstick[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(chopstick[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上面的算法解决了筷子的互斥问题，但可能导致死锁。若五个哲学家同时拿起同一边的筷子，则所有人都将永远等待。可行的解决方法有：&lt;ul&gt;
&lt;li&gt;最多只允许四个哲学家同时坐在桌上&lt;/li&gt;
&lt;li&gt;只有两只筷子都可用时才允许一个哲学家拿起筷子，且拿起两只筷子的操作在临界区内进行&lt;/li&gt;
&lt;li&gt;编号为奇数的哲学家先拿起左边的筷子再拿起右边的筷子，编号为偶数的哲学家先拿起右边的筷子再拿起左边的筷子&lt;/li&gt;
&lt;li&gt;Dijkstra解法：每个哲学家都先拿起身边编号较小的筷子，再拿起编号较高的筷子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 Dijkstra 解法的哲学家就餐问题解法如下，伪代码根据维基百科的算法描述编写。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;philosopher&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    leftChopstickIndex = index;    &lt;span class=&quot;comment&quot;&gt;// 左侧筷子编号为哲学家编号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rightChopstickIndex = (index + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % Philosophers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    firstIndex = min(leftChopstickIndex, rightChopstickIndex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondIndex = max(leftChopstickIndex, rightChopstickIndex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(chopstick[firstIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(chopstick[secondIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 进餐&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(chopstick[firstIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(chopstick[secondIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 释放资源的顺序可随意&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（四）：进程互斥&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（六）：管程（Monitor）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-5/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程同步部分的理论和概念，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（四）：进程互斥</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-4/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-4/</id>
    <published>2016-11-24T07:29:44.000Z</published>
    <updated>2017-01-06T11:58:33.867Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程互斥部分的理论和概念，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;生产者-消费者冲突模型&quot;&gt;&lt;a href=&quot;#生产者-消费者冲突模型&quot; class=&quot;headerlink&quot; title=&quot;生产者-消费者冲突模型&quot;&gt;&lt;/a&gt;生产者-消费者冲突模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;生产者-消费者（producer-consumer）&lt;/strong&gt; 问题：生产者进程产生用来被消费者进程消耗的数据，例如一个编译器产生汇编代码，此代码交由汇编器生成对象。生产者、消费者进程之间可通过共享内存来传递数据，可分为：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无限缓冲（unbounded buffer）&lt;/strong&gt; ：共享内存大小没有限制，当缓冲区为空时，消费者进程需要等待；生产者进程在任何时候都可以直接向缓冲区中投放数据而无需等待&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限缓冲（bounded buffer）&lt;/strong&gt; ：内存共享的缓冲区域大小固定，若缓冲区为空则消费者进程需要等待；若缓冲区已满则生产者进程需要等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;雏形&quot;&gt;&lt;a href=&quot;#雏形&quot; class=&quot;headerlink&quot; title=&quot;雏形&quot;&gt;&lt;/a&gt;雏形&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;采用共享内存、有限缓冲的生产者消费者代码如下（原书 99 页第三章初次介绍共享内存模型时的代码）。共享缓冲通过循环数组和两个逻辑指针 &lt;code&gt;in&lt;/code&gt;、&lt;code&gt;out&lt;/code&gt; 实现，变量 &lt;code&gt;in&lt;/code&gt; 指向缓冲中下一个空位，&lt;code&gt;out&lt;/code&gt; 指向缓冲中的下一个待取走的数据位，&lt;code&gt;(in+1)%BUFFER_SIZE == out&lt;/code&gt; 时缓冲区满。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; BUFFER_SIZE &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item buffer[BUFFER_SIZE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; in = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; out = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// producer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item nextProduced;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (((in + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE) == out) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buffer[in] = nextProduced;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    in = (in + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// consumer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item nextConsumed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (in == out) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nextConsumed = buffer[out];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    out = (out+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上面的代码存在缺陷，生产者、消费者进程能够使用的最大缓冲区为 BUFFER_SIZE - 1，并且代码也没有解决生产者、消费者进程同时访问共享内存的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;改进&quot;&gt;&lt;a href=&quot;#改进&quot; class=&quot;headerlink&quot; title=&quot;改进&quot;&gt;&lt;/a&gt;改进&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为使进程能够使用全部缓冲区，使用一个初始化为 0 的整数变量 &lt;code&gt;counter&lt;/code&gt; 记录当前缓冲区中的元素数量；每当生产者向缓冲区投放数据，&lt;code&gt;counter&lt;/code&gt; 递增；当消费者从缓冲区取走数据，&lt;code&gt;counter&lt;/code&gt; 递减。可修改上面代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// producer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (counter == BUFFER_SIZE) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buffer[in] = nextProduced;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    in = (in+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// consumer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (counter == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nextConsumed = buffuer[out];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    out = (out+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;以上代码可使用全部缓冲区资源，但当消费者进程和生产者进程并发执行时，涉及修改 &lt;code&gt;counter&lt;/code&gt; 的语句执行顺序将由操作系统设定。由于 C 语言中 &lt;code&gt;counter++&lt;/code&gt; 将被拆分为 &lt;code&gt;mov register, counter&lt;/code&gt;、&lt;code&gt;inc register&lt;/code&gt; 和 &lt;code&gt;mov counter, register&lt;/code&gt; 三句汇编指令，假设由于操作系统的调度，当前消费者进程和生产者进程分别执行到 &lt;code&gt;counter++&lt;/code&gt; 和 &lt;code&gt;counter--&lt;/code&gt; 的最后一条汇编指令处，则 &lt;code&gt;counter&lt;/code&gt; 的值将不正确。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;竞争条件（race condition）&lt;/strong&gt; ：多个进程同时访问和操作一个相同的数据，且执行结果和访问的特定顺序有关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程同步（process synchronization）&lt;/strong&gt; 和 &lt;strong&gt;协调（coordination）&lt;/strong&gt; ：确保系统不同部分操作资源不会互相影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;临界区&quot;&gt;&lt;a href=&quot;#临界区&quot; class=&quot;headerlink&quot; title=&quot;临界区&quot;&gt;&lt;/a&gt;临界区&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;系统中有 n 个进程&lt;code&gt;{P0, P1, ..., Pn-1}&lt;/code&gt;，每个进程有一个代码段称为 &lt;strong&gt;临界区（critical section）&lt;/strong&gt; ，在该区域中，不同的进程可能会改变相同的数据。临界区中应当最多同时存在一个进程。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;临界区问题&lt;/em&gt; 指设计一个使进程协作的协议：&lt;ul&gt;
&lt;li&gt;每个进程需先请求进入临界区（请求的代码称为 &lt;strong&gt;进入区，entry section&lt;/strong&gt; ）；&lt;/li&gt;
&lt;li&gt;获得允许，进入临界区执行&lt;/li&gt;
&lt;li&gt;退出临界区（ &lt;strong&gt;退出区，exit section&lt;/strong&gt; ）&lt;/li&gt;
&lt;li&gt;执行剩余代码（ &lt;strong&gt;剩余区，remainder section&lt;/strong&gt; ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;临界区问题的解决必须满足如下三个要求：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥（mutual exclusion）&lt;/strong&gt; ：若进程 Pi 正在其临界区内，则其他进程都不能在临界区中执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发展（前进，progress）&lt;/strong&gt; ：如果当前没有进程在临界区内，并且有一些进程在请求进入临界区，则只有不处在剩余区的进程可以参与到选择（选择哪个进程进入临界区）中。这个选择不能被无限期推迟，即必须立刻作出决定。简单的说， &lt;strong&gt;进入临界区请求的选择不应当受当前在剩余区执行进程的影响&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限等待（bounded waiting）&lt;/strong&gt; ：从一个进程发出进入临界区请求，到该请求被允许，这期间只能有有限的其它进程进入临界区。即保证了每个进程都有机会进入临界区而不会饥饿。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;假定每个进程的执行速度都不为 0，但是不能对 n 个进程的 &lt;strong&gt;相对速度（relative speed）&lt;/strong&gt; 做任何假设。&lt;/li&gt;
&lt;li&gt;操作系统内部的临界区问题：操作系统内同一时刻可能有多个处于内核模式的活动进程，有两种方法解决。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抢占内核（preemptive kernel）&lt;/strong&gt; ：允许处于内核模式的进程被抢占。此模式可能导致竞争条件，在对称多处理器体系中，此模式更难设计。但此模式适合实时编程，响应更快（Linux 2.6之后内核和 Solaris、IRIX 均为抢占内核）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非抢占内核（nonpreemptive kernel）&lt;/strong&gt; ：不允许处于内核模式的进程被抢占，处于内核模式的进程会一直运行，直到其退出内核模式、阻塞或者自动释放对 CPU 的控制。这种方式根本不会导致竞争条件的产生。Windows XP、Windows 2000 和传统 UNIX 均为非抢占内核。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Peterson-算法&quot;&gt;&lt;a href=&quot;#Peterson-算法&quot; class=&quot;headerlink&quot; title=&quot;Peterson 算法&quot;&gt;&lt;/a&gt;Peterson 算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Peterson 算法&lt;/strong&gt; 是对基于软件的临界区问题的经典解答，但由于现代计算机体系结构执行基本语言指令的不同方式，该算法在此类机器上不能正确执行。&lt;/li&gt;
&lt;li&gt;Peterson 算法仅适用于两个进程（P0和P1），它们都在临界区和剩余区间交替执行。以下当使用 Pi 表示一个进程时，使用 Pj 表示另一个（j == 1-i）。&lt;/li&gt;
&lt;li&gt;Peterson 算法需要在进程间共享两个数据项：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int turn&lt;/code&gt;：指定哪个进程可以进入临界区，若 turn == i，则 Pi 被允许&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean flag[2]&lt;/code&gt;：&lt;code&gt;flag[i]&lt;/code&gt; 表示进程 i 已发出进入临界区请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Peterson 算法中进程 Pi 的结构如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flag[i] = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    turn = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (flag[j] &amp;amp;&amp;amp; turn == j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flag[i] = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Peterson 算法正确性的证明：&lt;ul&gt;
&lt;li&gt;互斥：只有当 &lt;code&gt;flag[j] == FALSE&lt;/code&gt; 或 &lt;code&gt;turn == i&lt;/code&gt; 时 Pi 才进入临界区。假设 Pi 和 Pj 同时进入临界区，则 &lt;code&gt;flag[0] == flag[1] == TRUE&lt;/code&gt;，因为 turn 只能为 0 或 1，所以只有一个进程（假设 &lt;code&gt;turn == i&lt;/code&gt;）Pi 能够跳出 While 语句。此外，只要 Pi 在临界区内，&lt;code&gt;flag[i] == TRUE &amp;amp;&amp;amp; turn == i&lt;/code&gt; 就始终成立，所以 Pi 在临界区执行期间，Pj 将始终等待或执行剩余区内容。&lt;/li&gt;
&lt;li&gt;发展和有限等待：进程 Pi 仅在 &lt;code&gt;flag[j] == True&lt;/code&gt; 且 &lt;code&gt;turn == j&lt;/code&gt; 的情况下才会被阻塞，若 Pj 不准备进入临界区，则 &lt;code&gt;flag[j] == False&lt;/code&gt;，此时 Pi 可以进入；若 Pj 当前也在请求进入临界区，则 &lt;code&gt;flag[j] == True&lt;/code&gt;，此时由 turn 决定哪个进程进入临界区。假设此时 Pj 进入临界区，当 Pj 退出临界区时会设置 &lt;code&gt;flag[j]&lt;/code&gt; 为 False 使 Pi 进入临界区；如果 Pj 剩余区执行速度非常快，又重新申请进入临界区，此时 Pj 设置 &lt;code&gt;flag[j]&lt;/code&gt; 为 TRUE，同时 turn 被设置为 i。因此 Pi 一定会进入临界区（发展），并且最多需要等待一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Bakery-算法（补充）&quot;&gt;&lt;a href=&quot;#Bakery-算法（补充）&quot; class=&quot;headerlink&quot; title=&quot;Bakery 算法（补充）&quot;&gt;&lt;/a&gt;Bakery 算法（补充）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Bakery 算法适用于 n 个进程的临界区问题。&lt;/li&gt;
&lt;li&gt;在进入临界区之前，进程需要申请一个号码，拥有最小号码的进程会被允许进入临界区。如果两个进程 Pi 和 Pj 申请到的号码相同（申请号码不是临界区，因此可能获得相同号码），则比较进程编号 i 和 j，编号小的先执行。&lt;/li&gt;
&lt;li&gt;进程可申请到的号码始终是递增的。定义元组比较为 &lt;code&gt;(a, b) &amp;lt; (c, d) if a &amp;lt; c || a == c &amp;amp;&amp;amp; b &amp;lt; d&lt;/code&gt;，定义最大值函数 &lt;code&gt;max(a0, a1, ..., an-1)&lt;/code&gt; 为 a0 ~ an-1 中的最大值。&lt;/li&gt;
&lt;li&gt;Bakery 算法使用的共享数据有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boolean choosing[n]&lt;/code&gt;：&lt;code&gt;choosing[i] == TRUE&lt;/code&gt; 表明进程 Pi 当前正在申请进入临界区或者正在临界区中执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int number[n]&lt;/code&gt;：&lt;code&gt;number[i]&lt;/code&gt; 为进程 Pi 当前申请到的号码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bakery 算法流程如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    choosing[i] = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    number[i] = max(number[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], number[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], ..., number[n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    choosing[i] = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; n; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 此循环保证所有比当前进程持更高优先级的进程已离开临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (chossing[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (number[j] != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (number[j], j) &amp;lt; (number[i], i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    number[i] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Bakery 算法正确性证明：&lt;ul&gt;
&lt;li&gt;首先，元组的大小比较和取号规则（只增）保证了全部进程都可维持一个严格递增的顺序，而不会出现两个进程地位相等的情况。&lt;/li&gt;
&lt;li&gt;互斥：假设进程 Pi 已进入临界区，则 for 循环保证了，当前所有进程，号码比 Pi 的号码小的进程均已不在临界区，而号码比 Pi 大的进程将因为 &lt;code&gt;number[i] != 0&lt;/code&gt; 而被阻塞在它们自己的 for 循环中，因此仅有 Pi 可进入临界区。互斥条件满足。&lt;/li&gt;
&lt;li&gt;发展：假设一个进程 Pj 执行完临界区，则其进入剩余区之前将使 &lt;code&gt;number[j] == 0&lt;/code&gt;，此时所有在等待进入临界区的进程中，按元组比较最小的那个进程将因为 &lt;code&gt;number[j] == 0&lt;/code&gt; 而跳出 while 循环，此后它将跳过剩余的 for 循环（因为其它进程的元组均大于它）并进入临界区，而其它进程都将继续等待。因此在剩余区的进程（Pj）不会影响到进入临界区申请的选择。&lt;/li&gt;
&lt;li&gt;有限等待：假设一个进程 Pi 已经申请到号码 &lt;code&gt;number[i]&lt;/code&gt;，此时所有后申请进入临界区的进程 Pj 都会有 &lt;code&gt;number[j] &amp;gt; number[i]&lt;/code&gt;，且在 Pi 执行完临界区之前，Pj 都会因为 &lt;code&gt;number[i] != 0&lt;/code&gt; 且 &lt;code&gt;number[i] &amp;lt; number[j]&lt;/code&gt; 而阻塞。因此进程 Pi 至多等待 n-1 个进程即可进入临界区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;硬件同步&quot;&gt;&lt;a href=&quot;#硬件同步&quot; class=&quot;headerlink&quot; title=&quot;硬件同步&quot;&gt;&lt;/a&gt;硬件同步&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;无论软硬件方式，解决临界区问题都需要 &lt;strong&gt;锁（lock）&lt;/strong&gt; ，所有解决方案都基于锁，且锁的设计可能非常复杂。进程在进入临界区之前获得锁，退出临界区时释放锁。&lt;/li&gt;
&lt;li&gt;硬件特性可以简化编程并提高效率。现代计算机系统提供了特殊硬件指令以允许程序 &lt;strong&gt;原子（atomically）&lt;/strong&gt; 检查和修改字地内容或交换两个字地内容。以下的 &lt;code&gt;TestAndSet()&lt;/code&gt; 和 &lt;code&gt;Swap()&lt;/code&gt; 函数均为原子操作，即硬件保证了它们作为一个完整过程执行而不会被抢占。它们的定义如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;boolean &lt;span class=&quot;title&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(boolean *target)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean rv = *target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *target = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; rv;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(boolean *a, boolean *b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean temp = *a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *a = *b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;仅使用 &lt;code&gt;TestAndSet()&lt;/code&gt; 或仅使用 &lt;code&gt;Swap()&lt;/code&gt; 都可以解决互斥问题。以下是单独使用这二者实现的互斥，但均未满足有限等待的要求：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// TestAndSet Lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TestAndSetLock(&amp;amp;&lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;FALSE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Swap Lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    key = &lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(key == &lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Swap(&amp;amp;&lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt;, &amp;amp;key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;FALSE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;TestAndSet()&lt;/code&gt; 或 &lt;code&gt;Swap()&lt;/code&gt; 也可以解决有限等待问题，以下是使用 &lt;code&gt;TestAndSet()&lt;/code&gt; 实现的有限等待互斥，代码为进程 Pi 的结构，来自原书（英文版）第 199 页。可以看出，剩余区前的 while 循环保证一个进程 Pi 强制拉取了排在其后的进程 Pj 进入临界区（如果有的话），这保证了有限等待。使用到的共享数据有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boolean waiting[n]&lt;/code&gt;：&lt;code&gt;waiting[i] == TRUE&lt;/code&gt; 表明进程 i 已申请进入临界区并正在等待选择&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean lock&lt;/code&gt;：lock 是进程间共享的锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    waiting[i] = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    key = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (waiting[i] &amp;amp;&amp;amp; key)    &lt;span class=&quot;comment&quot;&gt;// 进程排队&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        key = TestAndSet(&amp;amp;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    waiting[i] = FALSE;          &lt;span class=&quot;comment&quot;&gt;// 进程标注自己已进入临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    j = (i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((j != i) &amp;amp;&amp;amp; !waiting[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j = (j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (j == i)                  &lt;span class=&quot;comment&quot;&gt;// 当前无其他进程排队则释放锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lock = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        waiting[j] = FALSE;      &lt;span class=&quot;comment&quot;&gt;// 强制拉取后一个进程进入临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/23/os-concepts-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（三）：CPU 调度&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（五）：进程同步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-4/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程互斥部分的理论和概念，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
</feed>
