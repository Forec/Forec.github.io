<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Forec&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://forec.github.io/"/>
  <updated>2017-01-11T14:47:38.752Z</updated>
  <id>http://forec.github.io/</id>
  
  <author>
    <name>Forec</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互斥读者-读者问题</title>
    <link href="http://forec.github.io/2017/01/08/os-concepts-16/"/>
    <id>http://forec.github.io/2017/01/08/os-concepts-16/</id>
    <published>2017-01-08T09:52:59.000Z</published>
    <updated>2017-01-11T14:47:38.752Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在 &lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（专题）：信号量编程（上）&lt;/a&gt; 中，我对《操作系统概念》原书课后习题 7.16 过桥问题做了一定改动，此部分记录对改动后题目的分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;注：以下解法均已通过程序验证，不会发生饥饿或死锁，验证代码可在 &lt;a href=&quot;https://github.com/Forec/semaphore-test&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt; 查看。&lt;/p&gt;
&lt;h2 id=&quot;村庄过桥问题&quot;&gt;&lt;a href=&quot;#村庄过桥问题&quot; class=&quot;headerlink&quot; title=&quot;村庄过桥问题&quot;&gt;&lt;/a&gt;村庄过桥问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原题大致翻译（原书 7.16）：一座桥连接了南北两个村庄，两个村庄的居民可以从桥上通过，但桥上不能同时承载两个人（无论同方向还是相向）。使用信号量保证死锁和饥饿都不会发生。&lt;/li&gt;
&lt;li&gt;我个人对此题编写的信号量解法如下，通过两个互斥信号量均衡双方争夺过桥权限的次数：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_waiting_north = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_waiting_south = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// 南北方等待过桥人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore mutex_south = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore mutex_north = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// 南北方等待过桥人数修改互斥锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore bridge = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;          &lt;span class=&quot;comment&quot;&gt;// 过桥权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore north_entry = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore south_entry = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 南北参与争夺桥的权限，开始双方均允许争夺&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_north&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 北方居民试图过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num_waiting_north ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(north_entry);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 将自己加入等待队列，如果等待队列有资源就可以等待桥资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num_waiting_north --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex_south);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (num_waiting_south == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 若南方当前无人准备过桥则本次过桥不计入争夺次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(north_entry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 若南方有居民准备过桥则允许南方等待队列中的一个居民争夺过桥权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(south_entry);      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex_south);   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_south&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 南方居民试图过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 与北方居民对称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;互斥读者-读者问题&quot;&gt;&lt;a href=&quot;#互斥读者-读者问题&quot; class=&quot;headerlink&quot; title=&quot;互斥读者-读者问题&quot;&gt;&lt;/a&gt;互斥读者-读者问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在 &lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（专题）：信号量编程（下）&lt;/a&gt; 的 “简单信号量编程” 部分中，北京大学 1992 年的入学考试题实际也是对书后习题 7.16 的改动，即 &lt;strong&gt;同一方向允许多辆车依次通过但不允许两辆车相对行驶&lt;/strong&gt; ，但未要求不发生饥饿。&lt;/li&gt;
&lt;li&gt;再对原题做了一点改变：将原题条件改成同一方向同时允许多个居民依次通过但不允许两个居民相向行走， &lt;strong&gt;同时保证不发生饥饿现象&lt;/strong&gt; 。 &lt;strong&gt;新的题目和原来的两道题目的主要区别&lt;/strong&gt; 在于：&lt;ul&gt;
&lt;li&gt;与教材 7.16 相比，教材 7.16 要求桥上任何时刻最多只能有一个人，而新的题目允许桥上 &lt;strong&gt;同时&lt;/strong&gt; 出现多个同方向的居民。即原题要求 &lt;strong&gt;依次&lt;/strong&gt; 通过，所以即使是同方向的居民也需要等待；新的题目允许 &lt;strong&gt;同时&lt;/strong&gt; 通过，即同方向的居民无需等待。&lt;/li&gt;
&lt;li&gt;与北京大学 1992 入学考试题相比，原题允许同方向多辆车同时通过，但未要求保证不发生饥饿，而新的题目要求保证不发生饥饿现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我个人认为改造后的问题等价为读者-写者问题的变种：将读者-写者问题中的写者也换成另一类读者，并且要保证没有饥饿现象。因此我将改造后的问题称作 &lt;strong&gt;互斥读者-读者问题&lt;/strong&gt; ，只需要对第三读者写者问题中的写者稍作处理就可以使用第三读者写者问题的解法实现。我基于第三读者-写者问题编写的信号量解法如下，解法依赖于信号量自身进程队列的先进先出特性：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_waiting_north = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_waiting_south = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 南北等待人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore north_mutex = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore south_mutex = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 修改等待人数的互斥锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore bridge = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;         &lt;span class=&quot;comment&quot;&gt;// 桥资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;          &lt;span class=&quot;comment&quot;&gt;// 通过信号量的先进先出维护双方居民顺序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_north&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;   &lt;span class=&quot;comment&quot;&gt;// 北方居民尝试过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(&lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(north_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num_waiting_north++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (num_waiting_north == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个北方居民要获得桥的通过权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(&lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(north_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(north_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num_waiting_north --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (num_waiting_north == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最后一个离开的北方居民交出桥的通过权权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(north_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_south&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 南方居民尝试过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 与北方居民过桥对称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;对于上面改造后的问题，通过转换为第三读者-写者问题得到的解法 &lt;strong&gt;依赖于信号量进程队列的先进先出特性&lt;/strong&gt; 。我构想了另一种解法（下面的代码），但我认为这种解法有些过于复杂，并且依赖状态的记录。此算法已经经过程序验证。或者你有另外的解法，请一定要告诉我（在评论中留言或 &lt;a href=&quot;mailto:forec@bupt.edu.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点此&lt;/a&gt; 向我发送邮件）！&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 其它变量和上面代码相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; north_entered = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; south_entered = FALSE;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 我方自上次对方通过桥后是否又有人通过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore north_entry = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore south_entry = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 双方居民争夺桥权的资格&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_north&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;   &lt;span class=&quot;comment&quot;&gt;// 北方居民过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num_waiting_north ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(north_entry);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 此句必须放置在 num_waiting_north++ 后，否则一方通过后将再无机会&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 打断对方的权限，直到对方主动交出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (num_waiting_north == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个北方居民要获取桥的资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    north_entered = TRUE;    &lt;span class=&quot;comment&quot;&gt;// 标记北方已经有人通过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (num_waiting_south == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 南方无人等待过桥则允许下一个北方居民过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 如果南方有人过桥，过桥后一定会再次给北方机会所以跳过此步&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(north_entry); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num_waiting_north --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (south_entered) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(south_entry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        south_entered = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果有南方居民已经通过桥，则说明 south_entry 为 0，因为最后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 一个通过的南方居民没有机会对 south_entry 做 signal。这样最后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 一个离开的北方居民需要将 south_entry 置为 1，使南方居民能够获得过桥资格。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex_north);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_south&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 南方居民过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 与北方居民对称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十五）：信号量编程（下）&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：专栏已结束&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-16/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-16/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/08/os-concepts-16/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 &lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot;&gt;操作系统（专题）：信号量编程（上）&lt;/a&gt; 中，我对《操作系统概念》原书课后习题 7.16 过桥问题做了一定改动，此部分记录对改动后题目的分析。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（专题）：信号量编程（下）</title>
    <link href="http://forec.github.io/2017/01/08/os-concepts-15/"/>
    <id>http://forec.github.io/2017/01/08/os-concepts-15/</id>
    <published>2017-01-08T03:53:13.000Z</published>
    <updated>2017-01-11T15:10:32.859Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;此部分包括一些和 《&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;信号量编程（上）&lt;/a&gt;》 相比稍难的信号量编程习题，可能有一小部分超出了考试范畴。这部分习题的解答均根据我个人理解编写， &lt;strong&gt;不保证提供的答案绝对正确或最优&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;注 1：习题主要来自 2000 年左右的各高校入学考试题，部分来自网络以及经典的信号量问题。&lt;/li&gt;
&lt;li&gt;注 2：以下问题顺序随机，难度之间并无递增/递减关系，可能有部分问题超出考试范畴。但其中第 1 ~ 4 题和之前 &lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;信号量编程（上）&lt;/a&gt; 中的习题 7.16 类似，之间存在类比、递进的关系。&lt;/li&gt;
&lt;li&gt;注 3：我提供了一份比较简陋的代码，可以帮助你 &lt;strong&gt;测试设计的信号量算法是否正确&lt;/strong&gt; 。详细可查看本文末尾的 “信号量编程测试”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;单向行驶问题&quot;&gt;&lt;a href=&quot;#单向行驶问题&quot; class=&quot;headerlink&quot; title=&quot;单向行驶问题&quot;&gt;&lt;/a&gt;单向行驶问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;（北京大学 1992 年）有一座桥连接了南北两侧，两侧均有车辆试图到另一侧，桥上不允许两车交会，但允许相同方向多辆车依次通行（桥上可以有多个同方向的车）。用信号量实现交通管理。&lt;/li&gt;
&lt;li&gt;本题和 &lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;信号量编程（上）&lt;/a&gt; 中的习题 7.16 （过桥问题）类似，但过桥问题要求桥上同时只能通过一人且保证不出现饥饿现象（习题 7.15 不要求处理饥饿，7.16 要求保证不会发生饥饿），所以此处我将其称之为单向行驶问题。我对本题的进一步修改和分析记录在 &lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-16/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互斥读者-读者问题&lt;/a&gt; 中。&lt;/li&gt;
&lt;li&gt;分析：因为同方向允许多辆车连续通行，很容易联想到读者-写者问题的读者。在 &lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/#读者-写者问题&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（五）：进程互斥&lt;/a&gt; 里介绍的读者-写者问题中，允许多个到来的读者一起读数据库。将车辆视作读者，同方向到来的多个车辆可以依次通过而不必等待。既然允许多个读者，就必须记录当前的　“读者”，也就是这里的汽车数量。&lt;/li&gt;
&lt;li&gt;定义信号量和变量如下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;count1 = count2 = 0&lt;/code&gt; ：分别记录当前已经位于桥上的南北两个方向来车数量，显然两个变量要么均为 0，要么一个非 0 而另一个就必须为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mutex1 = mutex2 = 1&lt;/code&gt; ：用于控制对 &lt;code&gt;count1&lt;/code&gt; 和 &lt;code&gt;count2&lt;/code&gt; 的互斥操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bridge = 1&lt;/code&gt; ：过桥的权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count1 = count2 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore mutex1 = mutex2 = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore bridge = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 北方来车&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;car_from_north&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count1 ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count1 == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count1 --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count1 == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 南方来车与北方对称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;士兵过桥问题&quot;&gt;&lt;a href=&quot;#士兵过桥问题&quot; class=&quot;headerlink&quot; title=&quot;士兵过桥问题&quot;&gt;&lt;/a&gt;士兵过桥问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;独木桥的左右两端各停留一队士兵，左侧有 m 个，右侧有 n 个。两侧士兵均可上桥，但一旦有一侧士兵上桥，另一侧士兵必须等待已上桥一侧的士兵全部通过后才可上桥。试使用信号量描述此过程。&lt;/li&gt;
&lt;li&gt;分析：与单向行驶问题类似，只需要保证一方先全部通过即可。因此需要记录两侧的人数。&lt;/li&gt;
&lt;li&gt;定义变量和信号量：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int left = 0, right = 0&lt;/code&gt; ：记录左右两侧已经通过的士兵数目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore left_mutex = right_mutex = 1&lt;/code&gt; ：操作变量 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 的互斥锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore bridge = 1&lt;/code&gt; ：桥的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 左侧士兵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(left_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    left ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; number = left;  &lt;span class=&quot;comment&quot;&gt;// 临时变量记录自己是第几个通过的士兵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (left == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(left_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (number == m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(bridge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 右侧士兵与左侧同理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;有限双向行驶问题&quot;&gt;&lt;a href=&quot;#有限双向行驶问题&quot; class=&quot;headerlink&quot; title=&quot;有限双向行驶问题&quot;&gt;&lt;/a&gt;有限双向行驶问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;（南开大学 1997 年题）在南开大学和天津大学之间有一条小路 S -&amp;gt; T，小路中间有一个安全岛 M，安全岛能够同时容纳两辆自行车，可供两个已经从两端进入小路的自行车错车用。整个地图如下图，S 到 K 段的小路和 T 到 L 段的小路同时都只能允许一辆自行车通过。试设计一个算法，使来往的自行车都能顺利通过。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/nankai-tianda.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;此题和上面的单向行驶问题类似，但同时每个方向只能允许一辆车通过，并且允许两个方向各有来车一辆。此题和教材 7.16 过桥问题也非常相似。应当注意体会本题和单向行驶、习题 7.16 的区别与联系。&lt;/li&gt;
&lt;li&gt;分析：需要先确定需要用信号量维护的资源对象种类和数量。首先 S 端和 T 端能且仅能进入一辆自行车，直到进入的自行车从另一端离开，否则在我方通行两辆自行车期间，一旦对方有来车就会出现死锁。正因为 S 和 T 端最多只能进入一辆，所以安全岛 M 最多也只会出现两辆自行车，所以不需要为 M 设置信号量。此外，除了要控制路口 S 和 T 的进入权限，还要控制两段小路 S-K 和 L-T 的通行权限，不能允许从 S 方向进入的自行车和从 T 方向进入的自行车同时进入这两段小路。因此共有 4 个互斥信号量。&lt;/li&gt;
&lt;li&gt;声明信号量：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;semaphore S = T = 1&lt;/code&gt; ：两端最多允许进入一辆&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore SK = LT = 1&lt;/code&gt; ：两段小路最多允许进入一辆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// S 口进入的自行车&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(S);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(SK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通过 S-K 段小路&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(SK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 进入安全岛 M&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(LT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通过 L-T 段小路&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(LT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(S);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// T 口进入的自行车与 S 口进入的自行车对称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;互斥读者-写者问题&quot;&gt;&lt;a href=&quot;#互斥读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;互斥读者-写者问题&quot;&gt;&lt;/a&gt;互斥读者-写者问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;具体见 &lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-16/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互斥读者-读者问题&lt;/a&gt;        &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;理发店问题&quot;&gt;&lt;a href=&quot;#理发店问题&quot; class=&quot;headerlink&quot; title=&quot;理发店问题&quot;&gt;&lt;/a&gt;理发店问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;（原书书后习题 6.11 ，有修改）一个理发店配有一个有 10 个椅子的休息室和一个有理发椅的理发室。如果没有顾客则理发师睡觉；如果顾客来了而休息室、理发椅都没有空则离开；如果理发师在忙而有空的椅子，则顾客选择一个坐下等待；如果理发师在睡觉则顾客摇醒他。&lt;/li&gt;
&lt;li&gt;分析：理发师在没有顾客时睡觉，并且顾客在没有空椅时离开，因此应当记录顾客的数量。&lt;/li&gt;
&lt;li&gt;定义信号量：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int count = 11&lt;/code&gt; ：空闲的椅子数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore mutex = 1&lt;/code&gt; ：对椅子数量的修改互斥&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore barber_chair = 1&lt;/code&gt; ：理发师互斥，同时只能给一个人理发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore customers = 0&lt;/code&gt; ：顾客人数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 顾客&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count == &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(customers);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 唤醒 barber&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(barber_chair);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 理发&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 理发师&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(customers);  &lt;span class=&quot;comment&quot;&gt;// 睡觉等待顾客&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 被唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剪发&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(barber_chair);  &lt;span class=&quot;comment&quot;&gt;// 下一个客人剪发&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上面的代码将顾客排队顺序交给了信号量自身的排队机制处理，如果需要确保顾客能够维持一个先来先服务的剪发顺序，则需要维护一个容量为 11 的队列，顾客到来后加到队列尾部，每次从队头取走最先到来的顾客。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;上机实习问题&quot;&gt;&lt;a href=&quot;#上机实习问题&quot; class=&quot;headerlink&quot; title=&quot;上机实习问题&quot;&gt;&lt;/a&gt;上机实习问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;某高校计算机系安排学生上机实习，机房共 30 台机器，有超过 60 名学生选课。规定每两个学生一组，一组占一台机器，协同完成实习。只有凑够两个学生且机房仍有空闲机器的情况下，门卫才允许该组学生进入机房。每组上机实习结束时需要由一名固定的老师检查完毕后，该组学生才可离开。&lt;/li&gt;
&lt;li&gt;分析：互斥资源有需要检查的教师，同步资源涉及机房里的 30 台机器。此外，学生必须两两凑成一组才能进入机房，因此需要维护当前准备进入机房的学生人数，一旦超过 1 个人就可以组成一组。此外，应当注意学生组队和获取机器的先后关系，为了保证两个学生只获取一台机器，可以只使偶数号到来的学生获取机器，因为偶数号学生到来时可以保证能够凑成至少一组。本题涉及的进程只有学生。&lt;/li&gt;
&lt;li&gt;定义信号量：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int count = 0&lt;/code&gt; ：开始时在机房外等候的学生人数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore mutex = 1&lt;/code&gt; ：修改学生人数的互斥信号量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore teacher = 1&lt;/code&gt; ：验收的老师&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore machine = 30&lt;/code&gt; ：30 台机器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 学生进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = count;     &lt;span class=&quot;comment&quot;&gt;// 记录自己的编号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;// 偶数号学生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(machine);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 上机&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 上机完成，等待验收&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(teacher);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 验收&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(teacher);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (temp % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(machine);   &lt;span class=&quot;comment&quot;&gt;// 由偶数号学生释放机器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 必须先释放机器再尝试获取 mutex&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 因为等待的偶数号学生先获取了 mutex，并且正在等待机器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count -= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// 一组学生离开&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;吸烟者问题&quot;&gt;&lt;a href=&quot;#吸烟者问题&quot; class=&quot;headerlink&quot; title=&quot;吸烟者问题&quot;&gt;&lt;/a&gt;吸烟者问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;假设一个系统有 3 个吸烟者进程和一个供应商进程，制造一根香烟需要三种材料各一份。三个吸烟者分别无限量的拥有三种材料中的一种。供应商进程可以无限量的供应这三种材料，一旦一个吸烟者想吸烟，则他向供应商发出请求，供应商会为这个吸烟者提供另外两种材料。供货商同时只能为一个吸烟者提供服务，多个吸烟者同时发出请求时按固定顺序服务。如此循环往复，请用信号量编写程序控制四个进程同步执行。&lt;/li&gt;
&lt;li&gt;分析：供货商需要判断有哪些吸烟者当前试图吸烟，因为可能有多个吸烟者发出请求，因此供货商需要分别判断。吸烟者需要三种材料中的两种，因此每种材料需要设置一个信号量表示资源请求。此外多个吸烟者同时发出请求，那么它们可能会同时争抢供货商提供的某个材料，因此需要一个互斥信号量控制提出请求的权限。&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; smoker1, smoker2, smoker3;   &lt;span class=&quot;comment&quot;&gt;// 分别表示 1、2、3 吸烟者是否发出请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore a = b = c = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始供应的三种材料数量，1、2、3 号吸烟者分别持有 a、b、c类型材料&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;semaphore smoker_request = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// 吸烟者发出请求权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 供应商&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (smoker1 == TRUE) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// 吸烟者 1 有请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (smoker2 == TRUE) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// 吸烟者 2 有请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (smoker3 == TRUE) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// 吸烟者 3 有请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//吸烟者 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(smoker_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    smoker1 = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(smoker_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;苹果-橘子或老虎与猪&quot;&gt;&lt;a href=&quot;#苹果-橘子或老虎与猪&quot; class=&quot;headerlink&quot; title=&quot;苹果-橘子或老虎与猪&quot;&gt;&lt;/a&gt;苹果-橘子或老虎与猪&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;两类问题本质一样，描述不同，在期中考试已经出现过。老虎与猪的描述如下：有一个笼子可以容纳一只老虎或者两只猪，如果笼子中已经有猪，则老虎不能被放入。猎人 A 每次向笼子中放入一只老虎，猎人 B 每次向笼子中放入一只猪。饲养员每次会从笼子中取出一只老虎，厨师每次会从笼子中取出一只猪。对笼子的操作是互斥的。试用信号量描述此过程。&lt;/li&gt;
&lt;li&gt;分析：此题的关键在于笼子中允许有两只猪，而当笼子中有猪时就无法放入老虎，因此需要维护猪的数量。猎人 A 需要和饲养员维持同步关系，猎人 B 需要和厨师维持同步关系。本题其实也可以看作生产者-消费者问题和第一类读者-写者问题的结合，但限制了读者的数量。&lt;/li&gt;
&lt;li&gt;变量和信号量定义：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int pig_count = 0&lt;/code&gt; ：笼子中当前猪的数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore coop = 1&lt;/code&gt; ：笼子的互斥锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore tiger = 0&lt;/code&gt; ：用于在猎人 A 和饲养员之间的同步，同时这个信号量和 &lt;code&gt;coop&lt;/code&gt; 也是互补的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore pig = 0&lt;/code&gt; ：用于在猎人 B 和厨师之间同步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore pig_space = 2&lt;/code&gt; ：用于限制可以放置猪的剩余空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore pig_count_mutex = 1&lt;/code&gt; ：用于限制对 &lt;code&gt;pig_count&lt;/code&gt; 的互斥访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 猎人 A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 抓到一只老虎&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(coop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将老虎放入笼子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(tiger);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 饲养员&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(tiger);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从笼子中取出老虎&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(coop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 猎人 B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 抓到一只猪&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(pig_space);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(pig_count_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pig_count ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pig_count == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(coop);    &lt;span class=&quot;comment&quot;&gt;// 笼子中没有猪的情况下要等待笼子权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将猪放入笼子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(pig_count_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(pig);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 厨师&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(pig);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(pig_count_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从笼子中取出一只猪&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pig_count --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pig_count == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(coop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(pig_count_mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(pig_space);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;信号量编程测试&quot;&gt;&lt;a href=&quot;#信号量编程测试&quot; class=&quot;headerlink&quot; title=&quot;信号量编程测试&quot;&gt;&lt;/a&gt;信号量编程测试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我编写了一点简单的测试代码（Windows 下）来辅助测试信号量算法能否工作成功。你可以在 &lt;a href=&quot;https://github.com/Forec/semaphore-test&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt; 获取这些代码。&lt;/li&gt;
&lt;li&gt;代码包括一个基类 &lt;code&gt;WorkStation&lt;/code&gt;（包含在 &lt;code&gt;base.hpp&lt;/code&gt; 中） 和两个可以用来做参考的测试文件。其中 &lt;code&gt;bridge1.cpp&lt;/code&gt; 用来验证 &lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;信号量编程（上）&lt;/a&gt; 中习题 7.16， &lt;code&gt;bridge2.cpp&lt;/code&gt; 用来验证 &lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-16/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互斥读者-读者问题&lt;/a&gt; 中我针对修改后问题给出的自己的解答。你可以仿照这两个文件，继承 &lt;code&gt;WorkStation&lt;/code&gt; 类来测试自己的信号量程序。&lt;/li&gt;
&lt;li&gt;测试举例：以上面的老虎与猪问题为例，定义一个类 &lt;code&gt;Coop&lt;/code&gt; 继承 &lt;code&gt;WorkStation&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将所需变量添加到子类中，并实现虚方法 &lt;code&gt;init()&lt;/code&gt;，该方法对你需要用到的信号量/变量做初始化。注意 &lt;code&gt;init()&lt;/code&gt; 函数中需要设置 &lt;code&gt;thread_type&lt;/code&gt;，这个变量表示有多少不同类型的进程，此问题有 4 种（猎人 A、B，厨师、饲养员），故 &lt;code&gt;thread_type&lt;/code&gt; 应当为 4。&lt;/li&gt;
&lt;li&gt;定义自己的参数结构体，对于上面老虎与猪问题而言需要将所用到的所有变量/信号量的地址放置到一个结构体中，对于此问题为：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Param&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *pig_count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HANDLE *coop, *tiger, *pig;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HANDLE *pig_space, *pig_count_mutex;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;实现虚函数 &lt;code&gt;void * getParam(int index)&lt;/code&gt;，此函数格式比较固定，对于此问题应当为：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * &lt;span class=&quot;title&quot;&gt;getParam&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Param *p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Param;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;pig_count = &amp;amp;pig_count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;coop = &amp;amp;coop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;tiger = &amp;amp;tiger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;pig = &amp;amp;pig;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;pig_space = &amp;amp;pig_space;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;pig_count_mutex = &amp;amp;pig_count_mutex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;实现四个进程对应的函数，只需要将已经写好的代码复制到你的代码中，格式参考 &lt;code&gt;bridge1.cpp&lt;/code&gt; 和 &lt;code&gt;bridge2.cpp&lt;/code&gt;。例如上面的猎人 A，应当写为：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;DWORD WINAPI &lt;span class=&quot;title&quot;&gt;hunter_A&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LPVOID param)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Param p = *(Param*) param;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 抓到一只老虎&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WaitForSingleObject(*(p.coop), INFINITE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将老虎放入笼子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ReleaseSemaphore(*(p.coop), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;假设你实现的代表四个进程的四个函数分别名为 &lt;code&gt;hunter_A&lt;/code&gt;、&lt;code&gt;hunter_B&lt;/code&gt;、&lt;code&gt;cook&lt;/code&gt; 和 &lt;code&gt;feeder&lt;/code&gt;。则向 &lt;code&gt;init()&lt;/code&gt; 函数添加下面的代码更新驱动表：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_threads[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = hunter_A;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_threads[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = hunter_B;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_threads[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = cook;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_threads[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = feeder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;修改 &lt;code&gt;main()&lt;/code&gt; 函数以测试。将 &lt;code&gt;main()&lt;/code&gt; 函数中 &lt;code&gt;simulate()&lt;/code&gt; 方法的第一个参数修改为 1，此参数表示每个进程创建多少个实例，此问题四种进程各一个，因此为 1。后一个参数表示程序运行多久退出，通常默认 60s 足够测试完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（专题）：信号量编程（上）&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-16/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互斥读者-读者问题&lt;/a&gt;        &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/08/os-concepts-15/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此部分包括一些和 《&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot;&gt;信号量编程（上）&lt;/a&gt;》 相比稍难的信号量编程习题，可能有一小部分超出了考试范畴。这部分习题的解答均根据我个人理解编写， &lt;strong&gt;不保证提供的答案绝对正确或最优&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（专题）：信号量编程（上）</title>
    <link href="http://forec.github.io/2017/01/06/os-concepts-14/"/>
    <id>http://forec.github.io/2017/01/06/os-concepts-14/</id>
    <published>2017-01-06T09:21:43.000Z</published>
    <updated>2017-01-11T15:16:21.061Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;此部分主要包括原书第六章（进程同步）和第七章（死锁）的部分习题（有些不属于考试范围），以及一些简单信号量编程习题（低于考试难度）的分析。这部分习题的解答均根据我个人理解编写或翻译， &lt;strong&gt;不保证提供的答案绝对正确或最优&lt;/strong&gt; 。稍微复杂一些的信号量编程在 《&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;信号量编程（下）&lt;/a&gt;》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;原书选题&quot;&gt;&lt;a href=&quot;#原书选题&quot; class=&quot;headerlink&quot; title=&quot;原书选题&quot;&gt;&lt;/a&gt;原书选题&lt;/h1&gt;&lt;p&gt;课后习题的解答主要是我对原书答案的翻译和解释。此外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;“进程同步”中，第 6 题之后（含第 6 题）超出考试范围&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“死锁”中，第 5 题超出考试范围&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进程同步&quot;&gt;&lt;a href=&quot;#进程同步&quot; class=&quot;headerlink&quot; title=&quot;进程同步&quot;&gt;&lt;/a&gt;进程同步&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;证明 &lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程互斥&lt;/a&gt; 中介绍的 &lt;strong&gt;Peterson 算法&lt;/strong&gt; 满足临界区的三个要求。&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/#Peterson 算法&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程互斥 - Peterson 算法&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么是 &lt;strong&gt;忙等待（busy waiting）&lt;/strong&gt; ？操作系统中还有哪些等待方式？忙等待可以被完全避免吗？&lt;ul&gt;
&lt;li&gt;忙等待意味着进程在等待一个条件被满足，并且进程在等待的过程中仍然不放弃对 CPU 的控制（如通过 &lt;code&gt;while&lt;/code&gt; 循环不断判断条件是否被满足）。&lt;/li&gt;
&lt;li&gt;操作系统可以在一个进程等待某条件时将 CPU 控制权限交给其他进程，而等待的进程可以在将来某个合适的、条件满足的情况下被唤醒。&lt;/li&gt;
&lt;li&gt;忙等待可以被避免，但需要在进程的调度上花费更多的资源。等待进程需要被挂起，等到进程等待的条件满足时再唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;试解释为什么 &lt;strong&gt;自旋锁（旋转锁，spinlock）&lt;/strong&gt; 不适合单处理器系统，但在多处理器系统中很常用。&lt;ul&gt;
&lt;li&gt;对于单处理器系统：一个进程使用自旋锁等待条件时仍然占据着唯一的 CPU，其他进程得不到执行，而占据 CPU 的进程等待的条件需要其它进程的执行才能得到满足。&lt;/li&gt;
&lt;li&gt;对于多处理器系统：进程使用自旋锁时占据着一个 CPU 资源，而其他进程可以在剩余的 CPU 上运转，并且改变某些数据从而使停滞在旋转锁的进程的等待条件得到满足。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;试解释为什么在单处理器系统的用户进程中通过屏蔽中断来实现同步是不合理的。&lt;ul&gt;
&lt;li&gt;如果用户进程具有屏蔽中断的权限，那么它可以同样屏蔽计时器中断，没有时钟中断则分派程序无法运行，进程会无限执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;试解释为什么在多处理器系统系统中无法通过屏蔽中断来实现同步。&lt;ul&gt;
&lt;li&gt;屏蔽中断仅仅阻止其他进程在被屏蔽了中断的处理器上运行，其他进程可能在其它处理器上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;试在多处理器环境下通过 &lt;code&gt;TestAndSet()&lt;/code&gt; 指令实现 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt; 信号量操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始定义 &lt;code&gt;int semaphore_value = 0&lt;/code&gt; 表示当前信号量剩余资源，定义 &lt;code&gt;bool guard = TRUE&lt;/code&gt; 保证对 &lt;code&gt;semaphore_value&lt;/code&gt; 的互斥修改。&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void wait()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (TestAndSet(&amp;amp;guard) == TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (semaphore_value == 0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 暂时没有资源可用，将进程挂起到信号量队列中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        semaphore_value --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guard = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void signal()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (TestAndSet(&amp;amp;guard) == TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (semaphore_value == 0 &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        there&#39;s a process waiting in the queue)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 信号量资源数为 0 并且有进程挂起在信号量中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 唤醒该进程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        semaphore_value ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    guard = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;证明 &lt;strong&gt;管程（monitor）&lt;/strong&gt; 和信号量可以互相实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/#使用信号量实现管程&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（六）：管程 - 使用信号量实现管程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用管程实现信号量：&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor semaphore &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c.signal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (value == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            c.wait();    &lt;span class=&quot;comment&quot;&gt;// 注意体会此处 while 而非 if 的意义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用管程实现有限缓冲的生产者 - 消费者模型。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor bounded_buffer &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; items[MAX_ITEMS];    &lt;span class=&quot;comment&quot;&gt;// 生产的资源缓冲区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numItems = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;        &lt;span class=&quot;comment&quot;&gt;// 缓冲区内当前资源数目&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition full, empty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; v)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (numItems == MAX_ITEMS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            full.wait();     &lt;span class=&quot;comment&quot;&gt;// 缓冲区满时将生产者挂起到条件变量 full&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        items[numItems++] = v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        empty.signal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retVal;          &lt;span class=&quot;comment&quot;&gt;// 临时变量保存返回值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (numItems == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            empty.wait();    &lt;span class=&quot;comment&quot;&gt;// 缓冲区为空将消费者挂起到条件变量 empty&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        retVal = items[--numItems];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        full.signal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retVal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;试提出一种解决读者-写者问题中饥饿现象的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 3 类读者-写者问题的一种解答：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/#第三读者-写者问题&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（五）：进程同步 - 第三读者-写者问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;另一种方案：每个读者/写者都保留开始等待时刻的时间戳，当一个写者完成写任务后，会唤醒等待时间最长的进程。当有读者正在临界区内而有新读者到来时，新读者必须在没有写者在等待的情况下才能也进入临界区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号量的 &lt;code&gt;signal()&lt;/code&gt; 和管程中条件变量 &lt;code&gt;signal&lt;/code&gt; 操作的区别。&lt;ul&gt;
&lt;li&gt;如 &lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（六）：管程&lt;/a&gt; 所讲，管程模式下的 &lt;code&gt;x.signal()&lt;/code&gt; 和信号量的 &lt;code&gt;signal()&lt;/code&gt; 区别在于： &lt;strong&gt;信号量操作 &lt;code&gt;signal()&lt;/code&gt; 会影响信号量的状态&lt;/strong&gt; ，而管程下的 &lt;code&gt;x.signal()&lt;/code&gt; 在 x 不存在挂起进程的情况下没有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个系统包含 n 个进程 P1~n，每个进程都有唯一的优先级编号，共有 3 台打印机供这 n 个进程使用。试通过管程实现按优先级调度的资源分配。&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor printers &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_avail = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 可用资源数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_waiting;      &lt;span class=&quot;comment&quot;&gt;// 等待进程数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; waiting_processes[MAX_PROCS];    &lt;span class=&quot;comment&quot;&gt;// 等待进程列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request_printer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; proc_number)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (num_avail &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;        &lt;span class=&quot;comment&quot;&gt;// 有资源可分配则进程直接获得&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            num_avail --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        waiting_processes[num_waiting] = proc_number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num_waiting++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(waiting_processes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (num_avail == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            waiting_processes[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] != proc_number)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 当可用资源数量为 0 并且当前进程不处于等待队列的第一位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            c.wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        waiting_processes[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = waiting_processes[--num_waiting];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(waiting_processes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num_avail--;    &lt;span class=&quot;comment&quot;&gt;// 使用一个资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;release_printer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num_avail ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c.signal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;考虑教材 7.1 描述的交通死锁问题（如下图所示），试说明死锁发生的四个必要条件在这个问题中均得到满足，并简述在这个问题中避免死锁的方案。（原书 7.1）&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/deadlock-traffic.jpg&quot; width=&quot;400px&quot;&gt;&lt;ul&gt;
&lt;li&gt;死锁发生的四个必要条件分别是：互斥、占有并等待、非抢占和循环等待。因为只有一条道路的每个位置上只能由一辆车占据，故满足资源互斥；当一辆车占据道路上某个位置时，它必须等待前面的车移动（获取新位置）才可以移动，，即占有并等待；一辆车不能被移开，故此系统为非抢占；每个车都在等待前面的车移动，每个十字路口的车辆则循环等待下一个十字路口的车辆移动，故循环等待。&lt;/li&gt;
&lt;li&gt;一个简单的方案是：当十字路口已存在车辆时，新到来的车辆不能进入十字路口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在真实计算机系统中，无论是可用资源还是进程对资源的需求都会随着时间的推移而改变。假设现在系统处于安全状态（通过银行家算法计算出），那么对于下面的几种改变，哪些改变执行之后一定能维持系统的安全状态？（原书 7.5）&lt;ul&gt;
&lt;li&gt;增加可用资源：维持安全状态&lt;/li&gt;
&lt;li&gt;减少可用资源：可能导致死锁，因为银行家算法计算出的安全状态是基于改变前的资源数量&lt;/li&gt;
&lt;li&gt;增加某个进程所需要的最大资源数量：可能导致死锁，理由同上&lt;/li&gt;
&lt;li&gt;减少某个进程所需要的最大资源数量：维持安全状态&lt;/li&gt;
&lt;li&gt;增加进程数量：可能导致死锁，理由同上&lt;/li&gt;
&lt;li&gt;减少进程数量：维持安全状态，进程退出竞争必然使可用资源增加或保持不变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个系统有四个相同类型的资源，它们被三个进程同时共享，每个进程最多需要两个资源。试证明这个系统不会发生死锁。（原书 7.6）&lt;ul&gt;
&lt;li&gt;假设系统发生死锁，则必然满足占有并等待和循环等待的条件。故每个进程都持有一个资源（若持有两个则已经满足要求，可以运行结束并释放），并且每个进程都在等待下一个资源。根据狄利克雷抽屉原理，四个资源分配给三个进程，必然有一个进程获得两个资源，这个进程必然可以执行完毕，然后释放持有的全部资源以使其它进程得以执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个系统有 m 个相同类型的资源，它们被 n 个进程同时共享。在每个时刻，进程只能至多申请或者释放一个资源。假设系统满足以下两个条件：每个进程所需的最大资源数量在 1~m 个之间、所有进程的最大资源需求数量之和小于 m+n 个，试证明这个系统不会发生死锁。（原书 7.7）&lt;ul&gt;
&lt;li&gt;解答 1：每个进程尚需的资源向量 &lt;code&gt;Need[i,] = Max[i,] - Allocation[i,]&lt;/code&gt;。假设存在死锁，则必有 &lt;code&gt;Σ(i = 1 to n) Allocation[i,] = m&lt;/code&gt; ，即所有资源都已经分配，没有资源空闲。&lt;/li&gt;
&lt;li&gt;因为进程所需的资源总和不超过 m+n·，故 &lt;code&gt;Σ Need[i,] + Σ Allocation[i,] = Σ Max[i,] &amp;lt; m + n&lt;/code&gt; ，和上式结合化简即为 &lt;code&gt;Σ Need[i,] &amp;lt; n&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;因为 n 个进程所需的资源总数小于 n，意味着至少有一个进程 P 还需要 0 个资源，所以进程 P 能够执行到结束。又每个进程所需的最大资源数量不少于 1 个，故 P 执行结束后会释放至少一个资源。因此系统不会产生死锁。&lt;/li&gt;
&lt;li&gt;解答 2：假设系统正在发生死锁，则当前状态下的 m 个资源已经全部被 n 个进程所占用，而这 n 个进程还需要更多的资源才能继续运行，也就是说每个进程还需要至少一个资源。因此，系统内 n 个进程正常运行所需要的资源总和大于或等于 m+n，与题意矛盾。故系统不可能发生死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一座桥连接了南北两个村庄，两个村庄的居民可以从桥上通过，但桥上不能同时承载两个人（无论同方向还是相向，这里原题中只要求不能同时相向行走）。使用信号量保证死锁和饥饿都不会发生。（原书 7.16）&lt;ul&gt;
&lt;li&gt;注 1：如果将此题的限制改为两个方向的人依次行走，即南向北过桥后，下一次应当是北向南，则此问题等同于缓冲区大小为 1 的生产者-消费者问题。&lt;/li&gt;
&lt;li&gt;注 2：此题要求不会产生饥饿现象，则需要考虑两个方面，既要保证不能有一方一直持有过桥的权利，还要保证某一方过桥后，任何一方再次过桥不会依赖已过桥的居民影响（临界区问题的“发展”要求）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注 3：此题是原书课后习题，课后的 7.15 和 7.16 是递进关系。《&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;信号量编程（下）&lt;/a&gt;》中北京大学 1992 年入学考试题（单向行驶问题）也与此题类似。我对该题又做了新的改动，本题的信号量解法以及改动后题目的相关分析均记录在 《&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-16/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;互斥读者-读者问题&lt;/a&gt;》，如果你有兴趣，欢迎与我讨论改动后题目的解法&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;原书答案给出了管程解法，对其做了一定修改如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor bridge &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_waiting_north = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 北方村庄等待过桥人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num_waiting_south = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 南方村庄等待过桥人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; prev = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// prev 为 0 表示上一次上桥的人是北方居民，否则为南方居民&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; on_bridge = FALSE;      &lt;span class=&quot;comment&quot;&gt;// 桥上是否有人&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition ok_to_cross;       &lt;span class=&quot;comment&quot;&gt;// 条件变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_north&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;span class=&quot;comment&quot;&gt;// 北方村庄居民试图过桥&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num_waiting_north++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (on_bridge ||      &lt;span class=&quot;comment&quot;&gt;// 桥上有人&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              (prev == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; num_waiting_south &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;comment&quot;&gt;// 或者上一次是北方居民过桥，且当前还有南方村庄居民在等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ok_to_cross.wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num_waiting_north --;    &lt;span class=&quot;comment&quot;&gt;// 已上桥，北方村庄等待人数减少&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prev = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enter_bridge_south&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num_waiting_south ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (on_bridge ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               prev == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; num_waiting_north &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ok_to_cross.wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num_waiting_south --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prev = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exit_bridge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;         &lt;span class=&quot;comment&quot;&gt;// 南北居民离开后都调用此函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        on_bridge = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ok_to_cross.signal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;简单信号量编程&quot;&gt;&lt;a href=&quot;#简单信号量编程&quot; class=&quot;headerlink&quot; title=&quot;简单信号量编程&quot;&gt;&lt;/a&gt;简单信号量编程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;此部分习题选自 2000 年左右各高校的研究生入学考试题，题目均比较简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;双车间零件装配&quot;&gt;&lt;a href=&quot;#双车间零件装配&quot; class=&quot;headerlink&quot; title=&quot;双车间零件装配&quot;&gt;&lt;/a&gt;双车间零件装配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;某工厂有两个生产车间和一个装配车间，两个生产车间分别生产 A，B 两种零件，装配车间的任务是把 A，B 两种零件组装成产品。每个车间生产完一个零件后都要把零件送到装配车间的货架 F1、F2 上，F1 存放零件 A，F2 存放零件 B，两个货架均可分别容纳 10 个零件。装配工人每次从货架上取出一个 A 零件和一个 B 零件然后组装成产品。请用信号量进行正确管理。&lt;/li&gt;
&lt;li&gt;此问题是生产者-消费者问题的变形，可以认为一个消费者（装配工人）和两个生产者（A，B车间）互斥使用两个缓冲区（F1、F2）。令 &lt;code&gt;mutex1&lt;/code&gt; 和 &lt;code&gt;mutex2&lt;/code&gt; 这两个互斥信号量控制对缓冲区的互斥操作，另外还需要 &lt;code&gt;empty1&lt;/code&gt;、&lt;code&gt;empty2&lt;/code&gt;、&lt;code&gt;full1&lt;/code&gt;、&lt;code&gt;full2&lt;/code&gt; 用来同步。&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 车间 A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(empty1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 生产零件 A 并放入 F1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(full);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 车间 B 和车间 A 对称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 装配工人&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(full1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(full2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 取出零件 A 和 B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(empty1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(empty2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;和尚挑水问题&quot;&gt;&lt;a href=&quot;#和尚挑水问题&quot; class=&quot;headerlink&quot; title=&quot;和尚挑水问题&quot;&gt;&lt;/a&gt;和尚挑水问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;（北京邮电大学 1998 年）某寺庙有老、小和尚若干，仅有一个水缸和一个水井。小和尚负责将水从井中挑到缸中以供老和尚饮用。水缸可以容纳最多 10 桶水，水井口非常窄，每次只能容纳一个水桶取水。水桶总数有 3 各，每次小和尚挑水、倒入缸内只能使用一个桶，且不可以同时进行。请使用信号量给出从缸中取水和向缸中倒水的算法描述。&lt;/li&gt;
&lt;li&gt;分析：需要将问题分解为数个过程。从井中取水到向缸中倒水应该是一个连续的动作，算作一个进程；老和尚用桶从缸中取水算作一个进程。题中互斥资源包括水井和水缸，分别需要一个信号量来保证互斥。题中同步问题涉及水桶，抢不到水桶的进程需要等待，水缸满时小和尚需要等待，水缸空时老和尚需要等待，这需要生产者-消费者问题的经典信号量控制满和空。&lt;/li&gt;
&lt;li&gt;定义信号量如下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mutex1 = mutex2 = 1&lt;/code&gt; ：水井和水缸两个资源各自的互斥访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;empty = 10&lt;/code&gt; ：初始水缸为空，可容纳至多 10 桶水&lt;/li&gt;
&lt;li&gt;&lt;code&gt;full = 0&lt;/code&gt; ：初始水缸为空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count = 3&lt;/code&gt; ：水桶数量为 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 小和尚&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(empty);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(count);   &lt;span class=&quot;comment&quot;&gt;// 争夺水桶&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从井中打水&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 倒水入水缸&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(count); &lt;span class=&quot;comment&quot;&gt;// 归还水桶&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(full);  &lt;span class=&quot;comment&quot;&gt;// 通知老和尚水缸有水&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 老和尚&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(full);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从水缸中打水&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(empty);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;阅览室登记问题&quot;&gt;&lt;a href=&quot;#阅览室登记问题&quot; class=&quot;headerlink&quot; title=&quot;阅览室登记问题&quot;&gt;&lt;/a&gt;阅览室登记问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;（北方交通大学 1999 年）阅览室有 100 个座位，读者进入阅览室需要先在一张登记表上登记，每个座位有一个条目，读者离开阅览室需要注销自己的登记信息。请使用信号量描述同步算法。约定：&lt;ul&gt;
&lt;li&gt;语句 &lt;code&gt;I = getflag(0)&lt;/code&gt; 可以搜索到一个空座位 i，通过语句 &lt;code&gt;i.flag = 0 或 1&lt;/code&gt; 可以标识座位 i 为空闲（0）或者占用（1）；&lt;/li&gt;
&lt;li&gt;语句 &lt;code&gt;i = getname(readername)&lt;/code&gt; 可以搜索到读者登记的座位号 i，通过 &lt;code&gt;i.name = 0&lt;/code&gt; 可以将座位原本的读者姓名清除，通过 &lt;code&gt;i.name = readername&lt;/code&gt; 可以将读者名称关联到座位 i 上；&lt;/li&gt;
&lt;li&gt;计数信号量用 &lt;code&gt;count&lt;/code&gt;，互斥信号量用 &lt;code&gt;mutex&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分析：约定部分仅仅为代码编写提供一定现成的符号，问题中仅有读者一个对象，因此只需要考虑读者之间是等价的，只需要考虑一个读者的行为。读者进入阅览室应当先检查是否有空闲座位，若存在则登记否则离开。座位显然需要信号量 &lt;code&gt;count&lt;/code&gt; 控制。读者离去时需要注销登记信息并释放座位，无论何时对登记簿的修改都需要互斥，如题中约定使用 &lt;code&gt;mutex&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;代码如下，对原题做一定修改，使读者进入阅览室时如果人满则离开，因此需要一个 &lt;code&gt;int&lt;/code&gt; 型变量 &lt;code&gt;seats&lt;/code&gt; 记录空闲座位数量，而原本的 &lt;code&gt;count&lt;/code&gt; 同步信号量可以丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; seats = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读者进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 进入阅览室&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (seats &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 无空闲座位，离开阅览室&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    seats --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i = getflag(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i.flag = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i.name = readername;    &lt;span class=&quot;comment&quot;&gt;// 获取空闲座位、登记&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 看书&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    seats ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i = getname(readername);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i.flag = i.name = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 注销登录信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;4-乘-100-米接力&quot;&gt;&lt;a href=&quot;#4-乘-100-米接力&quot; class=&quot;headerlink&quot; title=&quot;4 乘 100 米接力&quot;&gt;&lt;/a&gt;4 乘 100 米接力&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用信号量描述 4 × 100 米接力问题。&lt;/li&gt;
&lt;li&gt;分析：四个选手之间需要保持链式同步关系，因此设置三个信号量分别表示第 i 棒选手和第 i-1 棒选手之间的同步（0 &amp;lt; i &amp;lt; 5）。&lt;/li&gt;
&lt;li&gt;代码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;semaphore s1 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, s2 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, s3 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第一棒起跑并前进 100 米&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;signal(s1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二棒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wait(s1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二棒起跑并前进 100 米&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第四棒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wait(s3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第四棒起跑并前进 100 米到达终点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-13/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十三）：I/O 输入系统&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（专题）：信号量编程（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/06/os-concepts-14/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此部分主要包括原书第六章（进程同步）和第七章（死锁）的部分习题（有些不属于考试范围），以及一些简单信号量编程习题（低于考试难度）的分析。这部分习题的解答均根据我个人理解编写或翻译， &lt;strong&gt;不保证提供的答案绝对正确或最优&lt;/strong&gt; 。稍微复杂一些的信号量编程在 《&lt;a href=&quot;http://blog.forec.cn/2017/01/08/os-concepts-15/&quot;&gt;信号量编程（下）&lt;/a&gt;》。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（十三）：I/O 输入系统</title>
    <link href="http://forec.github.io/2017/01/06/os-concepts-13/"/>
    <id>http://forec.github.io/2017/01/06/os-concepts-13/</id>
    <published>2017-01-06T04:17:33.000Z</published>
    <updated>2017-01-11T14:27:00.661Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十三章 I/O 输入系统部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;注：整理只包含第 13 章内核 I/O 子系统之前的内容，考试涉及整章内容。&lt;/p&gt;
&lt;h1 id=&quot;I-O-硬件&quot;&gt;&lt;a href=&quot;#I-O-硬件&quot; class=&quot;headerlink&quot; title=&quot;I/O 硬件&quot;&gt;&lt;/a&gt;I/O 硬件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备驱动程序（device drivers）&lt;/strong&gt; 为 I/O 子系统提供了统一设备的访问接口。&lt;/li&gt;
&lt;li&gt;设备和计算机的通信通过 &lt;strong&gt;端口（port）&lt;/strong&gt; ，一组被一个/多个设备共同使用的线称为 &lt;strong&gt;总线（bus）&lt;/strong&gt; 。总线是一组线和一组严格定义的描述在线上传输信息的协议。 &lt;strong&gt;链环（daisy chaine）&lt;/strong&gt; 形容的是多个设备相连，最终设备通过端口连接到计算机上的模式。链环常常按总线方式工作，一个典型的 PC 总线结构如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/typical-pc-bus.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;上图中包含一个 &lt;strong&gt;PCI 总线&lt;/strong&gt; （最常用的 PC 系统总线）用于连接 CPU 和内存子系统/快速设备， &lt;strong&gt;扩展总线（expansion bus）&lt;/strong&gt; 用于连接串/并行端口和相对慢的设备（键盘）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制器（controller）&lt;/strong&gt; 是用来操作端口、总线或者设备的一组电子器件，它的复杂程度和传输协议有关，如串行端口控制器比较简单，而 SCSI 总线控制器常实现为一个和计算机相连的独立的 &lt;strong&gt;主机适配器（host adapter）&lt;/strong&gt; ，这个适配器会有处理器、微码以及一定的私有内存，从而能够处理 SCSI 协议信息。&lt;/li&gt;
&lt;li&gt;控制器有一个/多个用于数据和控制信号的寄存器， &lt;strong&gt;处理器通过读写这些寄存器来实现与控制器的通信&lt;/strong&gt; 。这种通信的可以通过特殊的 I/O 指令向指定的 I/O 端口地址传输一个字节/字，也可以通过 &lt;strong&gt;内存映射&lt;/strong&gt; I/O 模式（在 &lt;a href=&quot;http://blog.forec.cn/2017/01/04/os-concepts-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;虚拟内存&lt;/a&gt; 中介绍过），处理器能够通过标准数据传输指令完成对控制器的读写。部分系统同时采用这两种方式，例如图像控制器有 I/O 端口来完成基本控制操作，还有一个较大的内存映射区域来支持屏幕内容的接收和生成。&lt;/li&gt;
&lt;li&gt;I/O 端口通常有 4 种寄存器，寄存器通常为 1 ~ 4B：状态寄存器、控制寄存器、数据输入寄存器和数据输出寄存器。有的控制器有 FIFO 芯片从而可以保留多个输入/输出数据。上述四种寄存器的主要功能有：&lt;ul&gt;
&lt;li&gt;主机从 &lt;strong&gt;数据输入寄存器&lt;/strong&gt; 读出数据&lt;/li&gt;
&lt;li&gt;主机向 &lt;strong&gt;数据输出寄存器&lt;/strong&gt; 写入数据&lt;/li&gt;
&lt;li&gt;主机可从 &lt;strong&gt;状态寄存器&lt;/strong&gt; 读出设备当前的状态&lt;/li&gt;
&lt;li&gt;主机向 &lt;strong&gt;控制寄存器&lt;/strong&gt; 写入数据来发送命令、改变设备状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;轮询&quot;&gt;&lt;a href=&quot;#轮询&quot; class=&quot;headerlink&quot; title=&quot;轮询&quot;&gt;&lt;/a&gt;轮询&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;主机和控制器之间交互很复杂，但基本的 &lt;strong&gt;握手（handshaking）&lt;/strong&gt; 比较简单。假设控制器的状态寄存器中有一位用于说明设备当前是否在忙，控制器正忙时就将这一位置位。控制器的命令寄存器中有一位说明主机是否有任务准备就绪，当主机需要控制器执行某个操作时，需要将命令寄存器的这一位置位。主机和控制器交互输出一个字节时的握手流程如下：&lt;ol&gt;
&lt;li&gt;主机不断读取状态寄存器，直到状态寄存器中的 &lt;em&gt;忙位&lt;/em&gt; 为 0&lt;/li&gt;
&lt;li&gt;主机设置命令寄存器中的 &lt;em&gt;写位&lt;/em&gt; 并把一个字节写到数据输出寄存器&lt;/li&gt;
&lt;li&gt;主机设置命令寄存器中的 &lt;em&gt;就绪位&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;控制器注意到命令寄存器中的就绪位被置位，因此将状态寄存器中的 &lt;em&gt;忙位&lt;/em&gt; 置位&lt;/li&gt;
&lt;li&gt;控制器读取命令寄存器并发现 &lt;em&gt;写位&lt;/em&gt; 被置位，因此了解到需要执行一条写命令。它从数据输出寄存器读出一个字节，并向设备执行 I/O 操作&lt;/li&gt;
&lt;li&gt;控制器操作完成后将命令寄存器中的 &lt;em&gt;就绪位&lt;/em&gt; 清除，并清除状态寄存器中的 &lt;em&gt;故障位&lt;/em&gt; （这说明 I/O 设备成功完成任务），最后清除状态寄存器中的 &lt;em&gt;忙位&lt;/em&gt; 表示本次字节传输操作结束&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在步骤 1 中主机将处于 &lt;strong&gt;忙等待（busy-waiting）&lt;/strong&gt; 或者 &lt;strong&gt;轮询（polling）&lt;/strong&gt; 状态。多数计算机体系只需要三个 CPU 指令周期就可以完成基本的轮询操作，但不断地重复轮询会浪费处理器资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中断（interrupt）&lt;/strong&gt; 是使外设通知 CPU 的硬件机制。CPU 硬件有一条 &lt;strong&gt;中断请求线（Interrupt-request line，IRL）&lt;/strong&gt; ，CPU 执行完每条指令都会检测 IRL 判断是否有控制器通过 IRL 发送了信号。如果有，CPU 会保存当前的状态并且跳转到 &lt;strong&gt;中断处理程序（interrupt-handler）&lt;/strong&gt; 。中断处理程序会判断中断原因、进行处理、恢复状态并执行中断返回指令使 CPU 返回中断之前的执行状态。整个流程大致为：&lt;ul&gt;
&lt;li&gt;设备控制器通过中断请求线 &lt;strong&gt;发送中断信号引起（raise）中断&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;CPU &lt;strong&gt;捕获（catch）中断并分发（dispatch）到中断处理程序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;中断处理程序处理设备请求以 &lt;strong&gt;清除中断&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU 和 &lt;strong&gt;中断控制器（interrupt-controller）&lt;/strong&gt; 硬件提供了以下三个特性：&lt;ul&gt;
&lt;li&gt;在 CPU 执行关键指令时可以延迟对中断的处理&lt;/li&gt;
&lt;li&gt;能够将中断快速转发给适当的中断处理程序，而不必检查所有设备以确定是哪个设备引发了中断&lt;/li&gt;
&lt;li&gt;支持多级中断，可以根据紧迫性来响应中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数 CPU 有两个中断请求线： &lt;strong&gt;非屏蔽中断（nonmaskable）&lt;/strong&gt; 用于处理非常严重的，不可以恢复的内存错误等问题， &lt;strong&gt;可屏蔽中断（maskable）&lt;/strong&gt; 可被设备控制器用来请求服务，如果 CPU 正在执行关键、不可中断指令，则可以屏蔽这一类中断线上的请求。&lt;/li&gt;
&lt;li&gt;中断机制根据 &lt;strong&gt;中断向量（interrupt vector）&lt;/strong&gt; 来选择中断服务程序。中断向量和中断服务程序被维护在一张表中，中断向量支持的地址数量有限（例如 8 位中断向量只能对应 256 个中断服务程序，奔腾即为 256 个中断向量，0~31 用于各种错误等非屏蔽中断，剩下的为可屏蔽中断）， &lt;strong&gt;中断链接（interrupt chaining）&lt;/strong&gt; 可解决这个问题：中断向量指向的不再是单一的中断服务程序，而是一个中断服务程序的链表，中断一旦发生，对应链表中的全部中断处理程序都会一一调用，直到发现了能够处理请求的中断服务程序为止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断优先级（interrupt priority）&lt;/strong&gt; 使 CPU 可以在不屏蔽所有中断的情况下延迟处理低优先级的中断，并且也允许高优先级的中断抢占低优先级的中断处理。&lt;/li&gt;
&lt;li&gt;现代操作系统启动时会探查硬件总线、确定哪些设备存在并将对应的中断处理程序安装到中断向量中。操作系统对于中断机制的应用非常广泛：&lt;ul&gt;
&lt;li&gt;设备控制器通过中断表明自己已经准备好服务&lt;/li&gt;
&lt;li&gt;通过中断机制处理例如被 0 除、违例内存访问等 &lt;strong&gt;异常（Exception）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用中断进行虚拟内存分页，页错误会引发中断异常，这个中断会挂起当前进程并跳转到内核的页错误处理程序&lt;/li&gt;
&lt;li&gt;程序执行系统调用会触发 &lt;strong&gt;软中断（software interrupt）&lt;/strong&gt; 或者 &lt;strong&gt;陷阱指令（trap）&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;直接内存访问&quot;&gt;&lt;a href=&quot;#直接内存访问&quot; class=&quot;headerlink&quot; title=&quot;直接内存访问&quot;&gt;&lt;/a&gt;直接内存访问&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用通用处理器不断监听设备控制器的寄存器并按字节传输（ &lt;strong&gt;程序控制 I/O&lt;/strong&gt; ，Programmed I/O，PIO）是对计算资源的非常过分的浪费。计算机为了避免 PIO 增加 CPU 负担，将一部分数据传输任务交付 &lt;strong&gt;直接内存访问（direct-memory access，DMA）&lt;/strong&gt; 控制器。&lt;/li&gt;
&lt;li&gt;开始 DMA 传输时，主机向内存写入 DMA 命令块，块中包含传输的源、目的地址指针以及传输的字节数。 &lt;strong&gt;CPU 将该命令块的地址写到 DMA 控制器中&lt;/strong&gt; 并继续其他工作，DMA 控制器会根据命令块直接操作内存总线完成传输（这段时间 CPU 无法使用总线）。传输完成后 DMA 控制器会中断 CPU 并交还给  CPU 总线控制权。&lt;/li&gt;
&lt;li&gt;DMA 和设备控制器之间的握手通过 &lt;strong&gt;DMA-request&lt;/strong&gt; 和 &lt;strong&gt;DMA-acknowledge&lt;/strong&gt; 线进行，设备有数据需要传输时，设备控制器就通过 DMA-request 线通知 DMA 控制器，DMA 控制器会发出申请中断 CPU，在从 CPU 获取所需要的地址后将地址放到内存地址总线上，并通过 DMA-acknowledge 线通知设备控制器。设备控制器收到这个信号，向内存地址总线上的地址写入数据。交互过程如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/steps-dma-transfer.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;DMA 控制总线传输期间 CPU 不能访问主存（仍可访问 L1、L2 缓存），这称为 &lt;strong&gt;周期挪用（cycle stealing）&lt;/strong&gt; ，会放慢 CPU 计算，但往往能够改善系统总体性能。有的 DMA 使用物理内存地址，有的使用虚拟内存地址（这时候需要有一个虚拟到物理地址的转换），使用虚拟内存地址的 DMA 称为 &lt;strong&gt;直接虚拟内存访问（direct virtual-memory access，DVMA）&lt;/strong&gt; 。DVMA 可以直接实现两个内存映射设备之间的传输而无需 CPU 干涉。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;I-O-应用接口及后面几节简单摘要&quot;&gt;&lt;a href=&quot;#I-O-应用接口及后面几节简单摘要&quot; class=&quot;headerlink&quot; title=&quot;I/O 应用接口及后面几节简单摘要&quot;&gt;&lt;/a&gt;I/O 应用接口及后面几节简单摘要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;设备在很多方面有很大差异：&lt;ul&gt;
&lt;li&gt;字符流或块：字符流设备按字节传输，块设备以块为单位传输&lt;/li&gt;
&lt;li&gt;顺序访问或随机访问&lt;/li&gt;
&lt;li&gt;同步或异步：同步设备按照一定响应时间进行数据传输，异步设备则呈现无规则/不可预测的响应时间&lt;/li&gt;
&lt;li&gt;共享或专用：共享设备可以被多个进程/线程并发使用，专用设备则不可以&lt;/li&gt;
&lt;li&gt;操作速度：设备速度不同&lt;/li&gt;
&lt;li&gt;读写/只读/只写：设备支持的数据传输方向不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;块设备（block-device）&lt;/strong&gt; 接口规定了访问磁盘驱动器以及其它块设备所需的各个方面。操作系统本身和特殊的应用程序（如数据库）倾向于将块设备当作简单的线性块数组访问，这种访问方式称为 &lt;strong&gt;原始（raw） I/O&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞和非阻塞 I/O&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;应用程序发出 &lt;strong&gt;阻塞（blocking） I/O&lt;/strong&gt; 类型的系统调用时，应用程序就会被挂起，移动到进程等待队列中。因为阻塞式的 I/O 容易理解，并且 I/O 设备执行所需的时间是异步的，执行时间不可预估，因此绝大多数操作系统给应用程序预留的接口都是阻塞系统调用。&lt;/li&gt;
&lt;li&gt;有的用户级进程需要 &lt;strong&gt;非阻塞（nonblocking） I/O&lt;/strong&gt; ，例如用户接口，它用来接收键盘/鼠标输入，同时还要在屏幕回显。又或者视频应用程序，它需要从磁盘读取帧并解码到显示器上。非阻塞 I/O 通常使用多线程实现，有的线程执行阻塞系统调用，其他线程继续执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步系统调用（asynchronous system call）&lt;/strong&gt; 不必等待 I/O 完成就可以立刻返回，应用程序继续执行。I/O 完成时会通知应用程序，比如设置程序空间里某个变量，或者触发信号/软件中断等。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/two-io-methods.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓冲区（buffer）&lt;/strong&gt; 是用来保存两个设备之间或者设备和应用程序之间传输数据的内存区域。采用缓冲的理由有：&lt;ul&gt;
&lt;li&gt;处理数据流的生产者与消费者之间的速度差异&lt;/li&gt;
&lt;li&gt;协调传输数据大小不一致的设备&lt;/li&gt;
&lt;li&gt;支持程序 I/O 的复制语义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O 内核子系统&lt;/strong&gt; （kernel’s I/O subsystem）提供了很多和 I/O 有关的服务，包括：&lt;ul&gt;
&lt;li&gt;调度（scheduling）&lt;/li&gt;
&lt;li&gt;缓冲（buffering）&lt;/li&gt;
&lt;li&gt;高速缓存（caching）&lt;/li&gt;
&lt;li&gt;假脱机（spooling）&lt;/li&gt;
&lt;li&gt;设备预留（device reservation）&lt;/li&gt;
&lt;li&gt;错误处理（error handling）&lt;/li&gt;
&lt;li&gt;名称转换（name translation）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十二）：大容量存储器结构&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-14/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（专题）：信号量编程&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-13/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-13/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/06/os-concepts-13/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十三章 I/O 输入系统部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（十二）：大容量存储器结构</title>
    <link href="http://forec.github.io/2017/01/05/os-concepts-12/"/>
    <id>http://forec.github.io/2017/01/05/os-concepts-12/</id>
    <published>2017-01-05T15:23:30.000Z</published>
    <updated>2017-01-09T15:06:19.479Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十二章大容量存储器结构部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;大容量存储器结构&quot;&gt;&lt;a href=&quot;#大容量存储器结构&quot; class=&quot;headerlink&quot; title=&quot;大容量存储器结构&quot;&gt;&lt;/a&gt;大容量存储器结构&lt;/h1&gt;&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;磁盘（magnetic disk）&lt;/strong&gt; 是现代计算机系统使用的大容量外存。磁盘片为扁平原盘，两面均涂有磁质材料，读写头在磁盘片的表面飞行，磁头和 &lt;strong&gt;磁臂（disk arm）&lt;/strong&gt; 相连 ，磁臂将每个盘面两侧的全部磁头作为一个整体一起移动。磁盘片表面被逻辑划分为圆形 &lt;strong&gt;磁道（track）&lt;/strong&gt; ，一圈磁道被进一步划分为 &lt;strong&gt;扇区（sector）&lt;/strong&gt; 。同一圈磁道在不同盘片的集合组成了 &lt;strong&gt;柱面（cylinder）&lt;/strong&gt; 。磁盘结构如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/moving-head-disk-machanism.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;多数驱动器每秒可旋转 60~200 圈，磁盘速度由 &lt;strong&gt;传输速率（transfer rate）&lt;/strong&gt; 和 &lt;strong&gt;定位时间（positioning time）&lt;/strong&gt; 决定。其中传输速率指驱动器和计算机之间的数据传输速率；定位时间又称 &lt;strong&gt;随机访问时间（random access time）&lt;/strong&gt; ，包括 &lt;strong&gt;寻道时间（seek time）&lt;/strong&gt; （移动磁臂到所需柱面所需的时间） 和 &lt;strong&gt;旋转等待时间（rotational latency）&lt;/strong&gt; （等待磁盘驱动器将所需扇区旋转到磁头下的时间）。寻道时间和旋转等待时间通常为几毫秒，典型的磁盘能够以几兆每秒的速率传输。&lt;/li&gt;
&lt;li&gt;磁盘的传输速率总是低于有效的传输速率。 &lt;strong&gt;磁盘表现的传输速率是磁盘头从磁性介质读取比特的速率&lt;/strong&gt; ，这不同于给操作系统传输块的速率（与操作系统之间传输的速率才是决定磁盘速度的传输速率）。&lt;/li&gt;
&lt;li&gt;磁头飞行在盘片数微米上的空气层中，一旦磁头和盘片接触就会损坏磁盘表面，这称为 &lt;strong&gt;磁头碰撞（head crash）&lt;/strong&gt; 。磁头碰撞不能修复，整个磁盘必须替换。&lt;/li&gt;
&lt;li&gt;磁盘可移动或更换。 &lt;strong&gt;软盘（floppy disk）&lt;/strong&gt; 是便宜的可移动磁盘，存储容量在 1.44MB 左右。&lt;/li&gt;
&lt;li&gt;磁盘驱动器通过 &lt;strong&gt;I/O总线&lt;/strong&gt; 和计算机相连，可用的总线包括 &lt;strong&gt;EIDE（enhanced integrated drive electronics）&lt;/strong&gt; 、 &lt;strong&gt;ATA（advanced technology attachment）&lt;/strong&gt; 和 &lt;strong&gt;串行 ATA（serial ATA，SATA）&lt;/strong&gt; 、 &lt;strong&gt;USB（universal serial bus）&lt;/strong&gt; 、 &lt;strong&gt;FC（fiber channel）&lt;/strong&gt; 和 SCSI 总线。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制器（controller）&lt;/strong&gt; 是一个特殊处理器，用于执行总线上的数据传输。其中， &lt;strong&gt;主机（host）&lt;/strong&gt; 控制器是计算机上位于总线末端的控制器，而 &lt;strong&gt;磁盘（disk）&lt;/strong&gt; 控制器位于磁盘驱动器内。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁带（magnetic tape）&lt;/strong&gt; 是早期次级存储介质，但访问速度过慢。典型磁带可以存储 20~200GB。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;火线（FireWire）&lt;/strong&gt; 指一个接口，这个接口可以将外部设备如磁盘驱动器、DVD 驱动器等连接到计算机系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;磁盘结构和附属&quot;&gt;&lt;a href=&quot;#磁盘结构和附属&quot; class=&quot;headerlink&quot; title=&quot;磁盘结构和附属&quot;&gt;&lt;/a&gt;磁盘结构和附属&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;现代磁盘驱动器可以看作一个一维的 &lt;strong&gt;逻辑块（logical blocks）&lt;/strong&gt; 数组，逻辑块是最小的传输单位，通常为 512B，部分磁盘可以通过 &lt;strong&gt;低级格式化（low-level formatted）&lt;/strong&gt; 来选择不同的逻辑块大小。&lt;/li&gt;
&lt;li&gt;一维逻辑块数组按顺序映射到磁盘的扇区， &lt;strong&gt;扇区 0 是最外面柱面的第一个磁道的第一个扇区&lt;/strong&gt; ，这个映射关系先按磁道内的扇区顺序，之后按这一柱面上各个盘面的磁道顺序，最后按照 &lt;strong&gt;从外向内&lt;/strong&gt; 的柱面顺序排序。通过这种映射， &lt;strong&gt;可以将逻辑块号转换为磁盘内的柱面号、柱面内的磁道号以及磁道内的扇区号&lt;/strong&gt; 。这种转换有一些问题，原因在于：&lt;ul&gt;
&lt;li&gt;多数磁盘有一些缺陷扇区，这时候映射需要用其它空闲扇区替代这些缺陷扇区&lt;/li&gt;
&lt;li&gt;有些磁盘每个磁道上的扇区数不是常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于使用 &lt;strong&gt;常量线性速度（constant linear velocity，CLV）&lt;/strong&gt; 的介质，每个磁道的位密度均匀，离盘片中心更远的磁道的长度更长，容纳的扇区也就更多，这样从内向外的磁道所包含的扇区数就会逐渐增多，外部磁道的扇区数通常比内部磁道的扇区数多 40%。这时，盘片驱动器在磁头的不同位置的旋转速度将不同，磁头越靠近盘片中心则旋转速度越快。&lt;/li&gt;
&lt;li&gt;硬盘中通常采用 &lt;strong&gt;恒定圆角速度（constant angular velocity，CAV）&lt;/strong&gt; ，这时内磁道到外磁道的位密度会不断降低，以使磁盘驱动器转速恒定的情况下也能维持恒定的数据率。&lt;/li&gt;
&lt;li&gt;计算机访问磁盘可通过 I/O 端口，或称 &lt;strong&gt;主机附属存储（host-attached storage）&lt;/strong&gt; ，这一般在小系统中采用；或者通过分布式文件系统的远程主机，这称为 &lt;strong&gt;网络附属存储（network-attached storage）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;磁盘调度&quot;&gt;&lt;a href=&quot;#磁盘调度&quot; class=&quot;headerlink&quot; title=&quot;磁盘调度&quot;&gt;&lt;/a&gt;磁盘调度&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;强调磁盘的几个参数：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寻道时间&lt;/strong&gt; 是磁臂旋转以使磁头位于目标扇区所属的柱面上的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;旋转延迟&lt;/strong&gt; 是磁盘驱动器将盘片旋转以使目标扇区转动到磁头下的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁盘带宽&lt;/strong&gt; 是传输的总字节数除以从 &lt;em&gt;服务&lt;/em&gt; 请求开始到传递结束的总时间。可以通过磁盘 I/O 请求调度来排列访问顺序，从而提高访问速度和带宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程需要磁盘 I/O 操作时会向操作系统发出系统调用，这个调用请求包括：&lt;ul&gt;
&lt;li&gt;操作类型：输入/输出&lt;/li&gt;
&lt;li&gt;本次传输的磁盘地址、内存地址、扇区数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多个进程的多道程序系统，磁盘队列可能有多个待处理请求，此时操作系统需对磁盘请求进行调度，包括 FCFS、SSTF、SCAN、C-SCAN、LOOK、C-LOOK。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;FCFS-调度&quot;&gt;&lt;a href=&quot;#FCFS-调度&quot; class=&quot;headerlink&quot; title=&quot;FCFS 调度&quot;&gt;&lt;/a&gt;FCFS 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;先来先服务算法，此算法比较公平但无法提供最快的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SSTF-调度&quot;&gt;&lt;a href=&quot;#SSTF-调度&quot; class=&quot;headerlink&quot; title=&quot;SSTF 调度&quot;&gt;&lt;/a&gt;SSTF 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最短寻道时间优先法（shortest-seek-time-first，SSTF）&lt;/strong&gt; 会先处理最靠近当前磁头位置的请求，即选择距离当前磁头位置所需寻道时间最短的请求来处理。&lt;/li&gt;
&lt;li&gt;本质上是最短作业优先（SJF）调度，但与 SJF 类似，它可能导致一些请求得不到服务，如果待处理请求队列比较长，很有可能某个请求会产生饥饿。SSTF 调度相比 FCFS 调度有很大改善，但仍不是最优的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SCAN-和-C-SCAN-调度&quot;&gt;&lt;a href=&quot;#SCAN-和-C-SCAN-调度&quot; class=&quot;headerlink&quot; title=&quot;SCAN 和 C-SCAN 调度&quot;&gt;&lt;/a&gt;SCAN 和 C-SCAN 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SCAN 算法有时称为 &lt;strong&gt;电梯算法（elevator algorithm）&lt;/strong&gt; ，磁臂会从磁盘的一端向另一端移动（按一维逻辑块数组的顺序），当磁头移动过每个柱面时就会处理这个柱面的服务请求。到达另一端后磁头会反向继续移动，如此往返。&lt;/li&gt;
&lt;li&gt;如果一个请求刚好在磁头移动到请求位置之前加入磁盘请求队列，则它会马上得到服务&lt;/li&gt;
&lt;li&gt;如果一个请求刚好在磁头移动过请求位置后加入队列，则它需要等待磁头到达另一端并调转方向、返回后才能得到服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-SCAN（circular SCAN）&lt;/strong&gt; 调度和 SCAN 类似，但当磁头从磁盘的 0 号扇区移动到磁盘的最后一个扇区（或者柱面）后不会调转方向，而是从 0 号重新开始扫描整个磁盘。&lt;/li&gt;
&lt;li&gt;这两种算法都不会导致饥饿现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;LOOK-和-C-LOOK-调度&quot;&gt;&lt;a href=&quot;#LOOK-和-C-LOOK-调度&quot; class=&quot;headerlink&quot; title=&quot;LOOK 和 C-LOOK 调度&quot;&gt;&lt;/a&gt;LOOK 和 C-LOOK 调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;LOOK 和 SCAN 算法类似，磁头向一个方向移动，但不会一直移动到最后一个柱面才折返，而是处理完这个方向上最后一个请求后就掉头。&lt;/li&gt;
&lt;li&gt;C-LOOK 和 C-SCAN 类似，处理完最后一个请求后就会将磁头恢复到磁盘一端重新开始按固定顺序扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;算法选择&quot;&gt;&lt;a href=&quot;#算法选择&quot; class=&quot;headerlink&quot; title=&quot;算法选择&quot;&gt;&lt;/a&gt;算法选择&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘服务请求很大程度上受文件分配方法影响：一个连续分配文件会产生几个磁盘上相近位置的请求，而链接/索引文件会产生很多分散在磁盘上的块。&lt;/li&gt;
&lt;li&gt;目录和索引块在磁盘上的位置也很重要，如果目录位于第一个柱面而文件数据位于最后一个柱面，则磁头需要横跨整个磁盘宽度。如果目录在中央柱面，则磁头只需要移动不到一半的磁盘宽度。&lt;/li&gt;
&lt;li&gt;磁盘调度算法应该作为一个操作系统的独立模块，在必要的时候模块应该可以被替换。SSTF 或 LOOK 算法是比较合理的默认算法。&lt;/li&gt;
&lt;li&gt;调度算法只考虑了寻道距离。旋转延迟几乎和寻道时间一样，但操作系统无法通过调度改善旋转延迟，因为现代磁盘并不透露逻辑块的物理位置。磁盘制造商会在磁盘控制器中加入磁盘调度算法缓解寻道时间和旋转延迟问题。&lt;/li&gt;
&lt;li&gt;因为操作系统对请求服务的顺序有更多限制（如按需分页的 I/O 请求比普通应用程序的 I/O 请求优先级高），因此操作系统不能完全将磁盘调度交给磁盘控制器，而是选择自己的磁盘调度算法，将请求按调度好的顺序、按批次交给磁盘控制器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;磁盘管理&quot;&gt;&lt;a href=&quot;#磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;磁盘管理&quot;&gt;&lt;/a&gt;磁盘管理&lt;/h1&gt;&lt;h2 id=&quot;磁盘格式化&quot;&gt;&lt;a href=&quot;#磁盘格式化&quot; class=&quot;headerlink&quot; title=&quot;磁盘格式化&quot;&gt;&lt;/a&gt;磁盘格式化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;新磁盘仅仅是含有磁性记录材料的盘片，需要通过 &lt;strong&gt;低级格式化（物理格式化，physical formatting）&lt;/strong&gt; 分为扇区。&lt;/li&gt;
&lt;li&gt;低级格式化将磁盘的每个扇区按特定的数据结构填充数据，扇区的数据结构包括头、数据区（通常 512B）和尾部。头部和尾部包含磁盘控制器需要的信息，如扇区号码和 &lt;strong&gt;纠错代码（error-correcting code，ECC）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;操作系统需要将自己的数据结构记录到磁盘上，首先需要将磁盘分为一个或多个柱面组成的分区，操作系统可以将每个分区视作独立的磁盘。分区之后，操作系统需要通过 &lt;strong&gt;逻辑格式化（logical formatting）&lt;/strong&gt; 来创建文件系统，操作系统会将初始的文件系统数据结构存储到磁盘上。这些数据结构包括那些仍空闲的和已经分配的空间（如分配给 FAT 或者 inode）和一个初始为空的目录。&lt;/li&gt;
&lt;li&gt;为提高效率，多数操作系统将多个块集中到一大块，称为 &lt;strong&gt;簇（cluster）&lt;/strong&gt; 。磁盘 I/O 通过块完成，文件系统 I/O 通过簇完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;引导块&quot;&gt;&lt;a href=&quot;#引导块&quot; class=&quot;headerlink&quot; title=&quot;引导块&quot;&gt;&lt;/a&gt;引导块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机开始运行时需要初始化（自举，bootstrap）程序，它负责初始化系统所需的各个方面，并找到磁盘上的操作系统内核，将其装入内存开始执行。&lt;/li&gt;
&lt;li&gt;自举程序保存在 &lt;strong&gt;只读存储器（ROM）&lt;/strong&gt; 中，其位置固定，并且只读（不受病毒影响），但改变自举代码就需要改变 ROM 硬件芯片。因此操作系统只在启动 ROM 中保留一个非常小的自举程序，这个小自举程序会从磁盘上调入更完整的自举程序。更完整的自举程序可以修改，并且保存在磁盘的启动块上。&lt;/li&gt;
&lt;li&gt;磁盘的 &lt;strong&gt;启动块（boot blocks）&lt;/strong&gt; 位于磁盘的固定位置，拥有启动分区的磁盘称为 &lt;strong&gt;启动磁盘（boot disk）&lt;/strong&gt; 或者 &lt;strong&gt;系统磁盘（system disk）&lt;/strong&gt; 。启动 ROM 中的代码将启动块中的代码装入内存并执行，启动块中的完整自举程序会从 &lt;strong&gt;非固定位置&lt;/strong&gt; 装入整个操作系统并执行。&lt;/li&gt;
&lt;li&gt;以 Windows 2000 为例，其启动代码放置在硬盘的第一个扇区，被称为 &lt;strong&gt;主引导记录（master boot record，MBR）&lt;/strong&gt; ，MRB 中除了包含自举程序的代码，还包含硬盘分区列表和系统引导分区的具体标识。Win 2000 将硬盘分成多个分区，其中一个为 &lt;strong&gt;引导分区（boot partition）&lt;/strong&gt; ，该分区包括了操作系统和设备驱动程序。MBR 确定引导分区的位置后就会读取引导分区的第一个扇区（引导扇区，boot sector）并继续剩余的启动过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;坏块&quot;&gt;&lt;a href=&quot;#坏块&quot; class=&quot;headerlink&quot; title=&quot;坏块&quot;&gt;&lt;/a&gt;坏块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘有移动部件且容错能力小，容易出问题。多数磁盘从工厂出来就有 &lt;strong&gt;坏块（bad blocks）&lt;/strong&gt; 。坏块中的数据会丢失。&lt;/li&gt;
&lt;li&gt;简单磁盘可手动处理坏扇区。如 MS-DOS 的 &lt;code&gt;format&lt;/code&gt; 命令执行逻辑格式化时，会扫描磁盘查找坏扇区，如果找到就在 FAT 的条目中写上特殊值以标明该块已损毁。&lt;/li&gt;
&lt;li&gt;复杂磁盘（高端 PC、WorkStation 或服务器上的 SCSI 磁盘）需要控制器维护一个磁盘坏块链表，这个链表在磁盘出厂前进行低级格式化时就已经初始化，并在磁盘使用过程中不断更新。低级格式化会将一些块备用，操作系统无法看到这些块。当坏块出现时，控制器会用备用块替换这些坏块。这种方案称为 &lt;strong&gt;扇区备用（sector sparing）&lt;/strong&gt; 或 &lt;strong&gt;转寄（forwarding）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;典型的坏块区事务处理：&lt;ul&gt;
&lt;li&gt;操作系统访问逻辑块 87&lt;/li&gt;
&lt;li&gt;控制器计算该块的 ECC 值，发现该块已经损坏，因此将结果通知操作系统&lt;/li&gt;
&lt;li&gt;下次操作系统重启时运行特殊程序告知 SCSI 控制器用备用块替代坏块&lt;/li&gt;
&lt;li&gt;之后的每次系统访问逻辑块 87，请求都会被转换成替代后的备用块地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扇区备用的另一方案是 &lt;strong&gt;扇区滑动（sector slipping）&lt;/strong&gt; ：假定逻辑块 17 损坏，第一个可用的备用块是扇区 203，则将 18 ~ 202 扇区向下滑动一个扇区，变为 19 ~ 203 扇区。这样原本的扇区 18 变为空，用来替换扇区 17。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十一）：文件系统实现&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/06/os-concepts-13/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十三）：I/O 输入系统&lt;/a&gt;     &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/05/os-concepts-12/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十二章大容量存储器结构部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（十一）：文件系统实现</title>
    <link href="http://forec.github.io/2017/01/05/os-concepts-11/"/>
    <id>http://forec.github.io/2017/01/05/os-concepts-11/</id>
    <published>2017-01-05T09:11:59.000Z</published>
    <updated>2017-01-09T14:43:48.280Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十一章文件系统实现部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;文件系统结构&quot;&gt;&lt;a href=&quot;#文件系统结构&quot; class=&quot;headerlink&quot; title=&quot;文件系统结构&quot;&gt;&lt;/a&gt;文件系统结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;磁盘具有如下两个特点因而成为大容量多文件存储的方便介质：&lt;ul&gt;
&lt;li&gt;可以原地重写&lt;/li&gt;
&lt;li&gt;可以直接访问磁盘上任意一块信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存和磁盘之间的 I/O 转移以 &lt;strong&gt;块&lt;/strong&gt; 为单位而非字节。每块为一个或多个扇区，扇区大小从 32 ~ 4096B 不等，通常是 512B。&lt;/li&gt;
&lt;li&gt;文件系统包括多层，下图是一个分层的例子，每一层利用较低层的功能创建新功能以为更高层提供服务。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I/O 控制&lt;/strong&gt; 是最底层，由 &lt;strong&gt;设备驱动程序（device drivers）&lt;/strong&gt; 组成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本文件系统（basic file system）&lt;/strong&gt; 只需要向设备驱动程序发送一般指令就可以对磁盘上的物理块做读写，每个块由它的磁盘地址标识（驱动器 1，柱面 73，磁道 3，扇区 10）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件组织模块（file-organization module）&lt;/strong&gt; 直到文件和它的逻辑块、物理块。因为文件组织模块知道文件类型和位置，因此可以将逻辑块地址转换成基本文件系统用的物理块地址。它也包括 &lt;strong&gt;空闲空间管理器&lt;/strong&gt; 用来追踪未分配的块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑文件系统（logical file system）&lt;/strong&gt; 管理元数据，元数据包括文件系统的全部结构数据而不包括文件的具体内容。逻辑文件系统为文件组织模块提供所需的信息，通过 &lt;strong&gt;文件控制块（file-control block，FCB）&lt;/strong&gt; 来维护文件结构，同时也负责保护和安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目前多数操作系统都支持多个文件系统，UNIX 使用 UNIX文件系统（UFS），基于伯克利快速文件系统（FFS）。标准的 Linux 文件系统是 &lt;strong&gt;可扩展文件系统（extended file system）&lt;/strong&gt; ，常见版本有 ext2 和 ext3。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h1&gt;&lt;h2 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a&gt;基本结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘上的文件系统涉及如下一些结构：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;（每个卷的）引导控制块（boot control block）&lt;/strong&gt; ：从这个卷引导操作系统所需要的信息，如果这个卷没有安装操作系统则这一块内容为空。它通常是卷的第一块，UFS 称之为 &lt;strong&gt;引导块（boot block）&lt;/strong&gt; ，NTFS 系统称之为 &lt;strong&gt;分区引导扇区（partition boot sector）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;（每个卷的）卷控制块（volume control block）&lt;/strong&gt; ：包括卷或分区的详细信息，如分区块数、块大小、空闲块数量和指针、空闲 FCB 的数量和指针等。UFS 称之为 &lt;strong&gt;超级块（superblock）&lt;/strong&gt; ，在 NTFS 中存储在 &lt;strong&gt;主控文件表（Master File Table）&lt;/strong&gt; 。主控文件表采用关系型数据库，每个文件占据一行。&lt;/li&gt;
&lt;li&gt;每个文件的 FCB 包含文件的详细信息（文件权限、拥有者、大小、位置）等，UFS 称之为 &lt;strong&gt;索引节点（inode）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;每个文件系统的目录结构，这些目录结构用于组织文件。UFS 中目录结构包括文件名和相关的索引节点号，NTFS 则保存在主控文件表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存内信息用于文件系统管理，可以通过缓存来提高性能。这部分数据在文件系统挂载（安装）的时候被加载，文件系统卸载的时候丢弃，可能包括：&lt;ul&gt;
&lt;li&gt;内存中的安装表，含有所有已安装卷的信息&lt;/li&gt;
&lt;li&gt;内存中的目录结构缓存，保存最近访问过的目录信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统范围内的打开文件表&lt;/strong&gt; ，在 &lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文件系统接口&lt;/a&gt; 中介绍过，包括每个打开文件的 FCB 副本和其它信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单个进程的打开文件表&lt;/strong&gt; ，每个条目包括指向系统范围内打开文件表的条目的指针以及与进程相关的其它文件信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打开文件表的索引有多种名称，UFS 称之为 &lt;strong&gt;文件描述符（file descriptor）&lt;/strong&gt; ，Windows 称之为 &lt;strong&gt;文件句柄（file handle）&lt;/strong&gt; ，只要文件没有关闭，所有对文件的操作都是通过打开文件表执行的。文件系统中用户进程读文件的操作形式如下图所示。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/in-memory-file-system-read.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分区和挂载&quot;&gt;&lt;a href=&quot;#分区和挂载&quot; class=&quot;headerlink&quot; title=&quot;分区和挂载&quot;&gt;&lt;/a&gt;分区和挂载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个磁盘可以分成多个分区，一个卷也可能横跨多个磁盘上的多个分区（RAID 的一种形式）。&lt;/li&gt;
&lt;li&gt;没有文件系统的分区称作 &lt;strong&gt;生（raw）&lt;/strong&gt; 磁盘，含有文件系统的分区称为 &lt;strong&gt;熟（cooked）&lt;/strong&gt; 的。生磁盘通常用于没有合适的文件系统可以使用的地方，例如 UNIX 的交换空间，或者有的数据库使用生磁盘并将其格式化来满足自己的需求。&lt;/li&gt;
&lt;li&gt;引导信息可以包含在多个分区中，通常是一组有序块，并作为镜像文件读入内存。镜像文件会按照预先指定的位置开始执行，它除了可以启动一个特定的操作系统，还可以支持 &lt;strong&gt;双引导（dual-booted）&lt;/strong&gt; ，即启动加载器知道有哪些操作系统、文件系统位于引导区，并可以引导磁盘上不同分区的不同类型的操作系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根分区（root partition）&lt;/strong&gt; 包括操作系统内核以及其它系统文件，它们在引导时装载到内存中，其它卷会根据操作系统的设定，要么在引导时自动装入，要么通过用户手动装入。当有一个新设备挂载（安装）时，操作系统会验证设备上的文件系统是否有效，并根据需要自动/手动纠正。验证通过后，操作系统会在内存中的 &lt;strong&gt;挂载表/装入表（mount table）&lt;/strong&gt; 中标注该文件系统已经装入，并且存储与此文件系统有关的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟文件系统（Virtual File System，VFS）&lt;/strong&gt; 是文件系统接口和文件系统之间的一层，它的目的有：&lt;ul&gt;
&lt;li&gt;定义一个 VFS 接口将文件系统的通用操作和具体实现划分，多个 VFS 接口的实现能够在同一台机器共存，因此它允许访问安装在本地的多种类型的文件系统；&lt;/li&gt;
&lt;li&gt;VFS 提供了在网络上唯一标识一个文件的机制。它基于 vnode 文件表示结构（包括一个唯一的数值标识符，它能够表明位于整个网络范围内的唯一文件，例如 UNIX 的索引节点 inode 在文件系统内是唯一的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;目录实现&quot;&gt;&lt;a href=&quot;#目录实现&quot; class=&quot;headerlink&quot; title=&quot;目录实现&quot;&gt;&lt;/a&gt;目录实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性列表（linear list）&lt;/strong&gt; 是实现目录最简单的方法，运行非常低效。查找文件需要线性搜索，排序列表可以二分搜索，但排序的需求使文件创建/删除复杂化，它的优点在于可直接生成排序目录信息，可用 B 树实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表（hash table）&lt;/strong&gt; ：在线性列表存储目录之上使用哈希表，根据文件名哈希出一个指向线性列表中元素的指针，需要一些措施避免 &lt;strong&gt;冲突（collision）&lt;/strong&gt; 。其困难在于，如果使用固定大小的哈希表，当条目超出哈希表容量时需要扩充哈希表大小，并且设计新的哈希函数将文件名映射到新的范围内。可以使用 &lt;strong&gt;chained-overflow&lt;/strong&gt; 哈希表，使表中元素为一个链表而非单个记录。虽然冲突将使每个链表长度较大，查找可能变慢，但仍比线性搜索快得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;分配方法&quot;&gt;&lt;a href=&quot;#分配方法&quot; class=&quot;headerlink&quot; title=&quot;分配方法&quot;&gt;&lt;/a&gt;分配方法&lt;/h1&gt;&lt;h2 id=&quot;连续分配&quot;&gt;&lt;a href=&quot;#连续分配&quot; class=&quot;headerlink&quot; title=&quot;连续分配&quot;&gt;&lt;/a&gt;连续分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连续分配（contiguous allocation）&lt;/strong&gt; 要求每个文件在磁盘上占据连续的块。磁盘地址有一个线性序列，如果只有一个作业按照这个序列的顺序访问磁盘，在访问了块 b 后访问块 b+1 就无需移动磁头，即使需要移动磁头也只需要移动一个磁道（从一个柱面的最后扇区到下个柱面第一扇区）。因此， &lt;strong&gt;访问连续分配文件所需的寻道数最小，即使确实需要寻道，所花费的寻道时间也最小&lt;/strong&gt; 。在文件连续分配中，一个文件的目录条目包括文件占有的第一个块的地址，以及该文件分配的块的数量（分配区域的长度）。&lt;/li&gt;
&lt;li&gt;连续分配文件访问非常容易，既可以顺序访问也可以随机访问。它也存在问题，例如如何为新文件寻找空间，这个问题可看作 &lt;a href=&quot;http://blog.forec.cn/2017/01/03/os-concepts-8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存管理&lt;/a&gt; 中 &lt;strong&gt;动态存储分配&lt;/strong&gt; 问题的一个具体应用，即如何从一个空闲的孔列表中寻找一个满足大小为 n 的空间，常用首次适应和最佳适应。&lt;/li&gt;
&lt;li&gt;连续分配方案的另一个问题是需要确定文件需要多少空间，这个知识是无法预知的。如果为一个文件分配的空间过小则文件可能无法原地扩展文件，这时要么终止用户程序并通知用户必须分配更多空间才能运行（这样用户就会过高的预估所需的磁盘空间造成浪费），要么找一个更大的孔，将文件复制到新空间，释放旧空间，但这比较耗时。&lt;/li&gt;
&lt;li&gt;修正的连续分配方案：开始时为文件分配一块连续空间，一旦空间不够，另一块称为 &lt;strong&gt;扩展（extent）&lt;/strong&gt; 的 &lt;strong&gt;连续空间&lt;/strong&gt; 就会被分配给文件。这种情况下，文件块的位置就需要通过开始块地址、块数、指向下一个扩展的指针三项来确定。如果扩展太大，内部碎片会变得严重；随着扩展的分配、删除，外部碎片也将变得严重。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;链接分配&quot;&gt;&lt;a href=&quot;#链接分配&quot; class=&quot;headerlink&quot; title=&quot;链接分配&quot;&gt;&lt;/a&gt;链接分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;链接分配（linked allocation）&lt;/strong&gt; 解决了连续分配的全部问题。链接分配中，每个文件由分布在磁盘上各个位置的多个磁盘块组成，文件目录条目记录了一个文件第一块的指针和最后一块的指针。每一块都会有一个指向下一块的指针，用户无法使用存储这些指针的空间（例如一块有 512B，磁盘地址为 4B，则用户只可用 508B）。&lt;/li&gt;
&lt;li&gt;链接分配对于创建/读/写文件的操作如下：&lt;ul&gt;
&lt;li&gt;创建新文件时只要简单的在目录中增加一个新条目，条目中有指向文件第一块的指针，初始化为 &lt;code&gt;nil&lt;/code&gt; 以表明这是空文件，大小字段也是 0。&lt;/li&gt;
&lt;li&gt;写文件时通过空闲空间管理器寻找一个空闲块，这个块会被写入数据、链接到文件最后一个块的尾部，同时要更新这个文件在目录中条目的记录值（大小、最后一个块的地址）。&lt;/li&gt;
&lt;li&gt;读文件通过条目中存储的第一个块的地址，逐个向后寻找。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接分配的缺点在于：&lt;ul&gt;
&lt;li&gt;只能用于文件的顺序访问，要找到文件的第 i 块必须要从第一块开始寻找，每次访问都需要读磁盘，这还需要涉及磁盘寻道的延迟。因此 &lt;strong&gt;链接分配无法有效支持文件直接访问&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;指针需要空间，每一块都有一定空间被指针占用。这个问题的解决方法是将多个块组成 &lt;strong&gt;簇（cluster）&lt;/strong&gt; ，按簇而不是块来分配（如一个簇有 4 块）。这样指针占用的磁盘空间百分比会下降，但增加了内部碎片。簇可以改善多数算法中的磁盘访问时间，因此在绝大多数操作系统中得到应用。&lt;/li&gt;
&lt;li&gt;可靠性：文件通过指针链接，一旦有一个指针丢失/损坏，整个文件都将崩溃。一个逃避性的解决方案是采用双向链表，或者给每个块存上文件名和相对块数（相对第一块是第几块），但这又增加了过多的额外开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接分配方法的一个变种是 &lt;strong&gt;文件分配表（file-allocation table，FAT）&lt;/strong&gt; ，它被应用于 MS-DOS 和 OS/2 操作系统。每个卷的开始部分存储文件分配表，卷内的每一块都在表中占有一项，这个表可以通过块号码索引， &lt;strong&gt;表中存储的值是这一块指向的下一块块号&lt;/strong&gt; 。&lt;ul&gt;
&lt;li&gt;文件在目录中的条目只含有文件第一块的块号，访问文件时按照 FAT 表中存储的链接关系一直向下寻找，直到最后一块（最后一块在 FAT 表中标记为一个特殊的文件结束值，可以根据这个值判断是否为最后一块）。&lt;/li&gt;
&lt;li&gt;要分配一个新的块，只需要在 FAT 表中找到第一个值为 0（值为 0 表示一个块没有被使用）的块，用新块的地址替换掉此前最后一块的文件结束值，并且用文件结束值替换 FAT 表中的 0。&lt;/li&gt;
&lt;li&gt;FAT 需要采用缓存才能提高效率，否则可能导致大量的磁头寻道时间：磁头要移动到卷的开头读入 FAT  以获得块的位置，然后才能移动到块本身。最坏情况下每块的读取都要移动两次。但它的优点在于改善了随机访问时间， &lt;strong&gt;因为 FAT 的存在，操作系统可以快速找到文件任意一块的位置&lt;/strong&gt; 。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/file-allocation-table.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;索引分配&quot;&gt;&lt;a href=&quot;#索引分配&quot; class=&quot;headerlink&quot; title=&quot;索引分配&quot;&gt;&lt;/a&gt;索引分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果不采用 FAT，链接分配就无法有效支持直接访问，因为块指针散布在整个磁盘，必须顺序读取。 &lt;strong&gt;索引分配（indexed allocation）&lt;/strong&gt; 把所有指针放到一起，通过 &lt;strong&gt;索引块（index block）&lt;/strong&gt; 解决此问题。&lt;/li&gt;
&lt;li&gt;每个文件都有自己的索引块，它是一个磁盘块地址的数组。索引块的第 i 个条目代表文件的第 i 个块，条目中含有索引块的磁盘地址。要读取第 i 块只需要通过索引块第 i 个条目存储的指针来访问（类似第八章分页）。&lt;ul&gt;
&lt;li&gt;创建文件：索引块中所有指针设为 nil。&lt;/li&gt;
&lt;li&gt;第一次写入第 i 块：从空闲空间管理器获取一个空闲块，将数据写入块，并将块地址写到索引块的第 i 个条目中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引分配支持直接访问且没有外部碎片问题，但索引分配会浪费空间&lt;/strong&gt; ：如果一个文件只有两块长，链接分配只需要每块浪费一个指针，而索引分配需要为这个只有两块的文件创建一个完整的索引块，这个索引块里只有两个指针被使用到。&lt;/li&gt;
&lt;li&gt;索引块的大小需要经过仔细考量：每个文件都有一个索引块，索引块太大会造成浪费，太小又不足以满足大文件存储需求。针对这一问题的处理机制有如下几点：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;链接方案（Linked scheme）&lt;/strong&gt; ：一个索引块就是一个磁盘块。它本身能够直接读写，当遇到大文件存储时可以将多个索引块链接。例如一个索引块可以包含一个头部（头部包含文件名）以及 100 个磁盘块的地址。索引块的最后一个存储单元存储着指向下一个索引块的地址如果是小文件则这个指针为 &lt;code&gt;nil&lt;/code&gt;，如果是大文件则指向了另一个索引块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多层索引（Multilevel index）&lt;/strong&gt; ：设置两层索引块，第一层指向第二层，第二层指向文件块。根据最大文件大小的不同，可以继续到第三/四层。对于块大小为 4KB 的情况，可以在一个索引块里装入 1024 个 4B 指针，两层索引就可以容纳 1048 576 个数据块，即最大文件为 4GB。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合方案（Combined scheme）&lt;/strong&gt; ：在 UFS 中使用了这种方案。将索引块的前 15 个指针存在文件的 inode 里，这 15 个指针中：前 12 个直接指向了数据块，这样不超过 12 块的文件就不需要其它索引块；后 3 个指针分别是一级间接块、二级间接块、三级间接块指针。这种方法允许一个文件的块数超过 4B 文件指针能访问的空间。许多 UNIX 系统支持 64 位文件指针，这时允许文件/文件系统达到数 T 字节。UNIX 的inode 大致如下：&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/unix-inode-indexed.jpg&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引分配方案和链接分配方案在性能上都有欠缺，虽然索引块能够缓存在内存里，但数据块会分布到整个分区中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;性能&quot;&gt;&lt;a href=&quot;#性能&quot; class=&quot;headerlink&quot; title=&quot;性能&quot;&gt;&lt;/a&gt;性能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;连续分配对于任意类型的访问都只需要访问一次，链接分配可以将下一块的地址放到内存中并能直接读取，但对于直接访问需要读多次磁盘。所以有些系统通过使用连续分配支持文件直接访问，通过链接分配支持顺序访问。这种系统在创建文件时就要指明文件的类型（顺序访问还是直接访问），如果是直接访问还必须说明最大文件大小。&lt;/li&gt;
&lt;li&gt;索引分配非常复杂。如果索引块已在内存中则可以直接访问，但将索引块保存在内存中需要非常大的空间。尤其是多级索引，对于一个大文件来说，如果要访问文件末尾部分的数据，可能需要将所有索引块读入内存才能读到需要的数据库。所以索引分配的性能依赖于索引结构、文件大小和所需要的块的位置。&lt;/li&gt;
&lt;li&gt;有的系统把连续分配和索引分配结合，对于小文件（3、4块大小的）采用连续分配，大文件切换到索引分配。因为文件系统中大多数文件较小，所以小文件连续分配效率较高，平均性能较好。&lt;/li&gt;
&lt;li&gt;由于 CPU 和磁盘速度不等，花费数千条 CPU 指令来节省一些磁头移动都是值得的，随着时间推移，这种不等程度还会增加。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;空闲空间管理&quot;&gt;&lt;a href=&quot;#空闲空间管理&quot; class=&quot;headerlink&quot; title=&quot;空闲空间管理&quot;&gt;&lt;/a&gt;空闲空间管理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;系统需要维护 &lt;strong&gt;空闲空间链表（free-space list）&lt;/strong&gt; 以记录空闲磁盘空间，创建文件时会从空闲空间链表分配，删除文件时磁盘空间会加回到空闲空间链表上（称之为链表但不一定表现为链表）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;位向量&quot;&gt;&lt;a href=&quot;#位向量&quot; class=&quot;headerlink&quot; title=&quot;位向量&quot;&gt;&lt;/a&gt;位向量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将空闲空间用 &lt;strong&gt;位图（bit map）&lt;/strong&gt; 或 &lt;strong&gt;位向量（bit vector）&lt;/strong&gt; 表示，每块用一位说明是否为空闲，1 表示空闲，0 表示已经分配。&lt;/li&gt;
&lt;li&gt;此方式查找磁盘上第 1 个空闲块和 n 个连续空闲块时简单高效：&lt;ul&gt;
&lt;li&gt;按顺序检查位图中的每个字是否为 0 即可确定对应的块是否已经全部分配，第一个非 0 的字中，第一个 1 位偏移旧对应着第一个空闲块；&lt;/li&gt;
&lt;li&gt;连续 n 个空闲块只需要判断是否有连续 &lt;code&gt;[n / 字的位数]&lt;/code&gt; 个字均为最大值（如一个字就是一个字节时，只要连续有 &lt;code&gt;[n / 8]&lt;/code&gt; 个字节全为 255 就说明这部分块都空闲）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除非整个位向量都能保存在内存中，否则位向量的效率不高。对于小磁盘，位向量的大小可以接受，但对于大磁盘而言（如 40GB，每块 1KB）就需要超过 5MB 空间存储位图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;链表和组&quot;&gt;&lt;a href=&quot;#链表和组&quot; class=&quot;headerlink&quot; title=&quot;链表和组&quot;&gt;&lt;/a&gt;链表和组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将所有空闲磁盘块用 &lt;strong&gt;链表（Linked List）&lt;/strong&gt; 链接，将指向第一个空闲块的指针放在磁盘的一个特殊位置，同时也缓存到内存里。第一块空闲块中包含了指向下一个空闲磁盘块的指针。&lt;/li&gt;
&lt;li&gt;此方案效率不高，要遍历整个空闲块列表需要从磁盘读出每一块，这要耗费大量 I/O 时间。不过通常操作系统只需要获得一个空闲块以提供给文件，因此一般只需要分配空闲表的第一块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组（grouping）&lt;/strong&gt; 是对空闲链表的改进：将 n 个空闲块的地址存在第一个空闲块里，前 n-1 个地址都指向真正的空闲块， &lt;strong&gt;最后一个地址指向了另一个包含另外 n 个空闲块的块地址&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;计数&quot;&gt;&lt;a href=&quot;#计数&quot; class=&quot;headerlink&quot; title=&quot;计数&quot;&gt;&lt;/a&gt;计数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通常会有多个连续的块需要同时分配、释放，尤其是采用了连续分配或簇的情况下。因此可以不记录 n 个空闲块地址，而是记录连续多块空闲块的第一块的地址，以及连续的空闲块的数量。这样空闲空间表的每个条目包含了第一个空闲块地址和连续空闲块数量，虽然每个条目占用的空间增长了，但表的总长度会缩短（连续空闲块的数量往往大于 1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;UNIX-成组链接（补充）&quot;&gt;&lt;a href=&quot;#UNIX-成组链接（补充）&quot; class=&quot;headerlink&quot; title=&quot;UNIX 成组链接（补充）&quot;&gt;&lt;/a&gt;UNIX 成组链接（补充）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将文件存储设备中的所有的空闲块 &lt;strong&gt;从后向前&lt;/strong&gt; 按 50 块为一组进行划分，每组的第一块用于存放 &lt;strong&gt;前一组&lt;/strong&gt; 的总块数和每块的块号，因为第一组前面已经没有其他组存在，所以第一组实际有 49 块。因为存储空间不一定正好是 50 的整数倍，所以最后一组可能不足 50 块。因为最后一组后面没有其他组，所以最后一组的总块数和每块块号的信息存放到管理文件存储设备的文件资源表中。如下图所示。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/unix-group-linked.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;操作系统启动时将文件资源表复制到内存，此时文件资源表中包含了最后一组的空闲块总数以及空闲块的块号。操作系统还会设置一个用于空闲块分配、回收的堆栈，堆栈存储着空闲块的块号，栈指针 ptr 的初值等于最后一组的空闲块的总块数。&lt;/li&gt;
&lt;li&gt;成组链接分配方法：申请者请求获得 n 块空闲块，操作系统将按照先进先出的原则，将栈顶指向的块号分配给请求者，同时 ptr 自减。重复此操作直到 n 块分配完毕，或者堆栈中只剩下最后一个空闲块的块号（此块实际存储的是下一组的空闲块块数和各块块号）。当堆栈只剩下最后一个空闲块的块号时：&lt;ul&gt;
&lt;li&gt;从堆栈中弹出该块的块号，系统启动 I/O 设备，将该块存放的内容读入内存（即将下一组空闲块号和总块数读入空闲资源表），并设置 ptr 为下一组的空闲块数&lt;/li&gt;
&lt;li&gt;文件存储设备的最后一个空闲块中设置有尾部标识，表示空闲块已经分配完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成组链接回收方法：用户删除某个文件时，ptr 自增并将空闲块号入栈。若 ptr 为 50 则表明当前已经凑足一组，该组回收结束。&lt;ul&gt;
&lt;li&gt;如果还有空闲物理块 F 需要回收，则将块 F 回收，并且启动设备 I/O，把栈中记录的 50 个块号和块数（50）写入到块 F 中。设置 ptr 为 1，将块 F 的块号入栈，开始新的一组空闲块回收。&lt;/li&gt;
&lt;li&gt;对空闲块的分配和回收操作必须互斥进行（栈操作要互斥）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十）：文件系统接口&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-12/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十二）：大容量存储器结构&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/05/os-concepts-11/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十一章文件系统实现部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（十）：文件系统接口</title>
    <link href="http://forec.github.io/2017/01/05/os-concepts-10/"/>
    <id>http://forec.github.io/2017/01/05/os-concepts-10/</id>
    <published>2017-01-05T03:55:47.000Z</published>
    <updated>2017-01-11T13:55:32.263Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十章文件系统接口部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h1&gt;&lt;h2 id=&quot;概念、属性和操作&quot;&gt;&lt;a href=&quot;#概念、属性和操作&quot; class=&quot;headerlink&quot; title=&quot;概念、属性和操作&quot;&gt;&lt;/a&gt;概念、属性和操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;信息可以在多种介质上存储，为了方便使用，操作系统为不同的信息存储设备提供了统一的逻辑接口：对存储设备的各类属性加以抽象，定义了逻辑存储单元（文件），之后再将文件映射到非易失性的物理设备上。&lt;/li&gt;
&lt;li&gt;文件是 &lt;strong&gt;一系列有名称的、记录在二级存储器上的信息集合&lt;/strong&gt; 。在用户眼里，文件是逻辑外存的最小分配单元，数据必须通过文件的形式才能写入到外存。文件根据不同的类型有一定 &lt;strong&gt;结构（structure）&lt;/strong&gt; ，例如 &lt;em&gt;文本文件&lt;/em&gt; 由行（页）组成，每行又由字符组成； &lt;em&gt;源文件&lt;/em&gt; 由子程序和函数组成，子程序和函数又由声明、执行语句组成； &lt;em&gt;目标文件&lt;/em&gt; 是一系列字节序列，按目标系统链接器所能理解的方式组成； &lt;em&gt;可执行文件&lt;/em&gt; 为一系列可以装入程序调入内存执行的代码段。&lt;/li&gt;
&lt;li&gt;所有文件的信息都保存在文件系统的目录结构中，目录结构（必须也是非易失性的）也保存在外存中。 &lt;strong&gt;文件属性（file attributes）&lt;/strong&gt; 通常包括：&lt;ul&gt;
&lt;li&gt;名称：文件符号名称，按人类理解方式保存&lt;/li&gt;
&lt;li&gt;标识符：文件系统内标识此文件的唯一标签，通常为数字&lt;/li&gt;
&lt;li&gt;类型：此字段仅对于支持多类型文件系统有效&lt;/li&gt;
&lt;li&gt;位置：指向设备和设备上该文件位置的指针&lt;/li&gt;
&lt;li&gt;大小：文件当前大小，也可表示文件允许的最大容量&lt;/li&gt;
&lt;li&gt;保护：读、写、执行控制权限&lt;/li&gt;
&lt;li&gt;时间、日期、用户标识：文件创建、上次修改、最近访问等信息，用于保护、安全以及使用记录的追踪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件属于 &lt;strong&gt;抽象数据类型（abstract data type）&lt;/strong&gt; ，文件操作的最小集合包括如下六条，这六条基本操作可以组合以实现其他文件操作：&lt;ul&gt;
&lt;li&gt;创建文件：包括在文件系统中为文件找到空间并分配、在文件目录中为新文件创建条目；&lt;/li&gt;
&lt;li&gt;写文件：系统要为文件维护一个写位置的指针，一旦发生写操作就需要更新写指针（写方式 &lt;code&gt;fopen&lt;/code&gt; 返回值就是一个写指针）；&lt;/li&gt;
&lt;li&gt;读文件：系统也需要为文件维护读指针，一个进程通常只对一个文件读或写，故当前操作位置（读/写指针）可作为每个进程 &lt;strong&gt;当前文件位置指针（current-file-position pointer）&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;文件内重定位（repositioning within a file）：修改文件位置指针的值（seek 操作，文件寻址），这不需要执行真正的 I/O；&lt;/li&gt;
&lt;li&gt;删除文件：需要在目录中搜索给定名称文件，释放其空间并删除文件目录中的条目；&lt;/li&gt;
&lt;li&gt;截短（truncating）：删除文件内容而保留属性，将文件长度设为 0 并释放空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统维护一个 &lt;strong&gt;打开文件表（open-file table）&lt;/strong&gt; ，当需要一个文件时，操作系统根据这个表的索引来指定文件，避免了每次文件操作都要搜索文件目录。有的系统会在首次引用文件时隐式地打开它，绝大多数操作系统要求程序员通过 &lt;code&gt;open()&lt;/code&gt; 操作显示地打开文件，并将文件条目复制到打开文件表中。当文件不再使用时，进程可以 &lt;em&gt;关闭&lt;/em&gt; 这个文件，操作系统会从打开文件表删除文件对应的条目。系统调用 &lt;code&gt;open()&lt;/code&gt; 会返回一个 &lt;strong&gt;指向打开文件表中一个条目的指针&lt;/strong&gt; ，所有 I/O 操作会通过使用该指针来进行。&lt;/li&gt;
&lt;li&gt;多个进程同时打开同一文件的情况下，操作系统通常采用 &lt;strong&gt;两级内部表&lt;/strong&gt; ：单个进程的表和整个系统的表。其中单个进程的表追踪单个进程打开的所有文件（该进程对文件的使用信息，如该进程对该文件操作的指针位置、权限等），表中的每一个条目指向整个操作系统打开文件表中相对应的一项。而操作系统的打开文件表（整个系统的表）包含着与进程无关的文件信息（文件在磁盘的位置、大小等），一旦一个文件第一次被进程打开，操作系统会在打开文件表中增加相应的条目；而 &lt;strong&gt;一个已经被打开的文件再次被其它进程打开时，仅仅在进程的打开文件表中增加一个指向整个系统表的相应条目&lt;/strong&gt; 。一般系统维护的打开文件表中，每个文件会有一个文件打开计数器，用来记录多少进程打开了该文件，当计数器降到 0 时标识文件不再使用，可以从打开文件表删除。&lt;/li&gt;
&lt;li&gt;以上，每个打开文件应当包括如下信息：&lt;ul&gt;
&lt;li&gt;文件指针：这个属性对于每个进程都可能不同，因此它保存在进程各自的打开文件表中，每个进程都需要为自己打开的每个文件维护一个文件指针。&lt;/li&gt;
&lt;li&gt;文件打开计数器：此属性保存在操作系统的文件打开表中，操作系统等待所有进程均不在引用某文件（计数器为 0）后才会将其条目删除。&lt;/li&gt;
&lt;li&gt;文件磁盘位置：这一属性用于定位磁盘上的文件位置，保存在操作系统的打开文件表中。&lt;/li&gt;
&lt;li&gt;访问权限：此属性保存在进程各自的打开文件表中，操作系统根据进程各自的访问模式决定是否允许进程的 I/O 请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部分操作系统提供了 &lt;strong&gt;文件锁&lt;/strong&gt; 以允许一个进程锁住文件，禁止其他进程访问。文件锁可以用于多个进程共享的文件（如多个进程访问、修改的系统日志）。其中， &lt;strong&gt;共享锁（shared lock）&lt;/strong&gt; 类似 &lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程同步&lt;/a&gt; 中读者-写者问题的读者锁，它允许多个进程并发获取； &lt;strong&gt;专用锁（exclusive lock）&lt;/strong&gt; 类似写者锁，只有一个进程可以获取此锁。有的操作系统只提供专用锁。另外，操作系统可以提供 &lt;strong&gt;强制（mandatory）&lt;/strong&gt; 或者 &lt;strong&gt;建议（advisory）&lt;/strong&gt; 文件加锁机制，如果文件锁是强制的，那么操作系统会禁止其它进程访问一个已经加锁的文件；如果文件锁是建议的，则操作系统不会禁止。因此，对于建议加锁，程序开发者要确保进程适当的获取、释放锁。通常 Windows 系统采用强制加锁，而 UNIX 系统采用建议加锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类型和结构&quot;&gt;&lt;a href=&quot;#类型和结构&quot; class=&quot;headerlink&quot; title=&quot;类型和结构&quot;&gt;&lt;/a&gt;类型和结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不同的应用程序可以使用不同的扩展名来指明文件。UNIX 系统采用 &lt;strong&gt;幻数（magic number）&lt;/strong&gt; 表明文件类型，这部分数据保存在文件的开始位置（不是所有的文件都具有幻数）。UNIX 也不记录文件创建程序的名称，但仍允许通过文件扩展名来确定文件内容类型。&lt;/li&gt;
&lt;li&gt;文件类型可用于表示文件的内部结构（例如源代码文件和目标文件都有一定的结构来适应对应处理程序的要求），这些文件必须符合操作系统要求的结构。随着操作系统支持文件结构种类的增加，操作系统也会增大。很多操作系统 &lt;strong&gt;支持最少数量的文件结构&lt;/strong&gt; （包括 UNIX、MS-DOS），如 UNIX 认为每个文件是 8 位字节序列组成，操作系统不会去试着解释这些位。这样的方案提供了很高的灵活性（但是操作系统本身并不提供任何支持），应用程序必须通过自己的代码去解释输入的文件。当然操作系统必须至少支持可执行文件结构。&lt;/li&gt;
&lt;li&gt;磁盘系统通常有明确定义的块（由扇区大小决定），所有磁盘 I/O 均按块执行。因为物理块大小通常不会和文件操作的逻辑记录长度相同，因此文件系统将若干个逻辑记录 &lt;strong&gt;打包（packing）&lt;/strong&gt; 成块再执行 I/O 操作。同样，由于磁盘空间按块划分，文件最后一块的部分空间通常会被浪费，产生内部碎片，块越大内部碎片也越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;访问方法和文件系统挂载&quot;&gt;&lt;a href=&quot;#访问方法和文件系统挂载&quot; class=&quot;headerlink&quot; title=&quot;访问方法和文件系统挂载&quot;&gt;&lt;/a&gt;访问方法和文件系统挂载&lt;/h1&gt;&lt;h2 id=&quot;访问方法&quot;&gt;&lt;a href=&quot;#访问方法&quot; class=&quot;headerlink&quot; title=&quot;访问方法&quot;&gt;&lt;/a&gt;访问方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序访问（Sequential Access）&lt;/strong&gt; ：文件信息按顺序处理。这种访问模式最常用，如编辑器、编译器等均按此种方式访问。大量文件操作都是读写操作，两种操作都会向某一方向移动文件指针。顺序访问基于文件的磁带模型（读写/倒回），对顺序访问设备和随机访问设备都适用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接访问（Direct Access）&lt;/strong&gt; ：也称 &lt;strong&gt;相对访问（relative access）&lt;/strong&gt; ，文件由固定长度的 &lt;strong&gt;逻辑记录（logical records）&lt;/strong&gt; 组成，因此程序可以直接计算出文件所在的块并快速读写（磁盘允许对任意块进行随机读写）。数据库通常使用这种类型的文件。因为随机读写以块为目标，故文件操作要经过修改从而将块号作为参数。有两种方式：一是将 &lt;em&gt;读下一个字节&lt;/em&gt; 变成 &lt;em&gt;读 n&lt;/em&gt; ，将 &lt;em&gt;写下一个字节&lt;/em&gt; 变成 &lt;em&gt;写 n&lt;/em&gt; ；另一种则是仍使用 &lt;em&gt;读下一个&lt;/em&gt; 和 &lt;em&gt;写下一个&lt;/em&gt; ，但是增加了 &lt;em&gt;定位文件到 n&lt;/em&gt; 的操作。用户向操作系统提交的块号是 &lt;strong&gt;相对块号（relative block number）&lt;/strong&gt; ，是相对于文件开始的索引。&lt;/li&gt;
&lt;li&gt;不是所有的操作系统都支持顺序访问和直接访问，部分系统只允许顺序或随机访问，有的则再文件创建时指定文件是顺序还是随机访问。对于直接访问的文件，可以非常容易的模拟出顺序访问，而在顺序访问文件中模拟直接访问是非常低效的。&lt;/li&gt;
&lt;li&gt;其他访问方式通常建立在直接访问之上，涉及文件 &lt;strong&gt;索引（index）&lt;/strong&gt; ，索引包含了各个块的指针。要查找文件记录，要先搜索索引，然后根据指针直接访问文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;文件系统挂载&quot;&gt;&lt;a href=&quot;#文件系统挂载&quot; class=&quot;headerlink&quot; title=&quot;文件系统挂载&quot;&gt;&lt;/a&gt;文件系统挂载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文件系统在使用前必须 &lt;strong&gt;挂载（mount）&lt;/strong&gt; ，中文版翻译称为 &lt;strong&gt;安装&lt;/strong&gt; 。操作系统需要知道设备名称，以及这个设备在文件系统中的挂载（安装）位置，这个位置称为挂载点（mount point），通常是一个空目录。&lt;/li&gt;
&lt;li&gt;操作系统会验证一个挂载（安装）的设备是否包含一个有效文件系统，验证流程如下：通过设备驱动程序读入设备目录，验证目录是否符合操作系统期待的格式。验证通过后操作系统会在目录结构中记录这个文件系统已经被安装在挂载点上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;磁盘（或其他大存储设备）可以当作整体运用在一个文件系统中，但有时需要在一个磁盘上安装多种文件系统。磁盘上各个部分称为 &lt;strong&gt;分区（partitions）&lt;/strong&gt; 或 &lt;strong&gt;片（slices）&lt;/strong&gt; ，或称为 &lt;strong&gt;小型磁盘（minidisk，IBM）&lt;/strong&gt; 。每个磁盘分区可以创建一个文件系统，这些部分可以组合起来成为更大的结构 &lt;strong&gt;卷（volume）&lt;/strong&gt; ，也可以在卷上创建文件系统。下面将 &lt;strong&gt;存储文件系统的一大块空间作为卷&lt;/strong&gt; ，卷可以存放多个操作系统。包含文件系统的卷需要记录文件系统中的信息，这些信息保存在 &lt;strong&gt;设备目录（device directory）&lt;/strong&gt; 或 &lt;strong&gt;卷表（volume table of contents）&lt;/strong&gt; 中，它记录了卷上所有文件信息（名称、位置、大小、类型等）。&lt;/li&gt;
&lt;li&gt;目录可以视作符号表，将文件名称转换成目录条目。目录需要支持如下操作：&lt;ul&gt;
&lt;li&gt;在目录中搜索文件&lt;/li&gt;
&lt;li&gt;创建文件&lt;/li&gt;
&lt;li&gt;删除文件&lt;/li&gt;
&lt;li&gt;遍历目录&lt;/li&gt;
&lt;li&gt;重命名文件&lt;/li&gt;
&lt;li&gt;跟踪文件系统：定期备份整个文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组织目录结构的要求（补充）：&lt;ul&gt;
&lt;li&gt;高效（能够快速定位文件）&lt;/li&gt;
&lt;li&gt;命名（用户要方便命名、不同用户可以有同名文件、同一文件可以有多个名称）&lt;/li&gt;
&lt;li&gt;成组（可以按照文件属性划分成组）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单层结构目录（single-level directory）&lt;/strong&gt; ：所有文件保存在同一目录中，便于理解和支持。但当文件类型增加或者系统需要为多个用户提供服务时，必须保证所有文件名称唯一。文件名称长度有限，MS-DOS 只允许 11 个字符，UNIX 允许 255 个字符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双层结构目录（two-level）&lt;/strong&gt; ：单层目录结构会在不同用户直接引起文件名混淆，双层结构目录中，每个用户有自己的 &lt;strong&gt;用户文件目录（user file directory，UFD）&lt;/strong&gt; ，每个 UFD 都有相似的结构，但只包含所属用户的文件。用户作业执行/用户注册时，搜索主系统的 &lt;strong&gt;主文件目录（master file directory，MFD）&lt;/strong&gt; 来检索到用户的 UFD，这允许多个用户拥有相同名称的文件。&lt;ul&gt;
&lt;li&gt;双层结构目录能够有效地对用户隔离，但不利于用户之间的合作和文件共享。双层结构目录等价于一棵高度为 2 的倒置树。&lt;/li&gt;
&lt;li&gt;对于系统库等每个进程都需要的文件，双层结构目录必须将这些系统文件复制到每个 UFD 下，这导致大量空间浪费，解决方法是修改搜索步骤，在根目录下定义一个特殊的用户目录，目录中包含所有的系统文件。当进程在 UFD 查找不到需要的文件时会搜索这个特殊用户目录。给定一个文件，搜索的一系列目录称为 &lt;strong&gt;搜索路径（search path）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;树状目录结构（tree-structured directories）&lt;/strong&gt; ：允许用户创建自己的子目录，系统内每个文件有唯一路径名。目录包括一组文件和子目录，目录实际也是一个按特殊方式访问的文件，文件系统中每个条目都需要一位定义其为文件（0）还是子目录（1），并且删除目录条目需要特殊的系统调用。&lt;ul&gt;
&lt;li&gt;通常每个进程有一个当前目录， &lt;strong&gt;当前目录（current directory）&lt;/strong&gt; 包括进程当前感兴趣的多数文件，引用文件时也会先搜索当前目录。&lt;/li&gt;
&lt;li&gt;路径名分 &lt;strong&gt;绝对路径名（absolute path name）&lt;/strong&gt; 和 &lt;strong&gt;相对路径名（relative path name）&lt;/strong&gt; 。绝对路径名从根开始给出路径上的目录名，一直到指定文件；相对路径名从进程的当前目录开始定义路径。&lt;/li&gt;
&lt;li&gt;删除目录：如果目录为空可以直接删除，若目录不为空，有的系统不允许删除不为空的目录（MS-DOS，要删除一个有内容的目录就必须先清空整个目录内的文件），有的系统则提供了选择（选择是否允许删除全部子目录和文件，这样更危险，比如 &lt;code&gt;rm /* -rf&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;用户除了可以访问自己的文件，还可以通过路径名访问其他用户文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无环图目录（acyclic graph）&lt;/strong&gt; ： &lt;strong&gt;树状结构禁止共享文件和目录&lt;/strong&gt; ，无环图允许目录含有共享子目录和文件。无环图是树状结构目录的扩展。&lt;ul&gt;
&lt;li&gt;共享目录不同于文件复制，共享情况下任何一个用户对文件做出的改动都对其它共享用户可见。&lt;/li&gt;
&lt;li&gt;实现 &lt;strong&gt;共享目录方法&lt;/strong&gt; 1：创建一种称为 &lt;strong&gt;链接（link）&lt;/strong&gt; 的新目录条目，链接实际是另一个文件/目录的指针，操作系统可以通过链接保存的路径名定位真实文件（这一行为称为 &lt;strong&gt;解析（resolve）&lt;/strong&gt;  。&lt;/li&gt;
&lt;li&gt;实现共享目录方法 2：每个用户都有共享文件的副本，但这些副本时刻更新着所有被共享文件的信息。但这样做会使副本和原始的文件无法区分，并且一旦有用户修改了副本/原始文件，所有其它副本都需要修改以维护一致性。&lt;/li&gt;
&lt;li&gt;实现 &lt;strong&gt;共享目录问题&lt;/strong&gt; 1：一个文件被共享，因此可能会有多个绝对路径指向了同一个文件，这时对于遍历文件系统/查找文件/统计文件数量/备份文件等操作，需要解决不重复计算的问题。&lt;/li&gt;
&lt;li&gt;实现共享目录问题 2：分配给共享文件的空间何时可以删除？若用户删除文件即删除，则会留下很多悬挂链接指向不存在的文件，如果删除部分的空间被其它文件使用，这样链接又会指向其他文件的某个部分。可以在文件删除时搜索并删除这些悬挂的链接，但相对耗时；或者直到某个进程使用了某个悬挂链接时再去清理（UNIX 和 Windows 系统均不会在删除文件时删除链接，而由用户意识到原来文件已经删除）&lt;/li&gt;
&lt;li&gt;实现共享目录问题 3：删除共享文件的另一种方式是保留文件直到所有指向该文件的引用都删除为止。这样需要为每个文件维护一个引用列表，这个引用列表可能很大。因此可以用一个计数器代替引用列表。UNIX 操作系统对 &lt;strong&gt;硬链接（hard links，非符号链接）&lt;/strong&gt; 采用了这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用图目录（general graph）&lt;/strong&gt; ：无环图结构必须确保没有环，而对于无环图的共享部分，如果搜索一个共享子目录没有找到文件，就应该避免通过其它链接再次搜索这个共享子目录（浪费时间）。如果目录中甚至有环存在（例如子目录又包含了到父目录的链接），就更要避免循环搜索。&lt;ul&gt;
&lt;li&gt;避免循环搜索：限制搜索时访问目录的次数。&lt;/li&gt;
&lt;li&gt;删除文件：可能出现文件自我引用，这时需要垃圾收集机制确定什么时候可以删除引用。垃圾收集需要遍历整个文件系统并将所有能够访问到的空间标记，之后第二次遍历将第一遍没有标记的位置收集到空闲空间链表上。&lt;/li&gt;
&lt;li&gt;如何避免无环：仅允许链接到一个没有子目录的文件；垃圾回收；每次新链接加入都运行环检测算法判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;文件共享&quot;&gt;&lt;a href=&quot;#文件共享&quot; class=&quot;headerlink&quot; title=&quot;文件共享&quot;&gt;&lt;/a&gt;文件共享&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;多用户操作系统必须控制文件共享。系统可以默认允许一个用户访问其他用户文件，也可以要求一个用户授予文件固定的访问权限。多用户系统需要比但用户系统维护更多的文件和目录属性，现在绝大多数系统采用了文件（目录） &lt;strong&gt;拥有者（owner，user）&lt;/strong&gt; 和 &lt;strong&gt;组（group）&lt;/strong&gt; 的概念，其中拥有者控制权最高，拥有者的 ID 会和文件属性一起保存。同一组的成员具有相同的权限，并只能执行拥有者具有权限的子集。&lt;/li&gt;
&lt;li&gt;远程文件系统的实现方式包括：&lt;ul&gt;
&lt;li&gt;用户通过程序（ftp）在机器之间传输文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式文件系统（Distributed Information System）&lt;/strong&gt; ：远程目录可以从本机直接访问&lt;/li&gt;
&lt;li&gt;万维网（和 ftp 类似，基本是 ftp 的包装）：用浏览器下载文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C/S模型（客户机-服务器模型）：服务器包含文件，客户机访问文件。服务器需要表明目录和卷的哪些文件可用，而客户机的身份需要通过网络名称/IP 或者其它标识符鉴别（这些可能被欺骗/模仿），因此客户机需要通过加密密钥向服务器进行安全验证，安全验证也会遇到很多问题，所以多数情况还是使用不太安全的验证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障模式（Failure Modes）&lt;/strong&gt; ：本地文件系统可能因为某些原因出错，比如包含文件系统的磁盘老化，目录结构或者其它磁盘管理信息（统称为 &lt;strong&gt;元数据，metadata&lt;/strong&gt; ）损坏等。用户或管理员的冒失也会导致文件丢失/整个目录删除等。远程文件系统因为网络因素，需要有更多的故障模式，客户机和服务器之间 &lt;strong&gt;需要对每一次远程请求记录信息&lt;/strong&gt; 以在故障发生时能够恢复。类似 NFS 的协议对每个请求的信息都加以记录，因此能够很容易的从故障中恢复，但安全性较差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性语义（Consistency Semantics）&lt;/strong&gt; ：描述多用户同时访问共享文件时的语义，规定了一个用户修改的数据什么时候对另一个用户可见。&lt;ul&gt;
&lt;li&gt;UNIX 语义（UFS）：用户对已经打开的文件进行写操作会立刻被其它同时打开这一文件的用户可见，还有一种共享模式会共享文件指针的位置，一个文件移动了文件指针会影响其他用户，文件有一个映像，这个映像允许来自不同用户的交替访问（映像是互斥资源）。&lt;/li&gt;
&lt;li&gt;AFS 文件系统：用户对打开文件的写操作不会立刻被其他用户可见，一旦文件关闭，对文件的修改只能被以后打开的会话所见，已经打开文件的用户无法看到这些修改。一个文件会有多个物理映像，用户允许对自己的映像进行不受限制的读写操作（没有互斥）。&lt;/li&gt;
&lt;li&gt;不可修改共享文件语义：文件不可修改，即只读（文件名不能重用、文件内容不可修改）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;保护&quot;&gt;&lt;a href=&quot;#保护&quot; class=&quot;headerlink&quot; title=&quot;保护&quot;&gt;&lt;/a&gt;保护&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;计算机系统中保存的信息必须能够免受物理损坏（可靠性）和非法访问（保护）。对于多用户系统尤其需要某些机制。&lt;/li&gt;
&lt;li&gt;访问类型：需要 &lt;strong&gt;控制访问（controlled access）&lt;/strong&gt; 来限制可以进行的文件访问类型，访问类型包括：读、写、执行、添加、删除、列表清单（获取文件名称、属性等）。更多操作（重命名、编辑等）都是这些底层操作的组合，因此保护只需要在底层提供，高层操作涉及的底层操作如果不满足保护的要求就会被拒绝。&lt;/li&gt;
&lt;li&gt;访问控制：根据用户身份判断能否对某个文件访问。每个文件/目录都增加一个 &lt;strong&gt;访问控制列表（access-control list，ACL）&lt;/strong&gt; 来指定每个用户对这个文件/目录具有的合法的访问类型。缺点是访问控制列表会较长，并且一般事先无法知道系统的用户列表，这将导致更复杂的空间管理。&lt;/li&gt;
&lt;li&gt;操作系统为每个文件提供了三种用户类型：拥有者、组（一组需要共享文件并且具有相同访问需求的用户集合）、其他用户。Linux 中每种类型的用户都有 &lt;code&gt;rwx&lt;/code&gt; 三个位。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/04/os-concepts-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（九）：虚拟内存&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-11/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十一）：文件系统实现&lt;/a&gt;        &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/05/os-concepts-10/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第十章文件系统接口部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（九）：虚拟内存</title>
    <link href="http://forec.github.io/2017/01/04/os-concepts-9/"/>
    <id>http://forec.github.io/2017/01/04/os-concepts-9/</id>
    <published>2017-01-03T16:42:29.000Z</published>
    <updated>2017-01-11T13:38:54.955Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第九章虚拟内存部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;虚拟内存技术允许进程在执行时不完全加载入内存（动态加载也可以实现，但要求程序员做更多细致的工作），因此程序可以远大于物理内存。虚拟内存将内存抽象为一个 &lt;strong&gt;统一的&lt;/strong&gt; 巨大的统一存储数组，使用户看到的逻辑内存和物理内存分离，允许程序员不受内存存储限制。此外虚拟内存使进程共享文件/地址空间变得容易。&lt;/li&gt;
&lt;li&gt;很多情况下不需要将整个程序加载到内存中，如：&lt;ul&gt;
&lt;li&gt;程序执行过程中通常很少发生错误，处理异常错误的代码几乎不被执行&lt;/li&gt;
&lt;li&gt;数组、链表、表等结构通常会被分配比实际需要的更大的内存&lt;/li&gt;
&lt;li&gt;程序的一些功能/选项很少被使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只将程序的一部分加载入内存可以带来如下优势：&lt;ul&gt;
&lt;li&gt;程序不再受物理内存空间限制，用户可以针对一个远超过物理内存大小的 &lt;strong&gt;虚拟地址空间（virtual address space）&lt;/strong&gt; 编写程序从而简化编程工作量；&lt;/li&gt;
&lt;li&gt;更多的程序可以同时执行（每个程序使用了更少的物理内存），CPU 利用率也随之增加（响应时间/周转时间不随之增加）；&lt;/li&gt;
&lt;li&gt;内存与备份存储之间换入换出的速度加快（程序实际占用物理内存变小）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程的虚拟地址空间即为进程在内存中存放的 &lt;strong&gt;逻辑&lt;/strong&gt; 视图，通常进程的的虚拟地址空间从某一个逻辑地址开始（比如 0）连续存放，如下图。随着动态内存分配，堆向上增长，子程序调用带来栈向下增长以及载入动态链接库时空白区域被填充。堆和栈之间的巨大的空白部分是虚拟地址的一部分，但只有在堆/栈生长时这部分虚拟地址才需要对应实际的物理帧。含有空白的虚拟地址空间称为 &lt;strong&gt;稀（sparse）&lt;/strong&gt; 地址空间。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/virtual-address-space.png&quot; width=&quot;150px&quot;&gt;&lt;/li&gt;
&lt;li&gt;虚拟内存允许文件和内存通过共享页被多个进程共享，优势在于：&lt;ul&gt;
&lt;li&gt;系统库可被多个进程共享&lt;/li&gt;
&lt;li&gt;多个进程之间可以通过共享内存通信&lt;/li&gt;
&lt;li&gt;允许系统调用 &lt;code&gt;fork()&lt;/code&gt; 创建进程之间的共享页从而加快进程创建。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;按需调页（Demand-Paging）&quot;&gt;&lt;a href=&quot;#按需调页（Demand-Paging）&quot; class=&quot;headerlink&quot; title=&quot;按需调页（Demand Paging）&quot;&gt;&lt;/a&gt;按需调页（Demand Paging）&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当且仅当需要某页时才将该页调入内存的技术称为 &lt;strong&gt;按需调页（demand paging）&lt;/strong&gt; ，被虚拟内存系统采用。按需调页系统类似于使用交换的分页系统，进程驻留在二级存储器上（磁盘），进程执行时使用 &lt;strong&gt;懒惰交换（lazy swapper）&lt;/strong&gt; 换入内存。因为这种方式将进程视作一系列页而非巨大的连续空间，而 &lt;em&gt;交换程序（swapper）&lt;/em&gt; 是对整个进程进行操作，因此使用 &lt;strong&gt;调页程序（pager）&lt;/strong&gt; 对进程的单个页代替交换程序。&lt;/li&gt;
&lt;li&gt;需要一定形式的硬件区分哪些页在内存中，第八章中的有效/无效位可用于此目的，当该位设为有效时表示对应的页既合法又在内存中，而该位设置为无效时表示相关的页无效（不属于进程的逻辑地址空间）或有效但尚未调入内存。对于尚未调入内存的页，其页表条目设置为无效或者包含了该页在磁盘上的地址。&lt;/li&gt;
&lt;li&gt;进程试图访问尚未调入内存中的页会触发 &lt;strong&gt;页错误陷阱（page-fault trap）&lt;/strong&gt; ，操作系统会按如下流程 &lt;strong&gt;处理页错误&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;检查进程的内部页表（进程维护的内部页表和 PCB 一起保存）来确定该引用是否为合法地址，若引用非法则终止进程，否则准备调入页面；&lt;/li&gt;
&lt;li&gt;操作系统寻找一个空闲帧（如从空闲帧链表中选择一个元素）；&lt;/li&gt;
&lt;li&gt;操作系统调度磁盘，将需要的页调入到上一步分配的空闲帧；&lt;/li&gt;
&lt;li&gt;磁盘读操作完成后修改进程的内部页表和操作系统维护的页表以表示该页已经位于内存中；&lt;/li&gt;
&lt;li&gt;重新读取因为页错误而终端的指令，进程可以访问此前无法访问的页。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上述按需调页的一种极端情况是在不调入任何需要页的情况下就执行进程，因此进程执行过程中将不断出现页错误、调入页、继续执行。这种方案称为 &lt;strong&gt;纯粹按需调页（pure demand paging）&lt;/strong&gt; 。按需调页处理页错误的流程如下图所示。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/page-fault-steps.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;理论上单个指令可能触发多个页错误（例如一页用于获取指令，一页用于获取指令所需的数据），但此种情况较少见，正常执行程序满足 &lt;strong&gt;局部引用（locality of reference）&lt;/strong&gt; 特性，使按需调页的性能较好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;按需调页与分页&quot;&gt;&lt;a href=&quot;#按需调页与分页&quot; class=&quot;headerlink&quot; title=&quot;按需调页与分页&quot;&gt;&lt;/a&gt;按需调页与分页&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按需调页所需的硬件支持和分页、交换相同：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;页表&lt;/strong&gt; ：通过有效/无效位保护进程地址空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;次级存储器&lt;/strong&gt; ：备份存储，保存不在内存中的页，通常为快速磁盘，用于和内存交换页的部分空间称为 &lt;strong&gt;交换空间（swap space）&lt;/strong&gt; 。Linux 系统所需的 &lt;code&gt;/swap&lt;/code&gt; 挂载点挂载的存储空间即为交换空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟技术的困难在于，分页是加在 CPU 和内存之间的，并且要对用户进程完全透明。人们通常假定分页能够应用到任何系统中，这个假定对于非按需调页的环境而言是正确的（缺页即为访问无效内存，产生致命错误），而在按需调页系统中，页错误意味着可能缺页、需要调入一个额外的页。 &lt;strong&gt;调入额外的页的过程很可能导致原始的指令在调页完成后重新执行不再正确&lt;/strong&gt; 。考虑下面的情况：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MVC&lt;/code&gt; 指令可以将 256B 的块从一处移动到另一处（可能重叠），如果源块或者目的块中任何一块跨越了页边界，则移动操作执行（在执行前并没有意识到源块/目标块缺页）到一半可能会出现页错误；&lt;/li&gt;
&lt;li&gt;在上述情况（跨页）的基础上，如果源块和目的块有重叠（overlap），则移动执行到一半时，源块可能已经被修改，这时调页进入内存后，不能简单地重启该指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上述两类情况有两种不同解决方案：&lt;ul&gt;
&lt;li&gt;微码计算并试图访问两块的两端，如果出现了页错误，则在指令 &lt;code&gt;MVC&lt;/code&gt; 执行前将缺页调入内存；&lt;/li&gt;
&lt;li&gt;使用临时寄存器保存 &lt;code&gt;MVC&lt;/code&gt; 指令从执行到触发缺页之间被覆盖了的数据，如果发生了页错误，则临时寄存器中保存的值在处理页错误之前写回到内存，此时调页完成后指令可以重启，状态与之前相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;性能&quot;&gt;&lt;a href=&quot;#性能&quot; class=&quot;headerlink&quot; title=&quot;性能&quot;&gt;&lt;/a&gt;性能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按需调页内存的 &lt;strong&gt;有效访问时间（effective access time）&lt;/strong&gt; 计算为： &lt;code&gt;有效访问时间 = (1-p) x ma + p x 页错误时间)&lt;/code&gt;。其中 &lt;code&gt;ma&lt;/code&gt; 为计算机系统的内存访问时间，通常为 10 ~200ns； &lt;code&gt;p&lt;/code&gt; 为出现页错误的概率，&lt;code&gt;p&lt;/code&gt; 越接近于 0 则页错误发生越少。&lt;/li&gt;
&lt;li&gt;进程 P 触发了页错误会导致下列动作：&lt;ol&gt;
&lt;li&gt;触发硬件陷阱，操作系统中断进程 P&lt;/li&gt;
&lt;li&gt;操作系统保存用户进程 P 的寄存器、进程状态&lt;/li&gt;
&lt;li&gt;确定中断是否为页错误，若是则判断页引用是否合法，若合法则确定页所在磁盘位置&lt;/li&gt;
&lt;li&gt;从磁盘读入页到某个空闲帧，这一步又包括：在该磁盘队列中等待直到处理完排在自己之前的请求，磁盘寻道/延迟以及磁盘传输的时间&lt;/li&gt;
&lt;li&gt;磁盘等待过程中将 CPU 分配给其他进程 Q（CPU 调度）&lt;/li&gt;
&lt;li&gt;从 I/O 子系统接收到中断&lt;/li&gt;
&lt;li&gt;保存 Q 的寄存器和进程状态（如果执行了第 5 步）&lt;/li&gt;
&lt;li&gt;确定中断是否来自于之前页错误触发的磁盘请求，若是则修正页表和其他表以更新页信息&lt;/li&gt;
&lt;li&gt;等待 CPU 调度程序将 CPU 资源再次分配给进程 P&lt;/li&gt;
&lt;li&gt;恢复进程 P 的用户寄存器、进程状态和新页表，重新执行被中断的指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;以上步骤不是全部必需的，例如第 5 步可以提高 CPU 使用率，但执行完 I/O 后也需要额外的时间保存现场。无论如何， &lt;strong&gt;缺页导致的页错误处理时间主要包括：处理页错误中断、读入页以及重新启动进程&lt;/strong&gt; 三部分，其中读入页除了磁盘设备本身的处理时间，还可能包括等待设备的时间。&lt;/li&gt;
&lt;li&gt;交换空间的处理和使用对按需调页的性能也有很大影响，磁盘 I/O 操作到交换空间比到文件系统要快，因为 &lt;strong&gt;交换空间按照大块来分配&lt;/strong&gt; 。如果在进程开始时将整个文件镜像复制到交换空间，并从交换空间执行按页调度则可能获得更好的调页效果。另一种方式是进程执行开始时从文件系统按需调页，但当出现页置换时则将页写入交换空间，这样只有所需的页才会从文件系统调用，而一旦调用某页，此后的该页再次调度时会从交换空间读入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;写时复制和页面置换&quot;&gt;&lt;a href=&quot;#写时复制和页面置换&quot; class=&quot;headerlink&quot; title=&quot;写时复制和页面置换&quot;&gt;&lt;/a&gt;写时复制和页面置换&lt;/h1&gt;&lt;h2 id=&quot;写时复制&quot;&gt;&lt;a href=&quot;#写时复制&quot; class=&quot;headerlink&quot; title=&quot;写时复制&quot;&gt;&lt;/a&gt;写时复制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;系统调用 &lt;code&gt;fork()&lt;/code&gt; 是将子进程创建为父进程的副本，传统的 &lt;code&gt;fork()&lt;/code&gt; 会为子进程创建一个父进程地址空间的副本，将父进程的页复制，但由于很多子进程创建之后立刻执行系统调用 &lt;code&gt;exec()&lt;/code&gt;，因此复制父进程地址空间完全没有必要。 &lt;strong&gt;写时复制（copy-on-write）&lt;/strong&gt; 技术允许父进程和子进程开始时共享同一页面，这些页面标记为写时复制页，如果任何一个进程对某一个写时复制页进行了写操作，则为这个进程创建一个该页的副本。注意， &lt;strong&gt;只有可能被修改的页才会被标记为写时复制&lt;/strong&gt; ，对于不允许被修改的页面（如包含可执行代码的页）可以被父进程和子进程共享。&lt;/li&gt;
&lt;li&gt;许多操作系统为分配空闲页请求提供了空闲缓冲 &lt;strong&gt;池（pool）&lt;/strong&gt; ，池中的空闲页在进程的栈/堆需要扩展时可用于分配，或者用于管理写时复制页。操作系统通常使用 &lt;strong&gt;按需填零（zero-fill-on-demand）&lt;/strong&gt; 技术分配这些页，这些页在分配之前被填入 0 覆盖，因此清除了之前的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟内存 fork&lt;/strong&gt; 是有的 UNIX 版本提供的 &lt;code&gt;fork()&lt;/code&gt; 操作变种，&lt;code&gt;vfork()&lt;/code&gt; 将父进程挂起，自己成使用父进程的地址空间，并且不采用写时复制。因此子进程对父进程地址空间的任何修改都会在父进程重启时可见。&lt;code&gt;vfork()&lt;/code&gt; 主要用于子进程创建后立刻调用 &lt;code&gt;exec()&lt;/code&gt; 的情况，它不会导致页面的复制操作，有时用来 &lt;strong&gt;实现 shell 接口&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;页面置换概念&quot;&gt;&lt;a href=&quot;#页面置换概念&quot; class=&quot;headerlink&quot; title=&quot;页面置换概念&quot;&gt;&lt;/a&gt;页面置换概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;增加多道程序的程度会导致内存的 &lt;strong&gt;过度分配（over-allocating)&lt;/strong&gt; 。I/O 缓存也需要使用大量内存，缓存的使用会增加内存分配算法的压力，有的操作系统为 I/O 缓存分配了一定比例的内存，有的则允许用户进程和 I/O 子系统竞争全部系统内存。&lt;/li&gt;
&lt;li&gt;内存的过度分配会导致某个进程触发了页错误而没有空闲帧可用，因为按需调页对用户而言透明，因此操作系统不应当直接终止进程（操作系统也可以交换出一个进程来降低多道程序的级别，这种选择有时是好的）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页置换（page replacement）&lt;/strong&gt; 发生在需要调页而没有空闲帧的情况，流程如下：&lt;ul&gt;
&lt;li&gt;查找所需页在磁盘上的位置&lt;/li&gt;
&lt;li&gt;查找空闲帧，若有则使用，否则通过页置换算法选择一个 &lt;strong&gt;牺牲（victim）&lt;/strong&gt; 帧并将牺牲帧的内容写入备份存储（磁盘，交换空间），改变页表和帧表&lt;/li&gt;
&lt;li&gt;将所需页写入到空闲帧，并改变页表和帧表&lt;/li&gt;
&lt;li&gt;重启用户进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以看出，在没有帧空闲，需要页置换的情况下，会有两个页传输（一页换出，一页换入），这加倍了页错误处理时间。这一点可以通过在页表的每个条目中增加 &lt;strong&gt;修改位（modify bit）&lt;/strong&gt; 或 &lt;strong&gt;脏位（dirty bit）&lt;/strong&gt; 来降低额外开销，如果被置换出的页对应的修改位没有被设置，则说明此页从被调入内存后没有被修改，因此不必被写入回磁盘。&lt;/li&gt;
&lt;li&gt;按需调页需要开发 &lt;strong&gt;帧分配算法（frame-allocation algorithm）&lt;/strong&gt; 和 &lt;strong&gt;页置换算法（page-replacement algorithm）&lt;/strong&gt; 。页置换算法的好坏可以计算页错误率评估：对于一个特定的内存地址引用序列，运行置换算法，计算出页错误的数量。这个引用序列称为 &lt;strong&gt;引用串（reference string）&lt;/strong&gt; ，可以人工产生也可以跟踪一个真实的系统并记录其访问内存地址。利用两个事实可以降低引用串的数据量：只考虑内存引用的页码而不考虑完整地址；如果有对页 p 的引用，则紧跟着对页 p 的引用绝不会产生页错误。&lt;/li&gt;
&lt;li&gt;理论上来说，我们期待增加可用帧（增加物理内存大小就会增加可用帧数量）的数量能够使页错误的数量相对应减少。 &lt;strong&gt;Belady 异常（Belady’s anomaly）&lt;/strong&gt; 指违背这一期待的现象：对于有的页置换算法，页错误率甚至可能随着分配的物理帧数增加而增加，例如下面的 FIFO 算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;页面置换算法&quot;&gt;&lt;a href=&quot;#页面置换算法&quot; class=&quot;headerlink&quot; title=&quot;页面置换算法&quot;&gt;&lt;/a&gt;页面置换算法&lt;/h2&gt;&lt;h3 id=&quot;基本页置换算法&quot;&gt;&lt;a href=&quot;#基本页置换算法&quot; class=&quot;headerlink&quot; title=&quot;基本页置换算法&quot;&gt;&lt;/a&gt;基本页置换算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FIFO页置换&lt;/strong&gt; ：最简单的页置换算法，操作系统记录每个页被调入内存的时间，当必需置换掉某页时，选择最旧的页换出。实际操作中不需要真的记录调入时间，可以通过一个 FIFO 队列管理内存中的页，置换算法从队列的头部取出换出的页，将换入的页加入到队列尾部。FIFO 页置换算法的性能并不总是很好，它置换出的页可能是一个很久以前现在已经不再使用的页（符合我们的期望），也可能是一个进程创建时初始化的变量，而这个变量仍然在不停地被使用，此时被调出的这页很快就会再次导致页错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最优置换（optimal page-replacement）&lt;/strong&gt; 是所有页置换算法中页错误率最低的，但它需要引用串的先验知识，因此无法被实现。它会将内存中的页 P 置换掉，页 P 满足：从现在开始到未来某刻再次需要页 P，这段时间最长。也就是 OPT 算法会 &lt;strong&gt;置换掉未来最久不被使用的页&lt;/strong&gt; 。OPT 算法通常用于比较研究，衡量其他页置换算法的效果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最近最少使用算法（least-recently-used algorithm）&lt;/strong&gt; 简称 LRU，它置换掉到目前时刻最久未被使用的页。这一算法可以视作 OPT 的倒转，LRU 和 OPT 算法都属于 &lt;strong&gt;栈算法（stack algorithm）&lt;/strong&gt; ，它们绝不会产生 Bleady 异常。一个有意思的地方在于，对于引用串 S，LRU 算法计算 S 和 &lt;code&gt;S^R&lt;/code&gt; 的错误率时相同的（&lt;code&gt;S^R&lt;/code&gt; 是引用串 S 的逆序），这一特性对 OPT 算法也满足。LRU 策略可能需要一定的硬件支持，因为它需要为页帧按上次使用时间确定一个排序序列。两种实现方式：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;计数器（counters）&lt;/strong&gt; ：每个页表的条目关联一个时间域，CPU 增加一个计数器，每次内存引用发生时，计数器增加，并且将引用的页在页表中对应的条目的时间域更新为计数器的内容。这样 LRU 需要搜索页表置换具有最小时间域的页。这种方式每次内存访问都要写入内存，页表改变（因为 CPU 调度）的时候还需要保持时间，还需要考虑时钟溢出问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈（stack）&lt;/strong&gt; ：采用页码栈维护，每当引用了一个页就将该页从栈中删除并放置到顶部，这样栈顶总是最近使用的页，栈底则为 LRU 需要替换的页。因为要从栈中删除某项，所以可实现为带有头指针和尾指针的双向链表，从栈中删除一页并放置到栈顶最坏情况下需要修改 6 个指针，但这种实现方式不需要搜索整个表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;近似-LRU-页置换算法&quot;&gt;&lt;a href=&quot;#近似-LRU-页置换算法&quot; class=&quot;headerlink&quot; title=&quot;近似 LRU 页置换算法&quot;&gt;&lt;/a&gt;近似 LRU 页置换算法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;近似 LRU 页置换算法（LRU-Approximation Page Replacement）&lt;/strong&gt; ：很少有系统能够提供足够的硬件支持真正的标准 LRU 页置换，通常通过引用位的方式提供支持实现近似的 LRU 算法。页表的每一个条目都关联着一个 &lt;strong&gt;引用位（reference bit）&lt;/strong&gt; ，每当引用了一个页（无论读写），都将该页在页表中对应条目的引用位置位，检查引用位就可以确定哪些页使用过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;附加引用位（Additional-Reference-Bits）&lt;/strong&gt; 算法：位于内存中的每页对应的条目保留一个字节（8位），这个字节的 8 位说明了这一页在过去 8 个时间周期内的使用情况。每过一段规定的时间间隔（如 100 ms），时钟定时器产生中断并将控制转交给操作系统，操作系统将页表每个条目的引用位右移，最低位舍弃，最高位设置为引用位，并将引用位清零。具有最小值的页即为 LRU 替换的页。这里历史位共 8 位，长度可以调整，极端情况下可以为 0 位（此时仅剩下引用位本身）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二次机会（Second-Chance）&lt;/strong&gt; 算法：该算法基本算法是 FIFO 置换。每当准备置换出一页时检查其引用位，如果引用位为 0 则直接置换该页，否则将引用位清零并给该页第二次机会，之后准备换出下一个 FIFO 页。如果一个页总是被使用，则其引用位经常被设置，所以不会被置换出内存。这种算法的实现采用循环队列，用一个指针表示下次置换队列中的哪一页，找到牺牲页时就将新页插入到牺牲页的位置。最坏情况下所有页都已经被设置，此时需要遍历整个循环队列，性质等价于 FIFO 置换，而所需时间比 FIFO 更长。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增强型二次机会（Enhanced Second-Chance）&lt;/strong&gt; 算法：将引用位和修改位作为一对考虑以改进二次机会算法，这两个位可能有四种类型：&lt;code&gt;(0, 0)&lt;/code&gt; 表示最近没有使用也没有修改（最佳置换页）；&lt;code&gt;(0, 1)&lt;/code&gt; 表示最近没有使用但已修改（若置换则需要写入到磁盘）；&lt;code&gt;(1, 0)&lt;/code&gt; 表示最近使用但尚未修改（此页可能很快会被使用）；&lt;code&gt;(1, 1)&lt;/code&gt; 表示最近使用且已经被修改（此页可能很快会被使用并且如果置换需要写入磁盘）。这种方法给已经修改过的页更高的级别，降低了 I/O 操作数量。但找到要置换的页之前，可能需要搜索循环队列多次，每次将级别升高一级并寻找满足的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基于计数的页置换算法&quot;&gt;&lt;a href=&quot;#基于计数的页置换算法&quot; class=&quot;headerlink&quot; title=&quot;基于计数的页置换算法&quot;&gt;&lt;/a&gt;基于计数的页置换算法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;基于计数（Counting-Based）&lt;/strong&gt; 的页置换通过为每页的条目保留一个引用次数的计数器来选择换出页，包括 LFU 和 MFU，这两种置换方式都很费时并且效果很差：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最不经常使用（least frequently used，LFU）&lt;/strong&gt; 页置换算法：置换计数最小的页，理由是活动页通常有更大的引用次数。但带来问题是一个被使用多次的页可能已经很久不在使用，但仍然保留在内存中。一种解决方式是定期将次数寄存器右移一位来使使用次数指数衰减。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最常使用页（most frequently used，MFU）&lt;/strong&gt; 置换算法：置换计数最大的页，理由是最小次数的页可能刚刚被调入且尚未使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;页缓冲算法&quot;&gt;&lt;a href=&quot;#页缓冲算法&quot; class=&quot;headerlink&quot; title=&quot;页缓冲算法&quot;&gt;&lt;/a&gt;页缓冲算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;系统保留一个空闲帧缓冲池，出现页错误时仍然选择一个牺牲帧，但牺牲帧写出前就将所需要的页写入到缓冲池的某一个空闲帧中，写入完成的空闲帧就可以直接被使用，这样无需等待牺牲帧的写出。牺牲帧写出到交换空间后，又会被添加到空闲帧缓冲池中。&lt;/li&gt;
&lt;li&gt;此种方式的扩展之一是维护一个已经修改过的页面列表，当调页设备空闲时，就将一个修改过的页面写回到磁盘并重新设置其修改位，这样在真正需要置换时，牺牲页需要写入到磁盘的概率会降低。&lt;/li&gt;
&lt;li&gt;另一种修改是保留一个空闲帧池（需要记录哪些页对应哪些帧），当页错误发生时先检查所需页是否在空闲帧池中，若在则无需 I/O，若不在则选择一个空闲帧并从硬盘读入所需页。这种技术通常和 FIFO 算法一起用于 VAX/VMX 系统，当 FIFO 错误置换了常用页时，被换出的页仍能够很快从空闲帧池中调出。很多 UNIX 系统也将这种方法和二次机会算法一起使用，降低因错误选择牺牲页引起的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;针对应用程序选择页置换&quot;&gt;&lt;a href=&quot;#针对应用程序选择页置换&quot; class=&quot;headerlink&quot; title=&quot;针对应用程序选择页置换&quot;&gt;&lt;/a&gt;针对应用程序选择页置换&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有些情况下操作系统提供的虚拟内存会让部分应用程序性能下降。例如数据库提供了自己的内存管理和 I/O 缓冲，若操作系统同时也提供了 I/O 缓冲，则用于 I/O 的资源加倍。此外，对于一个执行大量顺序磁盘读操作的行为，LRU 算法删除旧页保持新页，而应用程序可能更需要旧页，此时 MFU 比 LRU 更高效。&lt;/li&gt;
&lt;li&gt;有些操作系统允许特殊程序绕过文件系统的数据结构，将磁盘视作逻辑块数组使用。这种数组称为 &lt;strong&gt;生磁盘（raw disk）&lt;/strong&gt; ，针对这样的数组的 I/O 称为生 I/O。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;缺段中断和处理（补充）&quot;&gt;&lt;a href=&quot;#缺段中断和处理（补充）&quot; class=&quot;headerlink&quot; title=&quot;缺段中断和处理（补充）&quot;&gt;&lt;/a&gt;缺段中断和处理（补充）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用分段内存管理时，CPU 要访问的指令/数据不在内存中会产生 &lt;strong&gt;缺段中断&lt;/strong&gt; ，操作系统会通过如下流程处理缺少段 X 的事件：&lt;ol&gt;
&lt;li&gt;考察内存中是否存在不小于 X 段长的空闲区，若存在则从该空闲区中为段 X 分配内存，转 4；&lt;/li&gt;
&lt;li&gt;若不存在，则考察内存中所有空闲区的总和是否小于 X 的段长，若总和大于 X 的段长则合并空闲区形成一个足够大的空闲区，并使用新空闲区为 X 分配内存，转 4；&lt;/li&gt;
&lt;li&gt;若空闲区总和仍小于 X 的段长，则按 FIFO 或 LRU 算法反复淘汰老段，形成一个长度不小于 X 段长的空闲区；&lt;/li&gt;
&lt;li&gt;将 X 段调入内存并修改段表&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;帧分配与系统颠簸&quot;&gt;&lt;a href=&quot;#帧分配与系统颠簸&quot; class=&quot;headerlink&quot; title=&quot;帧分配与系统颠簸&quot;&gt;&lt;/a&gt;帧分配与系统颠簸&lt;/h1&gt;&lt;h2 id=&quot;最少需要帧数&quot;&gt;&lt;a href=&quot;#最少需要帧数&quot; class=&quot;headerlink&quot; title=&quot;最少需要帧数&quot;&gt;&lt;/a&gt;最少需要帧数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分配的帧不能超过可用帧的数量（除非存在页共享），但也不能少于满足进程继续运行的帧数（minimum number of frames）。分配帧数不能过少的原因包括：&lt;ul&gt;
&lt;li&gt;性能：当分配给每个进程的帧数量减少时，页错误会增加从而减缓进程执行。&lt;/li&gt;
&lt;li&gt;页错误会导致指令重启：必须由足够的帧来容纳单条指令执行所需要的全部页。例如某台机器的机器指令都只有一个内存地址作为参数，此时至少需要一帧用于存储指令所在的页空间，还需要分配一帧用于存储指令引用的数据所在的页。如果此时允许一级间接引用（地址间接引用），则进程至少需要三个帧才能完成指令的执行，如果仅两帧可用，则进程将陷入无穷尽的页错误中。这种问题的最坏情况出现在允许多层间接引用的计算机中，对于多级引用，必须等到所有所需页都位于内存中指令才能执行，这种困难的解决方案是限制指令的间接引用级数，超出引用级数时触发陷阱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分配算法&quot;&gt;&lt;a href=&quot;#分配算法&quot; class=&quot;headerlink&quot; title=&quot;分配算法&quot;&gt;&lt;/a&gt;分配算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;平均分配（equal allocation）&lt;/strong&gt; ：给每个进程一个平均值，剩余的帧放置在空闲帧缓冲池中； &lt;strong&gt;比例分配（proportional allocation）&lt;/strong&gt; ：根据进程大小按比例分配内存。这两种分配方式，每个进程分配的数量都会随多道程序的级别而变化，当多道程序程度增加时，每个进程都需要失去一定数量的帧来提供给新进程，同理，多道程序程度降低时离开进程占有的帧可以分配给剩余的进程。&lt;/li&gt;
&lt;li&gt;比例分配可以根据进程的优先级（或者是优先级和大小的结合）而不是进程的大小来分配，这样可以给高优先级的进程更多的内存以加速执行。&lt;/li&gt;
&lt;li&gt;多个进程竞争帧时，可将页置换算法分为 &lt;strong&gt;全局置换（global replacement）&lt;/strong&gt; 和 &lt;strong&gt;局部置换（local replacement）&lt;/strong&gt; 。全局置换允许进程从所有帧的集合（包括其他进程持有的帧）中选择置换帧，这将导致某个进程所获得的帧的数量可能改变（从其他进程处选择了一个帧置换）；而局部置换只能允许进程选择分配给自己的某个帧，此时分配给每个进程的帧数量保持不变。&lt;/li&gt;
&lt;li&gt;全局置换算法的一个问题在于进程不能控制自己的页错误率，进程位于内存的页集合会受到其他进程调页行为的影响。此外，相同进程执行所需的时间在不同环境下可能有很大差异。但由于局部置换不能使用其他进程不常用的内存，所以全局置换有更好的系统吞吐量，因此更为常用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;系统颠簸&quot;&gt;&lt;a href=&quot;#系统颠簸&quot; class=&quot;headerlink&quot; title=&quot;系统颠簸&quot;&gt;&lt;/a&gt;系统颠簸&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当低优先级进程分配的帧数量少于体系结构所需的最少数量时，进程应当暂停执行并且换出分配的剩余帧，以使其他进程能够使用这部分帧空间。&lt;/li&gt;
&lt;li&gt;对于分配帧数不足的进程，当进程缺少所需的页时触发页错误，此时必须置换某个页。如果当前所有页对于这个进程而言都是需要使用的页，则它置换出一个页后，又立刻需要这个页，因此它将频繁产生页错误并触发页调度行为。这称为 &lt;strong&gt;颠簸（thrashing）&lt;/strong&gt; ： &lt;strong&gt;如果一个进程在换页上用的时间多于执行时间，则这个进程在颠簸&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;系统颠簸的原因在于：操作系统监控 CPU 使用率，CPU 利用率过低时会引入新进程来增加多道程序程度。然而，采用全局置换算法时，一个进程会置换任意进程的帧，这可能导致被换出页所属的进程也触发页错误，它们会再从其他进程中获取帧。 &lt;strong&gt;这些链式反应带来的页调度行为将使进程排队等待换页设备，就绪队列变空，CPU 使用率降低，导致 CPU 调度程序随之增加多道程序程度，新进程将引发更多的页错误，CPU 使用率进一步降低&lt;/strong&gt; 。系统颠簸现象如下图。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/system-thrashing.png&quot; width=&quot;250px&quot;&gt;&lt;/li&gt;
&lt;li&gt;随着多道程序程度增加，CPU 使用率增加直到最大值，之后开始系统颠簸，此时必须降低多道程序程度才能增加 CPU 使用率并降低系统颠簸。 &lt;strong&gt;局部置换算法（local replacement algorithm）&lt;/strong&gt; ，也称 &lt;strong&gt;优先置换算法（priority replacement）&lt;/strong&gt; 可以限制系统颠簸：如果一个进程开始颠簸，则它不能从其它进程获得帧，但问题未得到彻底解决，一个进程颠簸时会花费大量时间等待调页设备，这将导致调页设备的平均等待队列变长，页错误的平均等待时间增加，此时其它未颠簸进程的有效访问时间也会增加。&lt;/li&gt;
&lt;li&gt;要 &lt;strong&gt;防止颠簸&lt;/strong&gt; ，必须给进程提供足够多的帧。 &lt;strong&gt;局部模型（locality model）&lt;/strong&gt; 可以帮助确定进程实际正在使用多少帧，该模型说明，进程执行时在局部之间移动。 &lt;strong&gt;局部是进程经常使用的页的集合，进程由多个不同局部组成且局部之间可能重叠&lt;/strong&gt; 。如果进程分配的帧数小于现有局部的大小，则进程会颠簸，因为它无法把所有常用页都放置在内存中。例如，进程调用了一个子程序，则其进入新的局部，这个新局部中的内存引用包括子程序的指令、局部变量以及子程序使用到的部分全局变量；当子程序退出时，进程从该局部返回主程序的局部（也可能在之后再次调用子程序进入该局部）。因此，局部是由程序和数据结构定义的，它是缓存的基础（cache、LRU 置换算法其实也都是基于局部性原理，在访问序列完全随机的情况下性能甚至不如 FIFO 算法），如果对任意数据访问完全随机而没有局部性原理，则缓存完全无用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;工作集合模型&quot;&gt;&lt;a href=&quot;#工作集合模型&quot; class=&quot;headerlink&quot; title=&quot;工作集合模型&quot;&gt;&lt;/a&gt;工作集合模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作集合模型（working-set model）&lt;/strong&gt; 基于局部性假设，使用参数 Δ 定义 &lt;strong&gt;工作集合窗口（working-set window）&lt;/strong&gt; ，其思想是检查最近 Δ 个页的引用，这最近 Δ 个引用页的集合称为工作集合。工作集合是程序局部的近似：一个正在使用的页位于工作集合中，一旦它已经 Δ 个时间单位未被使用，则会从工作集合中删除。&lt;/li&gt;
&lt;li&gt;工作集合的精确度和 Δ 有关，Δ 太小则无法包含整个局部，过大则可能包含多个局部。工作集合最重要的属性是它的大小，系统内每个进程的工作集合大小 &lt;code&gt;WSSi&lt;/code&gt; 之和 &lt;code&gt;D&lt;/code&gt; 就是所有进程总的帧需求量，每个进程都会经常使用位于其工作集合内的页。当 &lt;code&gt;D &amp;gt; m&lt;/code&gt; （&lt;code&gt;m&lt;/code&gt; 是系统最大可用帧数量）时，就会有进程得不到足够的帧从而出现颠簸。&lt;/li&gt;
&lt;li&gt;使用工作集合模型的内存分配过程如下：操作系统跟踪每个进程的工作集合，并给每个进程分配大于其工作集合大小的帧数。如果尚有空闲帧则可加入新进程；如果需要分配的帧数大于可用帧数，则操作系统选择、暂停一个进程，这个进程的所有页写出到备份存储，其已经占有的帧会被分配给其他进程。&lt;/li&gt;
&lt;li&gt;工作集合模型的难点在于 &lt;strong&gt;跟踪&lt;/strong&gt; ，每次内存引用都会增加新引用并丢弃老引用。 &lt;strong&gt;固定定时中断和引用位可以近似模拟工作集合模型&lt;/strong&gt; 。例如 &lt;code&gt;Δ = 10000&lt;/code&gt; 时，每 5000 个引用就产生一次定时中断，中断触发时将所有页的引用位复制，复制完成后清除。当发生页错误，系统检查当前的引用位和位于内存中的两个位（每次中断复制一位，10000 次引用中断 2 次因此复制了两个位）从而确定这一页是否在过去的 10000~15000 个引用中出现过（只要有至少一位为 1 就说明使用过，否则都为 0），若出现则认为该页在工作集合中。这种模拟并不很准确，因为无法准确获取该页究竟在 5000 个引用中的具体哪个位置出现，增加中断频率和历史位的位数可以提高准确性，但相应的也会增加中断处理时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;页错误频率&quot;&gt;&lt;a href=&quot;#页错误频率&quot; class=&quot;headerlink&quot; title=&quot;页错误频率&quot;&gt;&lt;/a&gt;页错误频率&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工作集合模型更适合用于预先调页，将其应用于控制颠簸有些不太灵活。 &lt;strong&gt;页错误频率（page-fault frequency，PFF）&lt;/strong&gt; 策略能够通过测量、控制页错误率来更好的防止颠簸：颠簸有较高的页错误率，较高的页错误率说明进程需要更多帧，过低的页错误率说明进程可能分配了太多的帧。可以为页错误率设置上限和下限，超过上限就为进程分配更多帧，低于下限则移走帧。当页错误率过高而没有可用帧时，仍需要暂停一个进程并将其占有的帧释放、分配给具有过高页错误率的进程。&lt;/li&gt;
&lt;li&gt;进程的工作集合和页错误率之间有直接关系，当进程从一个局部迁移到另一个局部时，工作集合改变，页错误率会进入波峰，随着需要调入的页逐步调入内存，页错误率又会下降。一个波峰的开始到下一个波峰的开始显示了工作集合的迁移。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;其它&quot;&gt;&lt;a href=&quot;#其它&quot; class=&quot;headerlink&quot; title=&quot;其它&quot;&gt;&lt;/a&gt;其它&lt;/h1&gt;&lt;h2 id=&quot;内存映射文件&quot;&gt;&lt;a href=&quot;#内存映射文件&quot; class=&quot;headerlink&quot; title=&quot;内存映射文件&quot;&gt;&lt;/a&gt;内存映射文件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通过虚拟内存技术将文件 I/O 作为普通内存访问的方法称为文件的 &lt;strong&gt;内存映射（memory mapping）&lt;/strong&gt; 。文件的内存映射将一个磁盘块映射成内存的一页（或多页），开始时文件访问和普通的请求界面调度相同，并且产生页错误，这样一页大小的部分文件就会从文件系统读入到物理内存中（部分系统一次会读入多页大小内容）。通过内存操作文件而不是系统调用 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 能够简化文件访问和使用。&lt;/li&gt;
&lt;li&gt;对映射到内存中的文件做写操作可能不会立刻写回到磁盘文件中。有的操作系统定期检查文件在内存中的映射是否被修改，并据此决定是否需要将内存的数据更新到磁盘上。关闭文件必然会导致内存映射的数据写回磁盘，同时从进程的虚拟内存中删除。&lt;/li&gt;
&lt;li&gt;部分操作系统只能通过特定的系统调用提供内存映射，通过标准的系统调用处理所有其它的文件 I/O 请求；有的操作系统则一律将文件 I/O 视作内存映射，例如 Solaris 系统会将标明为内存映射的文件映射到进程的地址空间中，而对于采用普通系统调用（&lt;code&gt;read&lt;/code&gt;、&lt;code&gt;open&lt;/code&gt; 以及 &lt;code&gt;write&lt;/code&gt;）访问的文件，Solaris 也会做内存映射，不过目标是内核地址空间。&lt;/li&gt;
&lt;li&gt;一个文件可以同时映射到多个进程的虚拟地址空间中以实现 &lt;strong&gt;数据共享&lt;/strong&gt; ：任何一个进程对共享虚拟内存中数据的修改都会被那些同样映射了这部分文件的进程看见（注意这里是为了实现数据共享，因此才允许多个进程修改同一页）。每个共享进程的虚拟内存表指向了物理内存的同一页。内存映射也支持写时复制，进程可以共享只读模式的文件，对于需要改动的数据，进程需要维护各自独立的副本。&lt;/li&gt;
&lt;li&gt;其他设备的 I/O 操作也可以通过内存映射的方式：操作系统将一组内存地址专门映射到设备寄存器，对这些内存地址的读写等同于对设备寄存器的读写，即 I/O 端口。CPU 和设备之间传递数据可以通过轮询或中断。轮询方式指 CPU 不断查询控制位判断接收设备是否准备就绪；中断驱动则由接收设备通知 CPU 数据已经就绪。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;内核内存分配&quot;&gt;&lt;a href=&quot;#内核内存分配&quot; class=&quot;headerlink&quot; title=&quot;内核内存分配&quot;&gt;&lt;/a&gt;内核内存分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普通用户进程获取额外内存时是从内核维护的空闲页帧链表中获取，该链表由页替换算法更新，这些页帧往往分散在物理内存中。&lt;/li&gt;
&lt;li&gt;内核内存的分配通常从空闲内存池获取而非从普通用户进程的内存链表获取，原因：&lt;ul&gt;
&lt;li&gt;内核要为不同大小的数据结构分配内存，有些数据结构远不到一页的大小。很多操作系统的内核代码并不受分页系统控制，内核可以也必须谨慎分配内存并尽量降低碎片浪费。&lt;/li&gt;
&lt;li&gt;用户进程分配的页不一定非要在连续的物理内存中，但操作系统需要和硬件交流，需要内存常驻在连续的物理内存帧中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Buddy 系统（Buddy system）&lt;/strong&gt; 将物理上连续并且大小固定的段划分成 2 的幂（4KB、8KB、16KB等），如果请求大小不为 2 的幂，实际分配的内存大小也会是 2 的幂。例如请求 11KB 将会得到 16KB。Buddy 系统的分配通过不断切割实现，例如内存段大小 256 KB，申请 21 KB，则将内存段不断划分成两半，最终得到一个 32KB 的小段满足 21KB 请求。其优缺点如下：&lt;ul&gt;
&lt;li&gt;优点：可通过合并快速形成更大的段，例如上面分配的 32KB 内存释放后可以立刻得到原始的 256KB 段&lt;/li&gt;
&lt;li&gt;缺点：碎片，可能有 50% 的内存因为碎片而浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slab 分配&lt;/strong&gt; ：slab 由一个或多个 &lt;strong&gt;物理上&lt;/strong&gt; 连续的页组成，高速缓存 &lt;strong&gt;含有&lt;/strong&gt; 一个或多个 slab。每个内核数据结构都有一个 cache （如进程描述符 cache 只存储进程描述符对象、文件对象和信号量等以此类推），每个 cache &lt;strong&gt;包含&lt;/strong&gt; 内核数据结构的 &lt;strong&gt;对象实例&lt;/strong&gt; 。 slab 算法用 cache 存储内核对象，cache 创建之初会初始化一系列空闲的内核对象，这些对象的数量和 slab 的大小有关（例如 12KB 的 slab 可存储 4 个 3KB 大小的内核对象）。一旦操作系统需要内核结构的对象，就可以直接从 cache 上获取一个空闲的并将其标注为 &lt;strong&gt;已使用（used）&lt;/strong&gt; 。下面这张图需要注意的地方有，物理内存连续分配，实线（带箭头）表示包含关系，每个 cache 都存储了一类内核数据结构对象：&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/cache-slab-objects.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;Linux 下的 slab 有三种状态：满的（slab 中所有对象都标记为使用），空的（均为空闲）以及部分。slab 分配的分配流程如下：首先从部分空闲的 slab 分配，若没有则从空的 slab 分配，如果仍没有则从 &lt;strong&gt;物理连续页&lt;/strong&gt; 上分配新的 slab 并将其交付给一个 cache，并从新 slab 分配空间。其优点主要有：&lt;ul&gt;
&lt;li&gt;没有因为碎片引起的内存浪费。每个内核数据结构都有与自己的结构相对应的 cache，而每个 cache 由若干个 slab 组成， &lt;strong&gt;每个 slab 又可分为若干个和对象大小相等的部分&lt;/strong&gt; ，所以内核请求对象所获得的内存刚好和对象大小一致；&lt;/li&gt;
&lt;li&gt;slab 中的对象预先创建，可以直接从 cache 快速分配。因为操作系统经常分配、释放内存，使用 slab 分配能够更快地使内存请求得到响应，用完对象释放时也只需要将内核对象标记为空闲并返回给  cache。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;更多方面的考虑&quot;&gt;&lt;a href=&quot;#更多方面的考虑&quot; class=&quot;headerlink&quot; title=&quot;更多方面的考虑&quot;&gt;&lt;/a&gt;更多方面的考虑&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;预调页（prepaging）&lt;/strong&gt; ：当进程开始时，所有页都在磁盘上，每个页都需要通过页错误来调入内存。预调页同时将所需要的所有页一起调入内存，从而阻止了大量的页错误。部分操作系统如 Solaris 对小文件就采取预调页调度。实际应用中，例如对于采用工作集合模型的系统，可以为每个进程维护一个当前工作集合中的页的列表，如果进程在暂停之后需要重启时，根据这个列表使用预调页将所有工作集合中的页一次性调入内存。预调页有时效果比较好，但成本不一定小于不使用预调页时发生页错误的成本，有很多预调页调入内存的页可能没有被使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页大小（page size）&lt;/strong&gt; ：许多因素会影响页面大小，不存在单一的最佳页大小。页面大小总为 2 的幂，通常在 &lt;code&gt;2^12&lt;/code&gt; 到 &lt;code&gt;2^22&lt;/code&gt; 字节之间（4KB ~ 4MB）。页面大小的考虑主要涉及如下几点，现代操作系统倾向于使用更大的页面：&lt;ul&gt;
&lt;li&gt;更大的页面大小能够减少页数量，从而减小页表大小；&lt;/li&gt;
&lt;li&gt;更小的页面大小能够更好的利用内存，减少碎片；&lt;/li&gt;
&lt;li&gt;页读写所需要的时间：传输时间和传输量（页大小）成正比，看起来似乎小页面更好，但实际上磁盘的寻道、延迟时间远超过传输时间，因此为了最小化 I/O 时间，需要采用较大的页；&lt;/li&gt;
&lt;li&gt;局部性：采用较小的页能够更精准的定位程序局部，从而降低总的 I/O 量；&lt;/li&gt;
&lt;li&gt;页错误数量：页面大小过小时，页错误会触发的更加频繁，页错误会带来大量的额外开销（处理中断、保存寄存器、置换页、排队等待调页设备、更新表），为了减少页错误数量，需要较大的页。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TLB 范围（reach）&lt;/strong&gt; ：指通过 TLB 可访问的内存量，即 TLB 能够存储的条数和页面大小的乘积。理想情况下一个进程的全部工作集合都位于 TLB 中才能够减少地址转换、查页表浪费的时间，但是对于需要使用大量内存的应用程序，TLB 大小不足以存储全部局部。增加 TLB 范围可以通过增加 TLB 条数，也可以通过增加页面大小。增加页大小会带来更大的碎片，另一种选择是使用不同大小的页（如 UltraSPARC 支持 8、64、512KB 和 4MB 的不同大小的页面），对于绝大多数程序而言 8KB 的页足够，部分其它应用程序如数据库可以利用 4MB 大小的页。注意，现代操作系统趋势是不同大小的页由操作系统而不是硬件来管理，软件管理必然也会影响性能（PowerPC 和 Pentium 用硬件管理 TLB）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序结构&lt;/strong&gt; ：用户应当对按需调页足够了解，以使程序结构更好的适应系统，例如一个页大小为 128B 的系统按行存储数组，则下面的两类代码中，上面的代码会触发 &lt;code&gt;128 x 128 = 16384&lt;/code&gt; 次页错误，而下面的代码只会触发 128 次。程序设计语言的特性对调页也会有影响，例如 C 和 C++ 经常使用指针，指针趋向于使内存访问随机，从而导致进程的局部性变差。此外， &lt;strong&gt;OOP 思想设计的程序引用的局部性也较差&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; data[&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        data[j][i] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 每个字节都会触发一次，共 16384 次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        data[i][j] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// 每行触发一次，共128 次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;实验&quot;&gt;&lt;a href=&quot;#实验&quot; class=&quot;headerlink&quot; title=&quot;实验&quot;&gt;&lt;/a&gt;实验&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设计程序模拟 FIFO 和 LRU 页置换算法。我对此问题编写的代码可在 &lt;a href=&quot;https://github.com/Forec/course-design/tree/master/operating-system/%E6%8D%A2%E9%A1%B5%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;此处&lt;/a&gt; 获取，其中包括一个基类 &lt;code&gt;BASIC&lt;/code&gt; 和两个子类 &lt;code&gt;FIFO&lt;/code&gt;、&lt;code&gt;LRU&lt;/code&gt;。其它类型换页算法可以通过继承 &lt;code&gt;BASIC&lt;/code&gt; 并重写 &lt;code&gt;swapIn()&lt;/code&gt; 方法完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/03/os-concepts-8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（八）：内存管理&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/05/os-concepts-10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（十）：文件系统接口&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/04/os-concepts-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/04/os-concepts-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/04/os-concepts-9/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第九章虚拟内存部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（八）：内存管理</title>
    <link href="http://forec.github.io/2017/01/03/os-concepts-8/"/>
    <id>http://forec.github.io/2017/01/03/os-concepts-8/</id>
    <published>2017-01-03T02:27:12.000Z</published>
    <updated>2017-01-06T12:00:16.611Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第八章内存管理部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h2 id=&quot;基本硬件&quot;&gt;&lt;a href=&quot;#基本硬件&quot; class=&quot;headerlink&quot; title=&quot;基本硬件&quot;&gt;&lt;/a&gt;基本硬件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU 通常在一个 CPU 时钟周期内完成对内置寄存器的访问，对内存的访问需多个 CPU 时钟周期，在缺少数据来完成正在执行的指令时，CPU 需要 &lt;strong&gt;暂停（stall）&lt;/strong&gt; ，通常在 CPU 和内存之间添加高速缓存（cache）以协调速度差异。&lt;/li&gt;
&lt;li&gt;要确保操作系统不被用户进程访问、用户进程不被其他用户进程访问，需要每个进程拥有独立的地址空间。通过 &lt;strong&gt;基地址寄存器（base register）&lt;/strong&gt; 和 &lt;strong&gt;界限地址寄存器（limit register）&lt;/strong&gt; 可对进程内存加以保护，基地址寄存器存储进程可访问的最低合法 &lt;em&gt;物理&lt;/em&gt; 内存地址，界限地址寄存器决定从该地址开始的，可访问的内存范围大小。CPU 硬件对 &lt;strong&gt;用户模式&lt;/strong&gt; 下产生的 &lt;strong&gt;每一个&lt;/strong&gt; 地址和寄存器指明的地址区间比较，用户模式下的程序试图访问操作系统/其他用户进程内存的行为会触发陷阱（trap），操作系统会将其视为致命错误处理。&lt;/li&gt;
&lt;li&gt;基地址寄存器和界限地址寄存器能且仅能由操作系统的特权指令加载，因为仅有操作系统在内核模式下执行，故避免了用户程序修改这两个寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;地址绑定&quot;&gt;&lt;a href=&quot;#地址绑定&quot; class=&quot;headerlink&quot; title=&quot;地址绑定&quot;&gt;&lt;/a&gt;地址绑定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序执行前需将所需部分二进制数据调入内存并置于进程空间内，执行过程中根据操作系统采用的内存管理方案可能还会有内存/硬盘之间的换入换出移动。在磁盘上等待调入内存的进程构成了 &lt;strong&gt;输入队列（input queue）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;多数系统允许用户进程存放在物理内存任意位置，原程序中的地址通常用符号来表示， &lt;em&gt;编译器&lt;/em&gt; 会将这些符号地址 &lt;strong&gt;绑定（bind）&lt;/strong&gt; 到可重定位的地址， &lt;em&gt;链接程序&lt;/em&gt; 或 &lt;em&gt;加载程序&lt;/em&gt; 再将这些可重定位的地址绑定成绝对地址。绑定是从一个地址空间到另一个地址空间的映射。将指令和数据绑定到内存地址可能有如下几种情况：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编译时（compile time）&lt;/strong&gt; ：在编译时已经知道进程将在物理内存中的驻留地址，则可生成 &lt;strong&gt;绝对代码（absolute code）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载时（load time）&lt;/strong&gt; ：若编译时尚不了解进程将位于物理内存中具体哪个位置，则编译器需生成 &lt;strong&gt;可重定位代码（relocatable code）&lt;/strong&gt; ，如 “从这个模块开始的第 14 个字节”。此时，最后绑定延迟到加载时进行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行时（execution）&lt;/strong&gt; ：若进程在执行时可在内存段间移动，则绑定需要在执行时进行，此种方案需要特定硬件，绝大多数通用操作系统采用这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从源码到二进制内存镜像的过程如下图所示，图片截取自李文生老师《操作系统概念》PPT。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/multistep-processing-of-user-program.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;逻辑地址和物理地址&quot;&gt;&lt;a href=&quot;#逻辑地址和物理地址&quot; class=&quot;headerlink&quot; title=&quot;逻辑地址和物理地址&quot;&gt;&lt;/a&gt;逻辑地址和物理地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CPU 生成的地址为 &lt;strong&gt;逻辑地址（logical address）&lt;/strong&gt; ，加载到 &lt;strong&gt;内存地址寄存器（memory-address register）&lt;/strong&gt; 中的地址为 &lt;strong&gt;物理地址（physical address）&lt;/strong&gt; 。编译时和加载时的地址绑定方法生成的逻辑地址和物理地址相同，执行时的地址绑定方案生成的逻辑地址和物理地址不同。通常称逻辑地址为 &lt;strong&gt;虚拟地址（virtual address）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑地址空间（logical address space）&lt;/strong&gt; 为由程序所生成的所有逻辑地址的集合， &lt;strong&gt;物理地址空间（physical address space）&lt;/strong&gt; 为与这些逻辑地址对应的物理地址集合。&lt;/li&gt;
&lt;li&gt;运行时从虚拟地址到物理地址的映射由硬件设备 &lt;strong&gt;内存管理单元（memory-management unit，MMU）&lt;/strong&gt; 完成。一个最简单的 MMU 方案是将用户进程产生的地址加上 &lt;strong&gt;重定位寄存器（relocation register）&lt;/strong&gt; 的值作为最终的物理内存地址。&lt;/li&gt;
&lt;li&gt;用户进程绝不会看到真正的物理地址，一个地址在内存中比较、使用均基于虚拟地址，只有该地址作为内存地址，如执行加载/存储时才需要做到物理空间的地址映射。总而言之，用户进程只产生逻辑地址，且认为地址空间从 0 开始，而使用对应内存地址前必须由 MMU 做物理地址映射。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;动态加载、链接与共享库&quot;&gt;&lt;a href=&quot;#动态加载、链接与共享库&quot; class=&quot;headerlink&quot; title=&quot;动态加载、链接与共享库&quot;&gt;&lt;/a&gt;动态加载、链接与共享库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态加载（dynamic loading）&lt;/strong&gt; ：所有子程序均以可重定位的方式保存在磁盘上，仅主程序装入内存并执行，当且仅当某个子程序被需要时才会装载进内存。此种方法设计程序主要是用户程序开发者的责任。其优势在于不被使用的子程序绝不会加载，若程序中有较多代码用于处理异常，动态加载会特别有效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态链接库（dynamically linked library）&lt;/strong&gt; ：部分操作系统只支持 &lt;strong&gt;静态链接（static linking）&lt;/strong&gt; ，即加载程序将操作系统提供的语言库与其他目标模块一起合并到最终的二进制程序镜像中，所有程序均有一份所需系统库的副本；而动态链接将系统库的加载延迟到运行时，用户程序对系统库的引用留有 &lt;strong&gt;存根（stub）&lt;/strong&gt; ，存根指用于定位内存驻留库程序的一小段代码。当执行存根时，若所需的系统库已经驻留在内存中，则存根使用已有的系统库，否则将系统库装入内存。最终存根均会将系统库地址替换自身并执行系统库，此时所有使用某个库的进程只需要一个库代码副本。&lt;/li&gt;
&lt;li&gt;动态链接为库更新带来方便，库版本更新后，引用该库的程序会自动使用新版本而无需重新链接。多个版本的库也可以同时装入内存，程序根据自己所需的版本信息确定使用哪个副本。此类系统也称为 &lt;strong&gt;共享库（shared libraried）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;交换&quot;&gt;&lt;a href=&quot;#交换&quot; class=&quot;headerlink&quot; title=&quot;交换&quot;&gt;&lt;/a&gt;交换&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内存中的进程可暂时从内存中 &lt;strong&gt;交换（swap）&lt;/strong&gt; 到 &lt;strong&gt;备份存储（backing store）&lt;/strong&gt; 上，等到再次需要执行时调回。有时称为 &lt;strong&gt;滚出（roll out）&lt;/strong&gt; 和 &lt;strong&gt;滚入（roll in）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;备份存储通常为足够大的快速磁盘，以容纳所有用户程序的内存镜像副本、并提供对内存镜像的直接访问。交换系统上下文切换时间较长，为有效使用 CPU，通常使每个进程每次执行获取的时间片比交换时间长。&lt;/li&gt;
&lt;li&gt;为了 &lt;strong&gt;只交换用户进程真正使用的内存空间&lt;/strong&gt; （如一个用户进程当前可能只使用了 10MB，但其最多可能使用 200 MB），用户进程需要告诉系统其内存需求情况以减少交换时间。&lt;/li&gt;
&lt;li&gt;换出进程时，进程必须完全处于空闲状态。考虑如下场景：一个正在等待 I/O 操作的进程 P 即将被换出，若 I/O 操作异步访问 P 进程内存中的缓冲区，或是 I/O 设备正忙，I/O 操作在排队等待，此时换出进程 P，换入进程 P’ 会导致 I/O 操作已经属于 P’ 的内存。解决方案：&lt;ul&gt;
&lt;li&gt;不能换出有待处理 I/O 的进程&lt;/li&gt;
&lt;li&gt;I/O 操作只能使用操作系统缓冲区，仅当进程在内存中执行时才发生操作系统缓冲和进程内存缓冲之间的数据转移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上述标准交换在目前的操作系统中使用不广泛，交换需要很长时间并且只能提供很少的执行时间。对上述交换方式的一种修正在很多 UNIX 系统中得到使用：当且仅当系统负荷过高，内存吃紧时进行交换。早期缺乏高级硬件的个人计算机通过此种交换可同时运行多个进程，如 MS Windows 3.1，该系统内存不足时将老进程交换到磁盘上，当且仅当用户再次选择执行该进程时才再次换入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;覆盖（补充）&quot;&gt;&lt;a href=&quot;#覆盖（补充）&quot; class=&quot;headerlink&quot; title=&quot;覆盖（补充）&quot;&gt;&lt;/a&gt;覆盖（补充）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多道程序设计环境下可通过 &lt;strong&gt;覆盖（Overlays）&lt;/strong&gt; 技术扩充内存。由程序员实现，不需要操作系统的特殊支持。其思想为：将程序划分为若干个功能上相对独立的程序段，按程序逻辑结构让不会同时执行的程序段共享所有程序段均会使用到的内存。&lt;/li&gt;
&lt;li&gt;覆盖方式的内存管理仅始终保留一个程序 &lt;em&gt;在任何时候&lt;/em&gt; 都需要的数据。&lt;/li&gt;
&lt;li&gt;与交换的区别：&lt;ul&gt;
&lt;li&gt;覆盖对程序员要求较高，程序员必须十分清楚程序的逻辑结构，明确规定各程序段的执行和覆盖顺序以及设计实现覆盖驱动模块，而交换技术对用户透明&lt;/li&gt;
&lt;li&gt;覆盖在同一进程/作业内进行，而交换在进程与进程之间进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;连续内存分配&quot;&gt;&lt;a href=&quot;#连续内存分配&quot; class=&quot;headerlink&quot; title=&quot;连续内存分配&quot;&gt;&lt;/a&gt;连续内存分配&lt;/h1&gt;&lt;h2 id=&quot;内存保护&quot;&gt;&lt;a href=&quot;#内存保护&quot; class=&quot;headerlink&quot; title=&quot;内存保护&quot;&gt;&lt;/a&gt;内存保护&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内存分为操作系统驻留区域和用户进程驻留区域，操作系统通常位于低内存（因为中断向量通常位于低内存）。 &lt;strong&gt;连续内存分配（contiguous memory allocation）&lt;/strong&gt; 可使内存中每个进程占有连续的内存区域。&lt;/li&gt;
&lt;li&gt;通过重定位寄存器和界限地址寄存器可实现内存保护，重定位寄存器含有最低 &lt;em&gt;物理地址&lt;/em&gt; 值，界限地址寄存器含有 &lt;em&gt;逻辑地址&lt;/em&gt; 的范围值。重定位寄存器机制也允许操作系统动态改变，若某操作系统服务（如某个驱动程序）不常使用，则内存中不必保留其代码和数据，这类代码称为 &lt;strong&gt;暂时（transient）&lt;/strong&gt; 操作系统代码，它们根据需要调入/调出，可在程序执行时动态改变操作系统大小。重定位寄存器和界限地址寄存器的硬件支持如下图所示。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/hardware-support-for-relocation-limit-registers.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;内存分配&quot;&gt;&lt;a href=&quot;#内存分配&quot; class=&quot;headerlink&quot; title=&quot;内存分配&quot;&gt;&lt;/a&gt;内存分配&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最简单的内存分配方法：将内存分为多个 &lt;strong&gt;固定&lt;/strong&gt; 大小的 &lt;strong&gt;分区（partition）&lt;/strong&gt; ，每个分区只能容纳一个进程，多道程序的程度受分区数限制。当一个分区空闲时可以从输入队列选择一个进程调入空闲分区，进程终止时释放该分区。此种方式最初被 MFT（F：Fixed，IBM OS/360）使用，目前已被淘汰。&lt;/li&gt;
&lt;li&gt;对 MFT 的推广是 MVT（V:Variable），即 &lt;strong&gt;可变分区（variable partition）&lt;/strong&gt; 方案。操作系统维护一个表以记录哪些内存可用和哪些内存已被占用。初始时所有内存均可用于用户进程，可视作一大块可用内存，称为 &lt;strong&gt;孔（hole）&lt;/strong&gt; 。新进程到来时需要查找足够大的孔，并从该孔为进程分配所需内存，孔内剩余内存可分配给其他进程。随着进程的到来和离开，内存中会分散着大小不同的孔。进程终止时释放的内存会形成新孔，若新孔和其他孔相邻，则这些相邻的孔可以合并为一个大孔。此时系统可以检查是否有进程在等待分配内存空间，以及新合并的内存空间是否满足该进程的需求。&lt;/li&gt;
&lt;li&gt;上述 MVT 方法是通用 &lt;strong&gt;动态存储分配问题（dynamic storage allocation problem）&lt;/strong&gt; 的一种情况，从内存中的一组孔中选择一个空闲孔有如下三种常用方法，其中执行时间、空间利用方面最差适应方法最差，空间利用方面首次适应和最佳适应相近，但首次适应更快：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首次适应（First fit）&lt;/strong&gt; ：分配寻找到的第一个足够大的孔，查找可以从任何位置（如内存开始位置或上次首次适应结束的位置）开始，一旦找到足够大的空闲孔就停止；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最佳适应（Best fit）&lt;/strong&gt; ：分配 &lt;em&gt;最小&lt;/em&gt; 的足够大的孔，此方式必须查找整个表（若表内孔位置记录按孔的大小排序则不需要查找整个表）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最差适应（Worst fit）&lt;/strong&gt; ：分配 &lt;em&gt;最大&lt;/em&gt; 的孔，同样需要查找整个表，产生的孔比最佳适应方法产生的孔价值更大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;碎片&quot;&gt;&lt;a href=&quot;#碎片&quot; class=&quot;headerlink&quot; title=&quot;碎片&quot;&gt;&lt;/a&gt;碎片&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;随着进程装入和移出内存，空闲内存空间被分为散落的小段，产生 &lt;strong&gt;外部碎片问题（external fragmentation）&lt;/strong&gt; ：所有可用内存空间之和满足一个/多个进程的请求，但这些可用内存并不连续。上述首次适应和最佳适应两种不同方法导致的碎片的数量也不同，对于不同的系统两者各有优劣，分配方向（从空闲块的顶端还是模块开始分配内存）也会对碎片数量产生影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;50% 规则&lt;/strong&gt; ：对采用首次适应方法的统计表明，假定有 N 个块已被分配，无论采用什么优化，都可能有 0.5N 个块为外部碎片，即 1/3 的内存无法被使用。&lt;/li&gt;
&lt;li&gt;维护一个小孔的开销比小孔本身可能更大，例如一个需要 2046B 空间的进程被分配了大小为 2048B 的孔，剩余的 2B 小孔维护的开销比 2B 大得多。因此通常采用 &lt;em&gt;固定大小的块&lt;/em&gt; 而不是字节作为分配单元。此时进程被分配的空间通常大于所需空间，分配给进程的块中使用不到的空间被称为 &lt;strong&gt;内部碎片（internal fragmentation）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;解决外部碎片问题的方法：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;紧缩（compaction）&lt;/strong&gt; ：移动内存内容使所有空闲空间合并为一整块。紧缩仅可在重定位是动态的、且在运行时重定位的情况下可用。紧缩根据采用的合并算法不同，需要的开销大小也不同，最简单的合并算法将所有进程移动到内存的一端，空闲的孔移动到内存另一端以生成大孔，其开销较大；&lt;/li&gt;
&lt;li&gt;允许一个进程占有的内存地址空间非连续，只要有物理内存就可以为进程分配：分页、分段、分段+分页。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;分页&quot;&gt;&lt;a href=&quot;#分页&quot; class=&quot;headerlink&quot; title=&quot;分页&quot;&gt;&lt;/a&gt;分页&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分页（Paging）&lt;/strong&gt; 允许进程物理地址空间非连续，内存和备份存储均按页划分，页大小相同。在前述连续内存分配中，内存中的数据换入/换出到备份存储时，备份存储中也会存在类似的碎片问题，而分页避免了这一点。传统的分页由硬件处理，最近的设计（64位机）结合了硬件和操作系统。 &lt;strong&gt;在第八章中，需要假定自己尚未了解第九章的内容，并且进程在执行前已经把所需要的全部数据分页加载到内存中&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;分页方法&quot;&gt;&lt;a href=&quot;#分页方法&quot; class=&quot;headerlink&quot; title=&quot;分页方法&quot;&gt;&lt;/a&gt;分页方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将物理内存分为固定大小的块，称为 &lt;strong&gt;帧（frame）&lt;/strong&gt; ，将逻辑内存分配同样大小的块，称为 &lt;strong&gt;页（page）&lt;/strong&gt; 。备份存储页分为同样固定大小的块，进程执行时将执行所需的页从备份存储中调入可用的内存帧中。其硬件支持如下图所示。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/hardware-support-for-pages.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;CPU 生成的每个逻辑地址分为两部分： &lt;strong&gt;页号（page number）&lt;/strong&gt; 和 &lt;strong&gt;页偏移（page offset）&lt;/strong&gt; ，记为 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 。页号为 &lt;strong&gt;页表（page table）&lt;/strong&gt; 的索引，页表包含每页位于物理内存的基地址，页 &lt;code&gt;p&lt;/code&gt; 在页表中对应的基地址加上页偏移量 &lt;code&gt;d&lt;/code&gt; 即为该逻辑地址映射的物理地址。&lt;/li&gt;
&lt;li&gt;页大小由硬件决定，通常为 2 的次幂，根据计算机结构不同，每页大小从 512B ~ 16MB 不等。页大小为 2 的幂可直接将逻辑地址的 2 进制表示划分为 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;分页也是一种动态重定位，每个逻辑地址由分页硬件绑定为对应的物理地址。采用分页技术不会产生外部碎片，但可能有内部碎片（进程所需内存不足一页，或要求的内存大小不是页的整数倍则最后一帧有内存空闲）。&lt;/li&gt;
&lt;li&gt;目前页大小通常为 4 ~ 8KB，有的系统支持更大页，有的 CPU 内核支持多种页大小。页的大小受如下因素制约：&lt;ul&gt;
&lt;li&gt;在进程大小和页大小无关的前提下，可以假设每个进程平均有半页内部碎片，因此更小的页会带来更少的内部碎片；&lt;/li&gt;
&lt;li&gt;页表对于页和物理内存中的帧的对应关系记录需要一定开销，并且该开销随着页大小的增大而减小，页表中每个条目通常占 4B（可变）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分页的重要特点是 &lt;em&gt;用户视角内存&lt;/em&gt; 和 &lt;em&gt;实际物理内存&lt;/em&gt; 的分离，通过地址转换硬件将用户视角下的逻辑地址转换为物理地址。用户程序将内存作为一整块处理，而实际物理内存中进程可能分布在各个独立的帧中。用户进程无法访问其页表规定之外的内存，进程可见的页表仅包含进程拥有的页面记录。&lt;/li&gt;
&lt;li&gt;操作系统使用 &lt;strong&gt;帧表（frame table）&lt;/strong&gt; 维护物理内存的分配细节（已被占用的帧、可用帧等），帧表的每个条目对应一帧，并标明该帧是否空闲，若占用则被哪个（些）进程的哪个页占用等。操作系统同时 &lt;strong&gt;为每个进程维护一个页表的副本&lt;/strong&gt; ，当一个进程可被分配 CPU 时，CPU 调度程序可根据该副本定义硬件页表（用户进程运行在用户模式，若进行系统调用，操作系统需要使用进程的页表副本来获取进程逻辑地址映射的物理地址）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;硬件支持&quot;&gt;&lt;a href=&quot;#硬件支持&quot; class=&quot;headerlink&quot; title=&quot;硬件支持&quot;&gt;&lt;/a&gt;硬件支持&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最简单的页表硬件实现方法将页表作为一组专用寄存器。&lt;/li&gt;
&lt;li&gt;当代计算机允许页表非常大，因此页表放置在内存中，并设置 &lt;strong&gt;页表基寄存器（page-table base register，PTBR）&lt;/strong&gt; 指向页表，改变页表的位置仅需要修改此寄存器。此种做法的缺陷在于访问一个字节需要两次内存访问（一次用于在内存的页表中查找页号对应的条目，一次用于获取目标字节）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转换表缓冲区（translation look-aside buffer，TLB）&lt;/strong&gt; 是针对上述问题的专用快速硬件缓冲（关联存储器），其条目由键和值组成。TLB 查找速度快且造价昂贵，通常仅有 64 ~ 1024 个条目。TLB 和页表一起使用时，TLB 仅包含最近使用过的页表条目，查询流程如下：&lt;ul&gt;
&lt;li&gt;CPU 产生逻辑地址，从逻辑地址提取出页号交付 TLB，TLB 将页号和存储的键比对，若寻找到相同键则结束流程；&lt;/li&gt;
&lt;li&gt;请求的页码不在 TLB 中，即 &lt;strong&gt;TLB 失效（TLB miss）&lt;/strong&gt; ，此时需要在页表中查询。在页表中查询到与页号对应的帧号后，将页号和帧号增加到 TLB 中。若 TLB 中条目已满，则操作系统使用某种策略替换掉已有的一个条目，例如 &lt;em&gt;最近最少使用替换（LRU）&lt;/em&gt; 或随机替换等。TLB 中有的条目是永久驻留的（不允许从 TLB 中被替换），通常内核代码在 TLB 中的条目固定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有的 TLB 在每个 TLB 条目中存储了 &lt;strong&gt;地址空间标识符（address-space identifier，ASID）&lt;/strong&gt; ，该项用于唯一标识进程，为进程提供地址空间保护。TLB 解析虚拟页号时必须确保当前运行进程的 ASID 和 TLB 中条目对应的 ASID 匹配，否则视作 TLB 失效。除了内存空间保护，ASID 还使 TLB 能够同时包含多个不同进程的记录。如果 TLB 不支持每个条目有独立的 ASID，那么一旦有新页表被选择（例如进程的换入/换出），TLB 就需要被全部 &lt;strong&gt;刷新（flushed）&lt;/strong&gt; 或删除，防止 TLB 中存在无效的条目（页号地址无效的条目，如上一个进程留下来的无效物理地址）导致被换入的进程使用错误的地址转换。&lt;/li&gt;
&lt;li&gt;页号在 TLB 中被查找到的百分比为 &lt;strong&gt;命中率（hit ratio）&lt;/strong&gt; ， &lt;strong&gt;有效内存访问时间（effective memory-access time）&lt;/strong&gt; 的计算需要根据 TLB 的命中率加权。例如查找 TLB 需要 20ns，内存访问需要 100ns，命中率 80%，则有效内存访问时间为 &lt;code&gt;0.8 x 120 + 0.2 x 220 = 140ns&lt;/code&gt; 。需要注意的是， &lt;strong&gt;TLB 查询早于内存中页表的查询，只有 TLB 查询结束并且没有查询到帧号时才会开始在页表中的查询&lt;/strong&gt; ，此前计算机组成原理中讲过的 TLB 有错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;保护和共享&quot;&gt;&lt;a href=&quot;#保护和共享&quot; class=&quot;headerlink&quot; title=&quot;保护和共享&quot;&gt;&lt;/a&gt;保护和共享&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分页情况下内存保护通过每个帧对应的保护位实现，这些保护位通常保存在页表中。常见类型的位有：&lt;ul&gt;
&lt;li&gt;可读写/只读位：产生地址引用时除了在页表中查找对应的帧码，还需要检查保护位验证是否有对只读页进行了写操作，若有则向操作系统产生硬件陷阱。扩展这种方法可提供更细致的保护。&lt;/li&gt;
&lt;li&gt;有效/无效位：该位有效表示与之相关的页属于当前进程的逻辑地址空间，为合法页，否则与之相关的页不属于当前进程的逻辑地址空间。使用该位可以捕获到非法地址，操作系统通过对该位的设置可允许/禁止进程对某页的访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个进程很少会使用到所有分配的地址空间，页表为地址范围内的所有页都建立一个条目是浪费的行为（并且每个进程有一个页表副本），表中的多数条目不会被使用，而这些条目却占据可用地址空间。有些系统提供了 &lt;strong&gt;页表长度寄存器（page-table length register，PTLR）&lt;/strong&gt; 表示页的大小，该寄存器的值可用于验证逻辑地址是否处于进程的有效范围内。&lt;/li&gt;
&lt;li&gt;分页存储可以 &lt;strong&gt;共享&lt;/strong&gt; 公共代码，这对于分时系统非常重要。例如一个多用户系统，每个用户均执行一个文本编辑器，若代码不支持共享，则每个用户需要维护一个文本编辑器的副本；若代码是 &lt;strong&gt;可重入代码（reentrant code）&lt;/strong&gt; 或 &lt;strong&gt;纯代码（pure code）&lt;/strong&gt; ，则这部分代码可以被共享。可重入代码是不能自我修改的代码，它们在执行期间从不改变因此多个进程可以同时执行这部分代码。当然，除了共享的代码，每个进程还有自己的寄存器副本和数据存储。要实现共享，代码必须能够重入，并且可重入代码的只读性需要操作系统强制实现。（如果你了解 Haskell，可重入代码和 Haskell 里的 pure code 有类似的特性，后者不会对环境产生副作用，每次执行仅根据参数确定结果）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;页表结构&quot;&gt;&lt;a href=&quot;#页表结构&quot; class=&quot;headerlink&quot; title=&quot;页表结构&quot;&gt;&lt;/a&gt;页表结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;层次页表（Hierarchical Paging）&lt;/strong&gt; ：当代计算机支持非常大的逻辑地址空间，此时页表本身将非常大。例如 32 位逻辑地址空间的计算机系统，若页大小为 4KB，则页表需要包含 &lt;code&gt;2^20&lt;/code&gt; 个条目，即使每个条目在页表中仅需要 4B 存储，整个页表也需要 4MB 物理地址空间存储（每个进程还需要独立维护一个副本）。因为内存采取分页管理，页表的大小超过了一个页面的大小，因此需要将页表划分到足够小以便一页能够容纳。一种可行的方式是二级分页算法：例如上述 32 位逻辑地址系统，可将 20 位页号划分为 10 位的外部页表页码 &lt;code&gt;p1&lt;/code&gt; 和 10 位的页表偏移量 &lt;code&gt;p2&lt;/code&gt;，其具体的映射方式如下图所示。此种方案也称为 &lt;strong&gt;向前映射页表（forward-mapped page table）&lt;/strong&gt; 。对于 64 位体系结构，层次结构并不合适，例如 64 位 UltraSPARC 体系结构使用 7 级分页，几乎已经是内存访问极限。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/hierarchical-paging.jpg&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希页表（Hashed Page）&lt;/strong&gt; 以虚拟页码作为哈希值，每个条目包括一个链表用于处理碰撞。链表中的每个元素包含三个域：虚拟页码，对应帧号以及指向链表中下一个元素的指针。此种方式的地址映射过程如下：将虚拟页号哈希到表中某个条目，若该条目对应的链表存在元素，则按顺序比较直到找到对应的元素。哈希页表的一个变种是 &lt;strong&gt;群集页表（clustered page table）&lt;/strong&gt; ，它的每个条目包括多页信息，因此一个条目存储了多个物理页帧的映射，这对于 &lt;strong&gt;稀疏（sparse）&lt;/strong&gt; 地址空间非常有效，稀疏地址空间种的地址引用通常不连续并且散布在整个地址空间。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向页表（inverted page table）&lt;/strong&gt; ：每个进程均维护一个相关页表，这个进程使用到的每个页在其持有的页表里有一项，或者每个虚拟地址在页表里都有一项而不论这个虚拟地址是否有效，此时每个页表会有很多项，这些表会消耗大量的内存，而其目的仅仅是追踪物理内存如何使用。反向页表中，每个真实的内存页/帧存在一个条目，该条目包括引用该物理帧的虚拟页号以及拥有该页的进程信息。所以整个系统只有一个页表，每个物理内存帧仅有一条相应的条目。&lt;/li&gt;
&lt;li&gt;一种简化的反向页表实现（IBM RT 采用）：系统每个虚拟地址对应一个三元组 &lt;code&gt;&amp;lt;pid | page numbe r | offset&amp;gt;&lt;/code&gt;，反向表中每个条目为 &lt;code&gt;&amp;lt;pid | page number&amp;gt;&lt;/code&gt;，需要内存引用时，操作系统查找反向页表寻找匹配，若匹配找到则产生物理地址，否则认为产生了非法地址访问。这种方案减少了存储每个页表所需的内存空间，但增加了查找页表所需要的时间。反向页表按照物理地址排序，而查找依据虚拟地址，所以可能需要查找整个表来寻找匹配。可以使用 &lt;em&gt;哈希页表&lt;/em&gt; 限制页表条目或加入 TLB 来改善。此外，采用反向页表的系统很难共享内存，因为每个物理帧只对应一个虚拟页条目。对于这种情况，可以允许页表的没一个条目仅包含一个虚拟地址到共享内存地址的映射，这时对未被映射虚拟地址的引用会导致页错误（page fault）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;分段&quot;&gt;&lt;a href=&quot;#分段&quot; class=&quot;headerlink&quot; title=&quot;分段&quot;&gt;&lt;/a&gt;分段&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;采用分页管理导致用户视角的内存和实际物理地址内存分离，对于装载/写入操作必须将虚拟内存映射到实际的物理内存。 &lt;strong&gt;分段（segmentation）&lt;/strong&gt; 支持另一种用户视角，其逻辑地址空间由一些段组成，每个段有自己的编号和长度，用户通过段号和段内偏移（与分页的区别在于，分页管理中用户只指定一个虚拟地址，由硬件将虚拟地址拆分为页码和偏移，这些工作对程序员透明）来指定地址。&lt;/li&gt;
&lt;li&gt;编译用户程序时，编译器会自动根据输入的程序源码构造段（代码段、静态区、堆、栈等），编译时链接的库可能被分配不同的段，加载程序时装入这些段并分配段号。&lt;/li&gt;
&lt;li&gt;用户可以通过二维地址（段号、偏移）来引用存储单元，但实际物理内存仍然为一维的序列。操作系统通过 &lt;strong&gt;段表（segment table）&lt;/strong&gt; 实现将二维用户定义地址映射到一维物理地址，段表的每个条目对应一个段，存储着该段的段号、段基地址（段在内存中开始的物理地址）和段界限（段的长度），对于某段超出段长的地址引用访问会导致硬件陷阱的触发。&lt;/li&gt;
&lt;li&gt;段表在内存中的位置由 &lt;strong&gt;段基址寄存器（segment table base register，STBR）&lt;/strong&gt; 和 &lt;strong&gt;段长度寄存器（segment table length register，STLR）&lt;/strong&gt; 指定，当段号 s 满足 &lt;code&gt;s &amp;lt; STLR&lt;/code&gt; 时该段合法。&lt;/li&gt;
&lt;li&gt;分段会导致不连续的空闲内存空间以及外部碎片，从空闲内存为进程分配段也存在类似 &lt;em&gt;连续内存分配&lt;/em&gt; 中的问题，有首次适应和最佳适应两种分配方式。&lt;/li&gt;
&lt;li&gt;段可以被共享，多个进程可以通过相同段号共享同一个段。段的保护可通过类似页表中的保护位实现，段表中的每一条条目有一个合法位（为 0 表示不合法），同时也可以支持读/写/执行权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;实例：Intel-Pentium&quot;&gt;&lt;a href=&quot;#实例：Intel-Pentium&quot; class=&quot;headerlink&quot; title=&quot;实例：Intel Pentium&quot;&gt;&lt;/a&gt;实例：Intel Pentium&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;奔腾结构允许一个段的大小最大为 4GB，每个进程最多可持有 16K 个段。进程逻辑地址空间分为两部分，第一部分最多由 8K 个段组成，此部分私有；第二部分最多由 8K 个段组成，此部分可以被所有进程共享。第一部分的信息保存在 &lt;strong&gt;本地描述符表（local descriptor table，LDT）&lt;/strong&gt; 中，第二部分信息保存在 &lt;strong&gt;全局描述符表（global descriptor table，GDT）&lt;/strong&gt; 中，这两个表中每个条目占 8B 空间，包括一个段的详细信息（段基址、段界限）。&lt;/li&gt;
&lt;li&gt;逻辑地址格式： &lt;code&gt;&amp;lt;selector | offset&amp;gt;&lt;/code&gt;，其中选择器（selector）是一个 16 位的数，前 13 位表示段号，第 14 位表示该段在 GDT 还是 LDT 中，最后两位表示保护信息，支持四级保护。偏移量（offset）是 32 位的数，表示段内偏移量。奔腾 CPU 中有 6 个段寄存器，允许一个进程同时访问 6 个段，同时还有 6 个 8B 微程序寄存器保存相应的来自于 LDT 或 GDT 的描述符，它们使奔腾不必在每次内存引用时从内存读取描述符。&lt;/li&gt;
&lt;li&gt;奔腾结构允许页的大小为 4KB 或 4MB，对于 4KB 的页，奔腾使用二级分页方案，32 位线性地址划分为 10、10、12 三块，类似前述的二级分页的例子。最高 10 位引用 &lt;strong&gt;页目录（page directory）&lt;/strong&gt; 的条目，中间 10 位指向内部页表，最后 12 位为 4KB 页面内的偏移。页目录中每个条目有一个 PageSize 标志，若该标识被设置则代表页帧大小 4MB，此时跳过中间 10 位对内层页表的查询，直接使用后 22 位指向 4MB 页帧内偏移。奔腾的页表还可以交换到磁盘上，通过页目录条目的无效位表示该条目对应的页表位于内存还是磁盘。若页表在磁盘上，则可使用条目中剩下的 31 位标明页表在磁盘的具体位置以调入内存。&lt;/li&gt;
&lt;li&gt;奔腾体系结构上运行的 Linux 系统使用 6 个段（内核代码段、内核数据段、用户代码段、用户数据段、任务状态段 TSS 以及默认的 LDT 段）。Linux 中默认的 LDT 段被所有进程共享，如果一个进程需要自己的 LDT ，则它可以生成一个新的 LDT 来代替默认值。此外，每个进程有自己的 TSS 以存储上下文切换中的硬件上下文，每个进程也有自己的页表。&lt;/li&gt;
&lt;li&gt;奔腾体系结构上运行的 Linux 仅使用了四级保护中的两种，用于区分内核模式和用户模式。Linux 采用三级分页方案（全局目录-中间目录-页表-偏移），而奔腾采用二级分页模式，此时 Linux 的 “中间目录” 大小为 0，因此等价于奔腾的二级分页。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（七）：死锁&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2017/01/04/os-concepts-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（九）：虚拟内存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2017/01/03/os-concepts-8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2017/01/03/os-concepts-8/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2017/01/03/os-concepts-8/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第八章内存管理部分，内容均为原书和中文版翻译的摘录，其中原书摘录部分由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>顶点云（应用）用户代理</title>
    <link href="http://forec.github.io/2016/12/03/zenith-cloud-7/"/>
    <id>http://forec.github.io/2016/12/03/zenith-cloud-7/</id>
    <published>2016-12-03T13:44:07.000Z</published>
    <updated>2016-12-23T17:28:14.844Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;设计用户代理，实现 &lt;code&gt;DealWithRequests()&lt;/code&gt; 中的几种简单逻辑指令，如文件列表获取、文件拷贝、Fork操作等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/zenith-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）设计与实现&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/23/zenith-cloud-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）服务器逻辑实现&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：TODO  &lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计用户代理，实现 &lt;code&gt;DealWithRequests()&lt;/code&gt; 中的几种简单逻辑指令，如文件列表获取、文件拷贝、Fork操作等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="Golang" scheme="http://forec.github.io/tags/Golang/"/>
    
      <category term="云存储" scheme="http://forec.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
      <category term="线程" scheme="http://forec.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
