<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Forec的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://forec.github.io/"/>
  <updated>2016-02-14T14:18:00.840Z</updated>
  <id>http://forec.github.io/</id>
  
  <author>
    <name>Forec</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习笔记（Chapter 07 - AdaBoost元算法）</title>
    <link href="http://forec.github.io/2016/02/14/machinelearning7/"/>
    <id>http://forec.github.io/2016/02/14/machinelearning7/</id>
    <published>2016-02-14T14:06:25.000Z</published>
    <updated>2016-02-14T14:18:00.840Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;元算法是对其他算法进行组合的一种方式。在做决定时，大家通常考虑吸取多个专家（分类算法）而不是一个专家的意见。当我们试图对样例数目不均衡的数据进行分类时，会遇到非均衡分类问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;基于数据集多重抽样的分类器&quot;&gt;&lt;a href=&quot;#基于数据集多重抽样的分类器&quot; class=&quot;headerlink&quot; title=&quot;基于数据集多重抽样的分类器&quot;&gt;&lt;/a&gt;基于数据集多重抽样的分类器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;前面已经介绍了五种不同的分类算法，各有优缺点。我们可以将不同的分类器组合起来，这种组合结果被称为集成方法或者元算法。使用集成方法时会有许多形式，可以是不同算法的集合，也可以是同一算法在不同设置下的集成，还可以是数据集不同部分分配给不同分类器之后的集成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自举汇聚法&lt;/strong&gt; （bootstrap aggregating，bagging）是从原始数据集选择S次后得到S个新数据集的技术。新数据集和原数据集大小相等，每个数据集都是通过在原始数据集中随机选择一个样本来进行替换得到的，因此有可能出现多次选择同一样本，所以这一行只允许新数据集中有重复的值，而原始数据集的某些值在新集合中则不再出现。当这S个数据集建好，将某个学习算法应用到每个数据集就得到了S个分类器，之后用这S个分类器分类，投票选择最终类别。其它先进的bagging方法有&lt;strong&gt;随机森林&lt;/strong&gt;等，讨论材料见&lt;a href=&quot;http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;boosting是一种与bagging类似的技术，无论在bo哦sting还是bagging中，分类器的类型都是一致的。但在前者中，不同的分类器是通过串行训练获得的，每个新分类器都根据已训练出的分类器的性能来训练。 &lt;strong&gt;boosting是通过集中关注被已有分类器错分的数据来获得新的分类器&lt;/strong&gt; 。bagging中各个分类器的权重相等，而boosting中的分类器权重不等，代表其对应分类器在上一轮迭代中的成功度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AdaBoost流程&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;准备数据：依赖于使用的弱分类器类型，本章使用单层决策树，也可以使用任意分类器充当弱分类器。简单分类器作为弱分类器效果更好。&lt;/li&gt;
&lt;li&gt;分析数据：任意方法。&lt;/li&gt;
&lt;li&gt;训练算法：占据大部分时间，分类器将多次在同一数据集上训练弱分类器。&lt;/li&gt;
&lt;li&gt;测试算法：计算分类错误率。&lt;/li&gt;
&lt;li&gt;使用算法：二类分类器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基于错误提升分类器性能&quot;&gt;&lt;a href=&quot;#基于错误提升分类器性能&quot; class=&quot;headerlink&quot; title=&quot;基于错误提升分类器性能&quot;&gt;&lt;/a&gt;基于错误提升分类器性能&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可以通过弱分类器和多个实例来构造一个强分类器，这里的“弱”意味着分类器的性能比随即猜测要略好，但不会好太多。AdaBoost是adaptive boosting（自适应boosting），过程如下。&lt;/li&gt;
&lt;li&gt;训练数据集中的每个样本，并赋予其一个权重，这些权重构成了向量D。一开始这些权重都初始化为相等值。首先在训练数据上训练出一个弱分类器并计算该分类器的错误率，然后在同一数据集上再一次训练弱分类器。在分类器的第二次训练中，会重新调整每个样本的权重，其中上一次训练中分对的样本所占权重会降低，分错的样本所占样本权重升高。&lt;/li&gt;
&lt;li&gt;AdaBoost为每个弱分类器设置一个权重α，这些α值根据每个弱分类器的错误率计算，错误率ε=未正确分类的样本数/所有的样本数目。α计算公式为&lt;code&gt;α=0.5*ln((1-ε)/ε)&lt;/code&gt;。可见错误率下降，α上升。计算出α后，对权重向量D更新，如果某个样本被正确地分类，那么&lt;code&gt;D&amp;#39; = D*e^(-α)/sum(D)&lt;/code&gt;，如果某个样本被错分，那么&lt;code&gt;D&amp;#39; = D*e^α/sum(D)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;更新D后，AdaBoost进入下一轮迭代。其会不断重复训练和调整权重的过程，直到某次训练错误率为0，或者弱分类器达到用户指定的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基于单层决策树构建弱分类器&quot;&gt;&lt;a href=&quot;#基于单层决策树构建弱分类器&quot; class=&quot;headerlink&quot; title=&quot;基于单层决策树构建弱分类器&quot;&gt;&lt;/a&gt;基于单层决策树构建弱分类器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单层决策树（决策树桩）是一种简单的决策树，仅基于单个特征来做决策，只有一次分裂过程，因此是一个树桩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简单数据集加载 - adaboost.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadSimpData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	datMat = matrix([[ &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;2.1&lt;/span&gt; ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt; ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;1.3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;  ]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	classLabels = [&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; datMat, classLabels&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建立最佳单层决策树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将最小错误率minError设为+∞&lt;/li&gt;
&lt;li&gt;对数据集中的每一个特征（一层循环）：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对每个步长（二层循环）：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对每个不等号（三层循环）：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;建立一棵单层决策树并利用加权数据集对他测试，如果错误率低于minError，就将当前的单层决策树设为最佳单层决策树&lt;/li&gt;
&lt;li&gt;返回最佳单层决策树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最佳单层决策树生成函数 - adaboost.py。下面包含两个函数，stumpClassify是通过阈值threshVal来确定类别，在阈值一边的数据分到类别-1，另一边分到类别+1。第二个函数buildStump遍历stumpClassify所有可能输入值，第一层循环遍历数据集所有特征，第二层遍历所有阈值，第三层遍历不等号。并找到数据集上最佳的单层决策树。之后返回一个bestStump字典，存乎了最优单层决策树的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stumpClassify&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatrix, dimen, threshVal, threshIneq)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retArray = ones((shape(dataMatrix)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; threshIneq == &lt;span class=&quot;string&quot;&gt;&#39;lt&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		retArray[dataMatrix[:,dimen] &amp;lt;= threshVal] = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		retArray[dataMatrix[:,dimen] &amp;gt; threshVal] = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retArray&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;buildStump&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataArr, classLabels, D)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMatrix = mat(dataArr); labelMat = mat(classLabels).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numSteps = &lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;; bestStump = &amp;#123;&amp;#125;; bestClasEst = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	minError = inf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rangeMin = dataMatrix[:,i].min(); rangeMax = dataMatrix[:,i].max();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stepSize = (rangeMax - rangeMin)/numSteps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,int(numSteps)+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; inequal &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;&#39;lt&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;gt&#39;&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				threshVal = (rangeMin + float(j) * stepSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				errArr = mat(ones((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				errArr[predictedVals == labelMat] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				weightedError = D.T * errArr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#print &quot;split: dim %d, thresh %.2f, thresh inequal: %s, the weighted error is %.3f&quot; %\&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#	(i, threshVal, inequal, weightedError)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; weightedError &amp;lt; minError:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					minError = weightedError&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestClasEst = predictedVals.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestStump[&lt;span class=&quot;string&quot;&gt;&#39;dim&#39;&lt;/span&gt;] = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestStump[&lt;span class=&quot;string&quot;&gt;&#39;thresh&#39;&lt;/span&gt;] = threshVal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestStump[&lt;span class=&quot;string&quot;&gt;&#39;ineq&#39;&lt;/span&gt;] = inequal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bestStump, minError, bestClasEst&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;完整AdaBoost算法&quot;&gt;&lt;a href=&quot;#完整AdaBoost算法&quot; class=&quot;headerlink&quot; title=&quot;完整AdaBoost算法&quot;&gt;&lt;/a&gt;完整AdaBoost算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;伪代码：对每次迭代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用buildStump找到最佳的单层决策树&lt;/li&gt;
&lt;li&gt;将最佳单层决策树加入单层决策树数组&lt;/li&gt;
&lt;li&gt;计算α&lt;/li&gt;
&lt;li&gt;计算新的权重向量D&lt;/li&gt;
&lt;li&gt;更新累计类别估计值&lt;/li&gt;
&lt;li&gt;如果错误率为0.0则退出循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是训练过程代码，输入参数为数据集、类别标签和迭代次数。D是概率分布向量，因此所有元素之和为1，因此初始全部为1/m。同时程序建立列向量aggClassEst记录每个数据点的类别估计累计值。程序中&lt;code&gt;max(error, 1e-16)&lt;/code&gt;防止出现除零溢出。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;adaBoostTrainDS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataArr, classLabels, numIt = &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	weakClassArr = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m = shape(dataArr)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	D = mat(ones((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))/m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	aggClassEst = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numIt):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bestStump, error, classEst = buildStump(dataArr, classLabels, D)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;D:&quot;&lt;/span&gt;, D.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		alpha = float(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;*log((&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;-error)/max(error,&lt;span class=&quot;number&quot;&gt;1e-16&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bestStump[&lt;span class=&quot;string&quot;&gt;&#39;alpha&#39;&lt;/span&gt;] = alpha&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		weakClassArr.append(bestStump)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;classEst &quot;&lt;/span&gt;, classEst.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		expon = multiply(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;*alpha*mat(classLabels).T, classEst)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		D = multiply(D, exp(expon))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		D = D/D.sum()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aggClassEst += alpha*classEst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;aggClassEst: &quot;&lt;/span&gt;, aggClassEst.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T, ones((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		errorRate = aggErrors.sum() / m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;total error: &quot;&lt;/span&gt;, errorRate, &lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; errorRate == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; weakClassArr, aggClassEst&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分类：输入参数是待分类数据和分类器。遍历强分类器中的每个弱分类器，并通过stumpClassify得到每个分类器对某个类别的估计值。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;adaClassify&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(datToClass, classifierArr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMatrix = mat(datToClass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m = shape(dataMatrix)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	aggClassEst = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(classifierArr)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classEst = stumpClassify(dataMatrix, classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;dim&#39;&lt;/span&gt;],\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;thresh&#39;&lt;/span&gt;], classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;ineq&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aggClassEst += classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;alpha&#39;&lt;/span&gt;] * classEst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; aggClassEst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sign(aggClassEst)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在疝气病马数据集上应用AdaBoost算法，通过loadDataSet读入数据，并进行分类。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numFeat = len(open(filename).readline().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMat = []; labelMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineArr = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		curLine = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numFeat - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			lineArr.append(float(curLine[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		dataMat.append(lineArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		labelMat.append(float(curLine[-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat, labelMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;datArr, labelArr = adaboost.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTraining2.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;classifierArray = adaboost.adaBoostTrainDS(datArr, labelArr, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;testArr, testLabelArr = adaboost.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTest2.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;prediction10 = adaboost.adaClassify(testArr, classifierArray)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;errArr = mat(ones((&lt;span class=&quot;number&quot;&gt;67&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;errArr[prediction10!=mat(testLabelArr).T].sum()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误率分析：当分类器数目从1到10000变化时，总测试错误率先达到一个 最小值，之后又上升。该现象称为过拟合。有文献表明，对于表现好的数据集（horseColicTest有30%数据缺失），AdaBoost的测试错误率会达到一个稳定之，并不会随着分类器增加而上升。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;非均衡类问题和其他分类性能度量指标&quot;&gt;&lt;a href=&quot;#非均衡类问题和其他分类性能度量指标&quot; class=&quot;headerlink&quot; title=&quot;非均衡类问题和其他分类性能度量指标&quot;&gt;&lt;/a&gt;非均衡类问题和其他分类性能度量指标&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;之前的分类都假设所有分类代价一样，但实际上将马归类为死或者活的代价不同，假如分类器只有80%正确率，将一匹本能存活的马判定为安乐死，损失会更大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;混淆矩阵&lt;/strong&gt;：列方向为预测结果，行方向为实际结果，如果除了对角线，其他元素都是0，那么将是一个完美的分类器。&lt;/li&gt;
&lt;li&gt;对于二类问题：如果将正例判为正例则产生真阳例（TP），将反例正确判为反例则产生真阴例（TN），将正例错判为反例，则产生假阴例（FN），将反例错判为正例称为假阳例（FP）。正确率=TP/(TP+FP)，召回率=TP/(TP+FN)。在高召回率的分类器重，真正判错的正例数目并不多。我们可以很容易构造一个高准确率或者高召回率的分类器，但很难保证两者同时成立。&lt;/li&gt;
&lt;li&gt;ROC曲线：横轴为假阳率=FP/(FP+TN)，纵轴是真阳率=TP/(TP+FN)。ROC曲线给出的是当阈值变化时假阳率和真阳率变化的情况。左下角点对应所有样例判为反例，右上角对应所有样例判为正例。理想情况下，最佳分类器应尽可能处于左上角。另一个指标是ROC曲线下的面积AUC，代表了分类器的平均性能值。完美分类器的AUC=1.0，随即猜测的AUC=0.5。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建ROC曲线。首先将分类样例按照预测强度排序，强度高的分为正例，低的判为反例。下面为创建ROC曲线的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;plotROC&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(predStrengths, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cur = (&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ySum = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numPosClas = sum(array(classLabels) == &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	yStep = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/float(numPosClas)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	xStep = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/float(len(classLabels) - numPosClas)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sortedIndicies = predStrengths.argsort()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fig.clf()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax = plt.subplot(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sortedIndicies.tolist()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; classLabels[index] == &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			delX = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; delY = yStep;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			delX = xStep; delY = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			ySum += cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ax.plot([cur[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], cur[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]-delX], [cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - delY], c= &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		cur = (cur[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] - delX, cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - delY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax.plot([&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;span class=&quot;string&quot;&gt;&#39;b--&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;False Positive Rate&#39;&lt;/span&gt;); plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;True Positive Rate&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.title(&lt;span class=&quot;string&quot;&gt;&#39;ROC curve for AdaBoost Horse Colic Detection System&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax.axis([&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.show()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the Area Under the Curve is: &quot;&lt;/span&gt;, ySum * xStep&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成图像如下&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/adaboost.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代价敏感&lt;/strong&gt;的学习：选择具有最小期望代价而不是最大概率的类别作为最后的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;数据抽样方法：欠抽样和过抽样。欠抽样指删除部分样例，过抽样指复制部分样例。对于罕见类别，要尽量保留更多信息，通常选择离决策边界较远的样例删除。另一种策略是使用反例类别的欠抽样和正例类别的过抽样结合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;AdaBoost元算法总结&quot;&gt;&lt;a href=&quot;#AdaBoost元算法总结&quot; class=&quot;headerlink&quot; title=&quot;AdaBoost元算法总结&quot;&gt;&lt;/a&gt;AdaBoost元算法总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;元算法过多个分类器组合，可以减轻单分类器的不足。AdaBoost函数可以应用于任何分类器，只要该分类器可以处理加权数据。非均衡分类问题指在分类器训练时正例数目和反例数目不等或者相差很大，或者错分正例和反例代价不同时产生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/14/machinelearning7/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/14/machinelearning7/&quot;&gt;http://forec.github.io/2016/02/14/machinelearning7/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;元算法是对其他算法进行组合的一种方式。在做决定时，大家通常考虑吸取多个专家（分类算法）而不是一个专家的意见。当我们试图对样例数目不均衡的数据进行分类时，会遇到非均衡分类问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《函数式编程思维》笔记</title>
    <link href="http://forec.github.io/2016/02/13/functional-thinking/"/>
    <id>http://forec.github.io/2016/02/13/functional-thinking/</id>
    <published>2016-02-13T01:36:15.000Z</published>
    <updated>2016-02-14T07:34:24.022Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;函数式编程中粒度最小的重用单元是函数（一等公民），并具备值不可变性，带给我的感受是通过一系列基本数据结构方法的复用，配合高阶函数，用最基本的方法叠加出复杂的解法。在用Haskell解决问题总能体会到逆向思维，从目标出发，一步步推到初始条件。函数式的模式匹配、柯里化和部分施用都很有特色，在这种思维下思考是一个很享受的过程。下面是阅读《函数式编程思维》时做摘录的整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;思维转变&quot;&gt;&lt;a href=&quot;#思维转变&quot; class=&quot;headerlink&quot; title=&quot;思维转变&quot;&gt;&lt;/a&gt;思维转变&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令式编程风格通常 &lt;strong&gt;迫使我们出于性能考虑，把不同的任务交织起来，以便能够用一次循环来完成多个任务&lt;/strong&gt; 。而函数式编程用map、filter这些高阶函数把我们解放出来，让我们 &lt;strong&gt;站在更高的抽象层次上去考虑问题&lt;/strong&gt; ，把问题看得更清楚。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把控制权让渡给语言（运行时）。“人生苦短，远离malloc”。函数式编程语言让我们用高阶抽象从容取代基本的控制结构，将琐碎的细节（如垃圾处理）交托给运行时。 &lt;em&gt;面向对象编程通过封装不确定因素来使代码能被人理解；函数式编程通过尽量减少不确定因素来使代码能被人理解。——Michael Feathers&lt;/em&gt; 。与其建立种种机制来控制可变的状态，不如尽可能消灭可变的状态这个不确定因素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;函数式语言提倡 &lt;strong&gt;在有限的几种关键数据结构（list、set、map）上运用针对这些数据结构高度优化过的操作&lt;/strong&gt; ，以此形成基本的运转架构；面向对象程序员喜欢不断的创建新的数据结构和附属的操作，因为OOP范式就是建立新的类和类间的消息。比起一味创建新的类结构体系，把封装的单元降低到函数级别，更有利于达到细颗粒度的、基础层面的重用。&lt;/li&gt;
&lt;li&gt;换用函数式语言不是关键，转变看待问题的角度才是必不可少的。命令式编程是按照“程序是一系列改变状态的命令”来建模的一种编程风格，鼓励程序员将操作安排在循环内部执行。 &lt;strong&gt;函数式语言希望尽可能减少可变的状态&lt;/strong&gt; ，因此更多发展了通用性的计算设施。&lt;/li&gt;
&lt;li&gt;高阶函数消除了摩擦。语法上的便利是非常重要的方面， &lt;strong&gt;在语法处处掣肘下塑造出的抽象，很难配合我们的思维过程而不产生所谓的摩擦&lt;/strong&gt; 。迭代需要让位于高阶函数，如果能用高阶函数把希望执行的操作表达出来，语言将会把操作安排的更高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;权责让渡&quot;&gt;&lt;a href=&quot;#权责让渡&quot; class=&quot;headerlink&quot; title=&quot;权责让渡&quot;&gt;&lt;/a&gt;权责让渡&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;理解掌握的抽象层次永远要比日常使用的抽象层次更深一层&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt; （closure）实际上是一种特殊的函数，在暗地里绑定了函数内部引用的所有变量，换句话说，这种函数把它所引用的所有东西都放在一个上下文里包了起来。下面的代码先定义了一个Employee类，其中带有name和salary字段，接着定义带有amount参数的paidMore函数，其返回值是一个以Employee实例为参数的 &lt;strong&gt;代码块&lt;/strong&gt; ，或者叫闭包。数值100000随着&lt;code&gt;isHighPaid = paidMore(100000)&lt;/code&gt;这一步操作永久的和代码块绑定在一起。第二部分代码执行闭包。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Employee&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; name, salary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; paidMore(amount) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;Employee e -&amp;gt; e.salary &amp;gt; amount &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isHighPaid = paidMore(&lt;span class=&quot;number&quot;&gt;100000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; Smithers = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Employee(&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Fred&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;salary:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;120000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; Homer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Employee(&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Homer&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;salary:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;80000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println isHighPaid(Smithers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println isHighPaid(Homer)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;闭包经常被函数式语言和框架当作一种 &lt;strong&gt;异地执行的机制&lt;/strong&gt; ，用来传递待执行的变换代码，如map之类的高阶函数。注意闭包是代码块，而不是一个值，各个闭包内部状态都是独立的，尽管局部变量不在代码块内定义，但只要代码块引用了该变量，两者就被绑定在一起，这种联系在代码块实例的全部生命期内一直保持着。从实现的角度说， &lt;strong&gt;代码块实例从它被创建的一刻起，就持有其作用域内一切事物的封闭副本&lt;/strong&gt; 。下面的代码展示了闭包的异地执行。闭包所表现出来的函数式思维就是，“让运行时去管理状态”。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; Closure makeCounter()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; local_variable = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; local_variable += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1 = makeCounter()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c2 = makeCounter()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println &lt;span class=&quot;string&quot;&gt;&quot;C1 = $&amp;#123;c1()&amp;#125;, C2 = $&amp;#123;c2()&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// output: C1 = 4, C2 = 1 //&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;柯里化&lt;/strong&gt; 指的是从一个多参数函数变成 &lt;strong&gt;一连串单参数函数&lt;/strong&gt; 的变换。它描述的是 &lt;strong&gt;变换的过程&lt;/strong&gt; ，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生成一个参数数目较少的新函数。举例来说，函数process(x, y, z)完全柯里化之后变成process(x)(y)(z)的性质，其中process(x)和process(x)(y)都是单参数的函数。如果只对第一个参数柯里化，那么process(x)的返回值将是一个单参数的函数，而这个唯一的参数又接受另一个参数的输入。 &lt;strong&gt;函数柯里化的结果是返回链条中的下一个函数&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;部分施用&lt;/strong&gt; 指提前代入一部分参数值，使一个多参数得以省略部分参数，从而转化为一个参数数目较少的函数。 &lt;strong&gt;部分施用是把参数的取值绑定到用户在操作中提供的具体值上&lt;/strong&gt; 。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt; 的核心在于对一个不断变短的列表反复做同一件事，利用递归，将状态的管理责任推给运行时。递归没有成为一种平常的操作，一个主要原因是栈的增长。使用尾调用优化的写法来帮助运行时科夫栈的增长问题。当递归调用是函数执行的最后一个调用时，运行时往往可以在栈里就地更新，而不需要增加新的栈空间。因此 &lt;strong&gt;尽可能多的使用尾递归的写法&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;记忆和缓求值&quot;&gt;&lt;a href=&quot;#记忆和缓求值&quot; class=&quot;headerlink&quot; title=&quot;记忆和缓求值&quot;&gt;&lt;/a&gt;记忆和缓求值&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只有对纯函数才能放心地使用函数缓存的结果，这刚好符合函数式特性。对于Groovy，可以先将记忆的函数定义为闭包，再对闭包使用memoize()方法获得一个新函数，这个新函数调用的时候结果就会被缓存起来。在Haskell中好像下面的链接可以实现。我们写出来的缓存决不可能比语言开发者设计的更高效，因为语言设计者可以无视他们给语言设定的规定。 &lt;strong&gt;语言设计者实现出来的机制总是比开发者自己做的效率高&lt;/strong&gt; 。&lt;a href=&quot;https://wiki.haskell.org/Memoization&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Haskell-Wiki上的Memoization&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓求值的好处：昂贵的运算只有到了绝对必要的时候才执行；可以建立无限大的集合，只要一接到请求就一直送出元素；按缓求值的方式使用map、filter等，可以产生更高效的代码。特别适合于资源生产成本较高的情况。Haskell的惰性求值就是这样的特性，是非严格求值的。在严格求值的语言运行下面代码会报错，而非严格求值的语言会得出4。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; length([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;语言演化&quot;&gt;&lt;a href=&quot;#语言演化&quot; class=&quot;headerlink&quot; title=&quot;语言演化&quot;&gt;&lt;/a&gt;语言演化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;少量的数据结构搭配大量的操作。函数式语言有很多操作，但对应的数据结构很少。面向对象语言鼓励建立专门针对某个类的方法，我们从类的关系中发现重复出现的模式并加以重用。 &lt;strong&gt;函数式语言的重用表现在函数的通用性上，他们鼓励在数据结构上使用各种共通的变换，并通过高阶函数来调整操作以满足具体事项的要求&lt;/strong&gt; 。 &lt;em&gt;100个函数操作一种数据结构的组合，要好过10个函数操作10种数据结构的组合。——Alan Perlis&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;让语言去迎合问题&lt;/strong&gt; ，不要拿问题硬套语言，而是想法揉捏手中的语言来迎合问题。Lisp家族的语言传承了无可比拟的灵活性，对DSL的支持比主流语言要强得多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;函数式偏好没有副作用的纯函数，“异常”违背了这个条件。因此函数式语言通过Either类这种不相交联合体，返回左值表示错误信息，右值表示正常结果。函数式语言关注 &lt;strong&gt;引用的透明性&lt;/strong&gt; ，发出调用的例程不必关心他的访问对象真的是一个值，还是一个返回值的函数。&lt;/li&gt;
&lt;li&gt;现代语言大多数是多范式的，支持多种多样的编程范式，如OOP，元编程、函数式、过程式等等。这些范式在语言中相互正交（没有任何影响），不会相互干扰。&lt;/li&gt;
&lt;li&gt;设计模式的变化，模式已被函数式语言吸收成为了语言的一部分，语言特性简化了实现细节。OOP模式和FP模式已经具备了不同的意义。面向对象倾向于封装对象的重用，在不同的结构之间 &lt;strong&gt;耦合&lt;/strong&gt; 。而函数式编程则依靠零件之间的 &lt;strong&gt;复合&lt;/strong&gt; 来组织抽象，以达到减少不确定因素的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《函数式编程思维 - 美 Neal Ford》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/13/functional-thinking/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/13/functional-thinking/&quot;&gt;http://forec.github.io/2016/02/13/functional-thinking/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数式编程中粒度最小的重用单元是函数（一等公民），并具备值不可变性，带给我的感受是通过一系列基本数据结构方法的复用，配合高阶函数，用最基本的方法叠加出复杂的解法。在用Haskell解决问题总能体会到逆向思维，从目标出发，一步步推到初始条件。函数式的模式匹配、柯里化和部分施用都很有特色，在这种思维下思考是一个很享受的过程。下面是阅读《函数式编程思维》时做摘录的整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="函数式编程" scheme="http://forec.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 06 - 支持向量机）</title>
    <link href="http://forec.github.io/2016/02/11/machinelearning6/"/>
    <id>http://forec.github.io/2016/02/11/machinelearning6/</id>
    <published>2016-02-11T10:05:05.000Z</published>
    <updated>2016-02-14T07:43:11.224Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;支持向量机（Support Vector Machineds，SVM）是一个二类问题的分类器，实现方法多样，这里采用了序列最小优化（SMO）实现方法，并通过核函数拓展到非线性可分的SVM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;SVM和最大边缘超平面&quot;&gt;&lt;a href=&quot;#SVM和最大边缘超平面&quot; class=&quot;headerlink&quot; title=&quot;SVM和最大边缘超平面&quot;&gt;&lt;/a&gt;SVM和最大边缘超平面&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;SVM的优缺点&lt;ul&gt;
&lt;li&gt;优点：泛化错误率低，计算开销不大撒，结果易解释&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;对参数调节和核函数的选择敏感&lt;/strong&gt;，原始分类器不加修改情况下仅适用于处理二类问题&lt;/li&gt;
&lt;li&gt;适用数值类型：数值型和标称型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最大边缘超平面：在二维平面上分布的二类数值点，如果可以通过一条直线将两组不同类的数据分开，则这组数据&lt;strong&gt;线性可分&lt;/strong&gt;。在假设数据线性可分的前提下，将数据集分开的直线被称为分隔超平面，如果数据分布在三位平面，那么分隔超平面就是二维的。如果数据集分布在N维空间，则分隔超平面是N-1维。如果&lt;strong&gt;数据点离分隔超平面越远，则最后的预测结果就越好&lt;/strong&gt;。因为&lt;strong&gt;决策边界边缘较小的分类器对模型的过分拟合更加敏感，从而在未知的样本上的泛化能力很差&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;支持向量：离分隔超平面最近的那些点，支持向量机决策只依赖支持向量。&lt;/li&gt;
&lt;li&gt;寻找最大间隔：用向量的形式&lt;code&gt;W·X+b&lt;/code&gt;书写分隔超平面不需要考虑空间维度，其中向量W和常量b描述了所给数据的分隔超平面。因此SVM需要寻找使分隔超平面成为最大边缘超平面的W和b。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;分隔超平面目标函数的优化&quot;&gt;&lt;a href=&quot;#分隔超平面目标函数的优化&quot; class=&quot;headerlink&quot; title=&quot;分隔超平面目标函数的优化&quot;&gt;&lt;/a&gt;分隔超平面目标函数的优化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;SVM工作原理：与Logistic回归类似，使用一个类似海维赛德阶跃函数的函数对所给数据的W·X+b的结果判定分类，如果结果大于0则输出+1，否则输出-1。使用+1和-1而不使用1和0的作用在于，可以通过一个统一公式来表示间隔或者数据点到分隔超平面的距离。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数间隔和几何间隔：点到分隔超平面的函数间隔为&lt;code&gt;y*(wx+b)&lt;/code&gt;，其中y是函数的类别标签（+1或-1）；点到超平面的几何间隔为&lt;code&gt;y*(wx+b)/||w||&lt;/code&gt;。SVM使用几何间隔定义数据点和超平面的距离，因为如果使用函数间隔，则随着w的放大，（wx+b）的值也随之不断增大，此时最优化（最大化）距离无法确定w。《机器学习实战》对SVM的原理介绍很粗略，并且直接给出了最终的可以解决线性不可分情况的公式。《机器学习实战》中SMO之前的部分在&lt;a href=&quot;http://www.cnblogs.com/v-July-v/archive/2012/06/01/2539022.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;July的支持向量机通俗导论&lt;/a&gt;的第一层有比较清楚的介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面部分《机器学习实战》没有讲，在《数据挖掘导论》的5.5节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;边缘公式的优化&lt;/strong&gt;：要最大化最小间隔几何距离，考虑离决策边界最近的数据，如果数据在决策边界上方，则wx+b的结果是正值，在下方为负值，我们可以&lt;strong&gt;固定一个因子，调整另一个因子来优化最大值&lt;/strong&gt;。因此我们设置一个约束条件&lt;code&gt;y*(wx+b)&amp;gt;=1&lt;/code&gt;，这意味着所有的数据都在&lt;code&gt;wx+b&amp;gt;=1&lt;/code&gt;和&lt;code&gt;wx+b&amp;lt;=-1&lt;/code&gt;的范围内，距离超平面越远的店，其wx+b的绝对值就越大，只有支持向量才满足&lt;code&gt;y(wx+b)=1&lt;/code&gt;的。我们选取两个数据点，一个在wx+b=1直线上，一个在wx+b=-1直线上，相减得到&lt;code&gt;w(x1-x2)=2&lt;/code&gt;，注意w、x1和x2都是向量，所以d=x1-x2就代表着两点之间平行于超平面法线方向的距离。因此&lt;code&gt;d=2/||w||&lt;/code&gt;。要让d最大，等价于让&lt;code&gt;f(w)=||w||^2/2&lt;/code&gt;最小。因此，&lt;strong&gt;调整后的目标函数是f(w)，并且受到&lt;code&gt;y(wx+b)&amp;gt;=1&lt;/code&gt;的约束&lt;/strong&gt;。目标函数是二次的，w和b是线性的，因此该问题是凸优化问题（凸函数一阶可微，二阶导衡非负），此时可以引入拉格朗日算子，并且根据KKT条件将不等式约束改为等式约束&lt;code&gt;y(wx+b)-1=0&lt;/code&gt; ，变为最小化&lt;code&gt;Lp = ||w||^2/2 - ∑(λ(y(wx+b)-1)&lt;/code&gt;，观察这个式子，我们限定λ&amp;gt;=0。其一阶导数为0，得到w=∑λyx，∑λy=0。将这两个条件代入拉格朗日算子的公式中，就得到书中的最后的目标函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;不可分情况的处理：如果有少数数据噪声，需要引入正值的松弛变量ε，修改约束条件为&lt;code&gt;y(wx+b)-(1-ε)&amp;gt;=0&lt;/code&gt;，假设直线wx+b=-1+ε经过数据点P，并且平行于决策边界，那么P到wx+b=-1的距离是ε/||w||。因此，ε提供了决策边界在训练样本P上的误差估计。同样，因为我们在决策边界上允许了一定的错误，可能导致误分许多的实例，所以&lt;strong&gt;对松弛变量很大的边界进行惩罚&lt;/strong&gt;，修改后的目标函数为&lt;code&gt;f(w) = ||w||^2 /2 +C(∑ε)^k&lt;/code&gt;，其中C和k是用户指定的参数，用于对误分的数据进行惩罚。假定k=1。这样修改后问题的拉格朗日函数多了一项&lt;code&gt;-∑με&lt;/code&gt;，利用KKT条件约束，一阶导数为0，得到额外条件&lt;code&gt;μ+λ =C&lt;/code&gt;，因此0&amp;lt;=λ&amp;lt;=C，配合&lt;code&gt;∑λy = 0&lt;/code&gt;，这就是书中最终给出的约束公式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SMO求解最优化问题&quot;&gt;&lt;a href=&quot;#SMO求解最优化问题&quot; class=&quot;headerlink&quot; title=&quot;SMO求解最优化问题&quot;&gt;&lt;/a&gt;SMO求解最优化问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;推荐&lt;a href=&quot;http://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JerryLead博客中的支持向量机（五）SMO算法&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SMO算法的目标是求出一系列α和b，这里的α就是上面约束条件中的λ（拉格朗日乘子），因为参考的博客和书中都用α，下面也都用α。只要求出了α，根据&lt;code&gt;w=∑αyx&lt;/code&gt;，就能够求出w。工作原理是每次循环选择两个alpha进行优化处理，一旦找到一对可以优化的α，就增大其中一个，同时减少另外一个。这两个α的选择方法决定了SMO的效率和正确率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SMO算法里的辅助函数&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fileName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMat = []; labelMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(fileName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineArr = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		dataMat.append([float(lineArr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), float(lineArr[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		labelMat.append(float(lineArr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat, labelMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectJrand&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i, m)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	j = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j == i):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		j = int(random.uniform(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,m))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; j&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clipAlpha&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(aj, H, L)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; aj &amp;gt; H:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aj = H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L &amp;gt; aj:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aj = L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; aj&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《机器学习实战》书中先给了简化版的SMO算法，每次先选定一个α，然后随机选取另一个α。如果所有向量都没有被优化，就增加迭代次数，直到达到要求的迭代次数。书中给出平均速度14.5s。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;smoSimple&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatIn, classLabels, C, toler, maxIter)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; m,n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alphas = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    iter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (iter &amp;lt; maxIter):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alphaPairsChanged = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fXi = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[i,:].T)) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Ei = fXi - float(labelMat[i])&lt;span class=&quot;comment&quot;&gt;#if checks if an example violates KKT conditions&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((labelMat[i]*Ei &amp;lt; -toler) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (alphas[i] &amp;lt; C)) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; ((labelMat[i]*Ei &amp;gt; toler) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (alphas[i] &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j = selectJrand(i,m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fXj = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[j,:].T)) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Ej = fXj - float(labelMat[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaIold = alphas[i].copy(); alphaJold = alphas[j].copy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (labelMat[i] != labelMat[j]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, alphas[j] - alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    H = min(C, C + alphas[j] - alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, alphas[j] + alphas[i] - C)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    H = min(C, alphas[j] + alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L==H: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;L==H&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                eta = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * dataMatrix[i,:]*dataMatrix[j,:].T - dataMatrix[i,:]*dataMatrix[i,:].T - dataMatrix[j,:]*dataMatrix[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; eta &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;eta&amp;gt;=0&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphas[j] -= labelMat[j]*(Ei - Ej)/eta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphas[j] = clipAlpha(alphas[j],H,L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (abs(alphas[j] - alphaJold) &amp;lt; &lt;span class=&quot;number&quot;&gt;0.00001&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;j not moving enough&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])&lt;span class=&quot;comment&quot;&gt;#update i by the same amount as j&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                        &lt;span class=&quot;comment&quot;&gt;#the update is in the oppostie direction&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[i,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i,:]*dataMatrix[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[j,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j,:]*dataMatrix[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; alphas[i]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (C &amp;gt; alphas[i]): b = b1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; alphas[j]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (C &amp;gt; alphas[j]): b = b2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: b = (b1 + b2)/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaPairsChanged += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;iter: %d i:%d, pairs changed %d&quot;&lt;/span&gt; % (iter,i,alphaPairsChanged)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (alphaPairsChanged == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;): iter += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: iter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;iteration number: %d&quot;&lt;/span&gt; % iter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b,alphas&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启发式选择方法：每次选择α时，优先选择样本前面系数0&amp;lt;α&amp;lt;C的α作优化，因为在界上（α为0或C）的样例对应的α一般不会更改。这种启发式搜索方法是选择第一个α用的，只要选择出来的两个α中有一个违背了KKT条件，那么目标函数在一步迭代后值会减小。违背KKT条件不代表0&amp;lt;α&amp;lt;C，在界上也有可能会违背。因此&lt;strong&gt;在给定初始值α1=0后，先对所有样例进行循环，循环中碰到违背KKT条件的（不管界上还是界内）都进行迭代更新。等这轮过后，如果没有收敛，第二轮就只针对的样例进行迭代更新&lt;/strong&gt;。在第一个α选择后，第二个α也使用启发式方法选择，&lt;strong&gt;第二个α的迭代步长大致正比于|E1-E2|，选择第二个α能够最大化|E1-E2|&lt;/strong&gt;。即当E1为正时选择负的绝对值最大的E2，反之，选择正值最大的E2。最后的收敛条件是在界内（0&amp;lt;α&amp;lt;C）的样例都能够遵循KKT条件，且其对应的α只在极小的范围内变动。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完整的Platt SMO算法，书上数据平均时间0.78秒，下面是用到的辅助函数和结构。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;optStruct&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,dataMatIn, classLabels, C, toler)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# Initialize the structure with the parameters &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.X = dataMatIn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.labelMat = classLabels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.C = C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tol = toler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.m = shape(dataMatIn)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.alphas = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.eCache = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))) &lt;span class=&quot;comment&quot;&gt;#first column is valid flag&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcEk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(oS, k)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fXk = float(multiply(oS.alphas,oS.labelMat).T*(oS.X*oS.X[k,:].T)) + oS.b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ek = fXk - float(oS.labelMat[k])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Ek&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectJK&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i, oS, Ei)&lt;/span&gt;:&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;#this is the second choice -heurstic, and calcs Ej&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    maxK = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; maxDeltaE = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; Ej = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oS.eCache[i] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,Ei]  &lt;span class=&quot;comment&quot;&gt;#set valid #choose the alpha that gives the maximum delta E&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    validEcacheList = nonzero(oS.eCache[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (len(validEcacheList)) &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; validEcacheList:   &lt;span class=&quot;comment&quot;&gt;#loop through valid Ecache values and find the one that maximizes delta E&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; k == i: &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#don&#39;t calc for i, waste of time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Ek = calcEk(oS, k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            deltaE = abs(Ei - Ek)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (deltaE &amp;gt; maxDeltaE):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                maxK = k; maxDeltaE = deltaE; Ej = Ek&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxK, Ej&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:   &lt;span class=&quot;comment&quot;&gt;#in this case (first time around) we don&#39;t have any valid eCache values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j = selectJrand(i, oS.m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Ej = calcEk(oS, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; j, Ej&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;updateEkK&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(oS, k)&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;#after any alpha has changed update the new value in the cache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ek = calcEk(oS, k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oS.eCache[k] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,Ek]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完整SMO的内循环&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;innerL&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i, oS)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ei = calcEk(oS, i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((oS.labelMat[i]*Ei &amp;lt; -oS.tol) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.alphas[i] &amp;lt; oS.C)) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; ((oS.labelMat[i]*Ei &amp;gt; oS.tol) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.alphas[i] &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j,Ej = selectJ(i, oS, Ei) &lt;span class=&quot;comment&quot;&gt;#this has been changed from selectJrand&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oS.labelMat[i] != oS.labelMat[j]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, oS.alphas[j] - oS.alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, oS.alphas[j] + oS.alphas[i] - oS.C)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            H = min(oS.C, oS.alphas[j] + oS.alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L==H: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;L==H&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        eta = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * oS.X[i,:]*oS.X[j,:].T - oS.X[i,:]*oS.X[i,:].T - oS.X[j,:]*oS.X[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; eta &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;eta&amp;gt;=0&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        updateEk(oS, j) &lt;span class=&quot;comment&quot;&gt;#added this for the Ecache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (abs(oS.alphas[j] - alphaJold) &amp;lt; &lt;span class=&quot;number&quot;&gt;0.00001&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;j not moving enough&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])&lt;span class=&quot;comment&quot;&gt;#update i by the same amount as j&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        updateEk(oS, i) &lt;span class=&quot;comment&quot;&gt;#added this for the Ecache                    #the update is in the oppostie direction&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[i,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[i,:]*oS.X[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[j,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[j,:]*oS.X[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; oS.alphas[i]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.C &amp;gt; oS.alphas[i]): oS.b = b1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; oS.alphas[j]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.C &amp;gt; oS.alphas[j]): oS.b = b2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: oS.b = (b1 + b2)/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是外循环代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;smoP&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatIn, classLabels, C, toler, maxIter)&lt;/span&gt;:&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#full Platt SMO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oS = optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    iter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    entireSet = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;; alphaPairsChanged = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (iter &amp;lt; maxIter) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; ((alphaPairsChanged &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; (entireSet)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alphaPairsChanged = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; entireSet:   &lt;span class=&quot;comment&quot;&gt;#go over all&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(oS.m):        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaPairsChanged += innerL(i,oS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fullSet, iter: %d i:%d, pairs changed %d&quot;&lt;/span&gt; % (iter,i,alphaPairsChanged)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            iter += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;span class=&quot;comment&quot;&gt;#go over non-bound (railed) alphas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nonBoundIs = nonzero((oS.alphas.A &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) * (oS.alphas.A &amp;lt; C))[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nonBoundIs:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaPairsChanged += innerL(i,oS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;non-bound, iter: %d i:%d, pairs changed %d&quot;&lt;/span&gt; % (iter,i,alphaPairsChanged)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            iter += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; entireSet: entireSet = &lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#toggle entire set loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (alphaPairsChanged == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;): entireSet = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;iteration number: %d&quot;&lt;/span&gt; % iter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; oS.b,oS.alphas&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是求W和分类函数&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcWs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(alphas, dataArr, classLabels)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	X = mat(dataArr); labelMat = mat(classLabels).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(X)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	w = zeros((n,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))	&lt;span class=&quot;comment&quot;&gt;# n*1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		w += multiply(alphas[i] * labelMat[i], X[i,:].T)	&lt;span class=&quot;comment&quot;&gt;# n*1*1 (1*n)^T&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; w&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classified&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dat, ws, b)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dat * mat(ws) + b &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;核函数&quot;&gt;&lt;a href=&quot;#核函数&quot; class=&quot;headerlink&quot; title=&quot;核函数&quot;&gt;&lt;/a&gt;核函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;来自《数据挖掘导论》，并参考&lt;a href=&quot;https://www.zhihu.com/question/24627666&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎上关于机器学习中核函数的讨论&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;径向基函数（RBF）：是一个采用向量作为自变量的函数，能够基于向量距离运算输出一个标量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;核函数和SVM是两个正交的概念，通过核函数可以将当前维度无法线性划分的数据转移到高维（无穷维度）。SVM核的变换后空间也称为&lt;strong&gt;再生核希尔伯特空间（RKHS）&lt;/strong&gt;，使用核函数计算点积开销更小，并且计算在原空间进行，无须担心维灾难问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Mercer定理：对非线性SVM使用的核函数的主要要求是，必须存在一个相应的变换，使得计算一对向量的核函数等价于在变换后的空间中计算这对向量的点积。核函数K可以表示为&lt;code&gt;K(u, v) = Φ(u)Φ(v)&lt;/code&gt;，当且仅当对于任意满足&lt;code&gt;∫g(x)^2dx&lt;/code&gt;为有限值得函数g(x)，则&lt;code&gt;∫K(x,y)g(x)g(y)dxdy &amp;gt;= 0&lt;/code&gt;。满足这个定理的核函数称为正定核函数。例如&lt;code&gt;K(x,y) = (x·y+1)^p&lt;/code&gt;，&lt;code&gt;K(x,y) = e^(-(|x-y|^2)/2σ^2))&lt;/code&gt;，&lt;code&gt;K(x,y) = tanh(ky·y - δ)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;核函数转换&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;kernelTrans&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(X, A, kTup)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(X)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	K = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; kTup[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;string&quot;&gt;&#39;lin&#39;&lt;/span&gt;: K = X*A.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; kTup[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			deltaRow = X[j,:] - A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			K[j] = deltaRow * deltaRow.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		K = exp(K / (-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;*kTup[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; NameError(&lt;span class=&quot;string&quot;&gt;&quot;Houston We Have a Problem -- \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		That kernel is not recognized&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; K&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是测试函数，需要对函数innerL和calcEk和类optStruct做一定修改。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testRbf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(k1=&lt;span class=&quot;number&quot;&gt;1.3&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataArr, labelArr = loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;testSetRBF.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	b, alphas = smoP(dataArr, labelArr, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;, (&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;,k1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	datMat = mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	svInd = nonzero(alphas.A &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sVs = datMat[svInd]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	labelSV = labelMat[svInd]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;there are %d Support Vectors&quot;&lt;/span&gt; % shape(sVs)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		kernelEval = kernelTrans(sVs, datMat[i,:], (&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;,k1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict) != sign(labelArr[i]) : errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the training error rate is %f&quot;&lt;/span&gt; % (float(errorCount)/m) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataArr, labelArr = loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;testSetRBF2.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	datMat = mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		kernelEval = kernelTrans(sVs, datMat[i,:], (&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;,k1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict) != sign(labelArr[i]) : errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the test error rate is %f&quot;&lt;/span&gt; % (float(errorCount)/m)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原代码需要修改的地方&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;innerL&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        eta = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * oS.K[i,j] - oS.K[i,i] - oS.K[j,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i,i] -\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    			oS.labelMat[j] * (oS.alphas[j] - alphaJold) * oS.K[i,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i,j] - \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    			oS.labelMat[j] * (oS.alphas[j] - alphaJold) * oS.K[j,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcEk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(oS, k)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	fXk = float(multiply(oS.alphas, oS.labelMat).T * oS.K[:,k] + oS.b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Ek = fXk - float(oS.labelMat[k])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Ek&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;optStruct&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, dataMatIn, classLabels, C, toler, kTup)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.X = dataMatIn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.labelMat = classLabels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.C = C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.tol = toler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.m = shape(dataMatIn)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.alphas = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.eCache = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.K = mat(zeros((self.m, self.m)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(self.m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			self.K[:,i] = kernelTrans(self.X, self.X[i,:], kTup)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;kNN手写问题回顾&quot;&gt;&lt;a href=&quot;#kNN手写问题回顾&quot; class=&quot;headerlink&quot; title=&quot;kNN手写问题回顾&quot;&gt;&lt;/a&gt;kNN手写问题回顾&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SVM是二类分类器，将非9的数字判为-1，否则判为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - testDigits - svmMLiA.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;img2vector&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVect = zeros((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fr = open(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineStr = fr.readline()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            returnVect[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;*i+j] = int(lineStr[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnVect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadImages&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dirName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; os &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; listdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hwLabels = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trainingFileList = listdir(dirName)           &lt;span class=&quot;comment&quot;&gt;#load the training set&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = len(trainingFileList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trainingMat = zeros((m,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fileNameStr = trainingFileList[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fileStr = fileNameStr.split(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]     &lt;span class=&quot;comment&quot;&gt;#take off .txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classNumStr = int(fileStr.split(&lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; classNumStr == &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;: hwLabels.append(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: hwLabels.append(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trainingMat[i,:] = img2vector(&lt;span class=&quot;string&quot;&gt;&#39;%s/%s&#39;&lt;/span&gt; % (dirName, fileNameStr))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; trainingMat, hwLabels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testDigits&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(kTup=&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataArr,labelArr = loadImages(&lt;span class=&quot;string&quot;&gt;&#39;trainingDigits&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b,alphas = smoP(dataArr, labelArr, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;, kTup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    svInd=nonzero(alphas.A&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sVs=datMat[svInd] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    labelSV = labelMat[svInd];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;there are %d Support Vectors&quot;&lt;/span&gt; % shape(sVs)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m,n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict)!=sign(labelArr[i]): errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the training error rate is: %f&quot;&lt;/span&gt; % (float(errorCount)/m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataArr,labelArr = loadImages(&lt;span class=&quot;string&quot;&gt;&#39;testDigits&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m,n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict)!=sign(labelArr[i]): errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the test error rate is: %f&quot;&lt;/span&gt; % (float(errorCount)/m)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改径向基核函数的参数σ，观察错误率。σ下降，则训练错误率降低，测试错误率上升。最小的训练错误率并不对应于最小的向量支持数目。另外线性和函数的效果并不很糟糕，可以牺牲线性核函数的错误率来换取分类速度的提高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;多类分类问题&quot;&gt;&lt;a href=&quot;#多类分类问题&quot; class=&quot;headerlink&quot; title=&quot;多类分类问题&quot;&gt;&lt;/a&gt;多类分类问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;第一种方法将多类问题分解为K个二类问题，对于类别yi，属于类别yi的为一类，不属于yi的为另一类。此方法称为一对其他（1-r）方法。&lt;/li&gt;
&lt;li&gt;第二种方法为一对一（1-1）方法，构建K(K-1)/2个分类器，没一个分类器用来区分一对类(yi,yj)，此时忽略其他类的样本。&lt;/li&gt;
&lt;li&gt;以上两种方法都使用二类分类器的组合预测，并投票表决，票数多的分类为最终分类。这种方法可能导致不同类的平局。&lt;/li&gt;
&lt;li&gt;纠错输出编码：1-r和1-1方法都对二元分类的错误太敏感。可以参考海明编码，为每个类别分配一个码字，码字的每个二进制位训练一个二元分类器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;支持向量机总结&quot;&gt;&lt;a href=&quot;#支持向量机总结&quot; class=&quot;headerlink&quot; title=&quot;支持向量机总结&quot;&gt;&lt;/a&gt;支持向量机总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;支持向量机是一种二类分类器，通过求解一个二次优化问题来最大化分类间隔。通过SMO算法每次优化两个α可以提升SVM的训练速度。核函数可以从一个低维空间的非线性数据映射到一个高维空间的线性数据i，此部分可以参考知乎。&lt;/p&gt;
&lt;p&gt;SVM问题可以表示为凸优化问题，利用已知的有效算法发现目标函数的全局最小值。通过最大化决策边界的边缘来控制模型的能力，用户必须提供其他参数，如核函数类型、松弛变量带来的惩罚C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》、《数据挖掘导论 - 美Pang-Ning Tan等》&lt;/p&gt;
&lt;p&gt;参考的文章等：&lt;a href=&quot;http://www.cnblogs.com/v-July-v/archive/2012/06/01/2539022.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;July的文章&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JerryLead的文章&lt;/a&gt;，&lt;a href=&quot;https://www.zhihu.com/question/24627666&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;王赟 Maigo等在知乎上的答案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/11/machinelearning6/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/11/machinelearning6/&quot;&gt;http://forec.github.io/2016/02/11/machinelearning6/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;支持向量机（Support Vector Machineds，SVM）是一个二类问题的分类器，实现方法多样，这里采用了序列最小优化（SMO）实现方法，并通过核函数拓展到非线性可分的SVM。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 05 - Logistic回归）</title>
    <link href="http://forec.github.io/2016/02/09/machinelearning5/"/>
    <id>http://forec.github.io/2016/02/09/machinelearning5/</id>
    <published>2016-02-09T10:57:05.000Z</published>
    <updated>2016-02-14T07:47:21.211Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Logistic回归根据现有数据对边界回归线建立回归公式，以此进行分类。训练分类器时的做法就是寻找最佳拟合参数，使用的是最优化算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Logistic回归和Sigmoid函数&quot;&gt;&lt;a href=&quot;#Logistic回归和Sigmoid函数&quot; class=&quot;headerlink&quot; title=&quot;Logistic回归和Sigmoid函数&quot;&gt;&lt;/a&gt;Logistic回归和Sigmoid函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Logistic回归过程&lt;ul&gt;
&lt;li&gt;准备数据：需要进行距离运算，数据类型为数值型，结构化数据格式最佳。&lt;/li&gt;
&lt;li&gt;分析数据：任意方法。&lt;/li&gt;
&lt;li&gt;训练算法：大部分时间用于训练，训练目的为了找到最佳的分类回归系统。&lt;/li&gt;
&lt;li&gt;测试算法：训练步骤完成后分类将会很快。&lt;/li&gt;
&lt;li&gt;使用算法：输入数据并将其转换为对应的结构化数值，之后基于训练好的回归系数可以对这些数值进行简单的回归计算，判定其属于哪个类别。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Logistic回归优缺点&lt;ul&gt;
&lt;li&gt;优点：计算代价不高，易于理解和实现&lt;/li&gt;
&lt;li&gt;缺点：容易欠拟合，分类精度不高&lt;/li&gt;
&lt;li&gt;使用数据类型：数值型和标称型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sigmoid函数：是近似海维塞德阶跃函数（单位阶跃函数），&lt;code&gt;σ(z)=1/(1+e^(-z))&lt;/code&gt;。当x为0时，Sigmoid(0)=0.5，随着x的增大减小，σ(x)将逼近1和0。当横坐标刻度足够大，Sigmoid看起来类似阶跃函数。我们将输入数据的每个特征乘以对应的回归系数，得到的结果相加，作为Sigmoid函数的参数，得到一个范围在0-1之间的数值，若大于0.5则归入1，小于0.5则归入0。因此Logistic回归可以被看成概率估计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;最佳回归系数确定&quot;&gt;&lt;a href=&quot;#最佳回归系数确定&quot; class=&quot;headerlink&quot; title=&quot;最佳回归系数确定&quot;&gt;&lt;/a&gt;最佳回归系数确定&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;梯度上升法与梯度下降法类似，梯度上升算法用来求函数的最大值，梯度下降算法用来求函数的最小值。思想为要找到某函数的最大值，则沿着该函数的梯度方向探寻。梯度上升法到达每个点后会重新估计移动方向，循环迭代直至满足停止条件。对于线性回归系数，初始状态均为1，每次迭代的计算公式为&lt;code&gt;w:=w+α▽f(w)&lt;/code&gt;，▽f(w)是在w处的梯度，α是沿梯度方向移动量大小，记为步长。该公式一直迭代执行，直到停止条件，比如迭代次数达到某个指定值，或误差达到指定精度。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用梯度上升找到最佳参数，R为迭代次数，流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个回归系数初始化为1&lt;/li&gt;
&lt;li&gt;重复以下步骤R次：计算整个数据集的梯度，使用alpha*gradient更新回归系数的向量，返回回归系数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - gradAscent - logRegres.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sigmoid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inX)&lt;/span&gt;:&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;# the array from numpy can be used as a single parameter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+exp(-inX))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;gradAscent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatIn, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMatrix = mat(dataMatIn)    &lt;span class=&quot;comment&quot;&gt;# m*n&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	labelMat = mat(classLabels).transpose()    &lt;span class=&quot;comment&quot;&gt;# m*1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	alpha = &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	maxCycles = &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	weights = ones((n,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))    &lt;span class=&quot;comment&quot;&gt;# n*1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(maxCycles):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		h = sigmoid(dataMatrix*weights)	&lt;span class=&quot;comment&quot;&gt;# m*1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		error = (labelMat - h)	&lt;span class=&quot;comment&quot;&gt;# counting error direction, m*1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		weights = weights + alpha * dataMatrix.transpose() * error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; weights&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - loadDataSet - logRegres.py ，loadDataSet函数导入testSet.txt，返回数据矩阵和标签。gradAscent接收数据矩阵和标签，并返回生成的回归系数向量。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMat = []; labelMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(&lt;span class=&quot;string&quot;&gt;&#39;testSet.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineArr = line.strip().split()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		dataMat.append([&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, float(lineArr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), float(lineArr[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		labelMat.append(int(lineArr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat, labelMat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - plotBestFit - logRegres.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;plotBestFit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(weights)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMat, labelMat = loadDataSet()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataArr = array(dataMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	n = shape(dataArr)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	xcord1 = []; ycord1 = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	xcord2 = []; ycord2 = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; int(labelMat[i]) == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			xcord1.append(dataArr[i,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); ycord1.append(dataArr[i,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			xcord2.append(dataArr[i,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]); ycord2.append(dataArr[i,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax.scatter(xcord1, ycord1, s = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, c = &lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, marker = &lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax.scatter(xcord2, ycord2, s = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, c = &lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	x = arange(-&lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	y = (-weights[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]-weights[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]*x)/weights[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax.plot(x,y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;x1&#39;&lt;/span&gt;); plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;x2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.show()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&amp;gt;&amp;gt;&amp;gt; import logRegres&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&amp;gt;&amp;gt;&amp;gt; dataArr, labelMat = logRegres.loadDataSet()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&amp;gt;&amp;gt;&amp;gt; weights = logRegres.gradAscent(dataArr, labelMat)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#&amp;gt;&amp;gt;&amp;gt; logRegres.plotBestFit(weights.getA())&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;随机梯度上升&quot;&gt;&lt;a href=&quot;#随机梯度上升&quot; class=&quot;headerlink&quot; title=&quot;随机梯度上升&quot;&gt;&lt;/a&gt;随机梯度上升&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gradAscent函数迭代五百次，并且每次计算都要遍历整个数据集，对于大规模数据复杂度过高。改进方法为每次仅用一个样本点来更新回归系数，只在新样本到来时对分类器进行增量式更新，是在线学习算法。流程如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有回归系数初始化为1&lt;/li&gt;
&lt;li&gt;对数据集中的每个样本：计算该样本的梯度，使用alpha*gradient更新回归系数值&lt;/li&gt;
&lt;li&gt;返回回归系数值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - stocGradAscent0 - logRegres.py，随机上升算法在200次迭代时的系数变化过程在《机器学习实战》82页，其中系数X2经过50次迭代后达到稳定，而系数1和0则需要更多次迭代。并且，在大的波动停止后，还有一些小的周期性波动，这源于数据中存在一些不能正确分类的样本点（数据集非线性可分），在每次迭代时会引发系统的剧烈震荡。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stocGradAscent0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatrix, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	weights = ones(n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	alpha = &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		h = sigmoid(sum(dataMatrix[i]*weights))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		error = classLabels[i] - h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		weights = weights + alpha * error * dataMatrix[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; weights&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Improve - Code -stocGradAscent1 - logRegres.py，改进后的代码中，alpha每次迭代都会调整，这可以缓解高频波动，并且虽然alpha随着迭代次数减小，但永远不会减小到0（常数项存在），这样保证多次迭代之后新数据仍然对系数有影响。同样，这也避免了alpha的严格下降，避免参数的严格下降也常见于模拟退火算法等其他优化算法中。改进后的代码通过随机选取样本的方式更新回归系数，这样可以减少周期性波动。改进后的代码收敛速度更快，默认迭代次数150。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stocGradAscent1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatrix, classLabels, numIter = &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	weights = ones(n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numIter):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		dataIndex = range(m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			alpha = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;+j+i)+&lt;span class=&quot;number&quot;&gt;0.0001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			randIndex = int(random.uniform(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len(dataIndex)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			h = sigmoid(sum(dataMatrix[randIndex]*weights))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			error = classLabels[randIndex] - h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			weights = weights + alpha * error * dataMatrix[randIndex]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt;(dataIndex[randIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; weights&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;改进后的回归系数&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/logistic%E5%9B%9E%E5%BD%92-%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8A%E5%8D%87.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;处理数据中的缺失值&quot;&gt;&lt;a href=&quot;#处理数据中的缺失值&quot; class=&quot;headerlink&quot; title=&quot;处理数据中的缺失值&quot;&gt;&lt;/a&gt;处理数据中的缺失值&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;假设有1000个样本和20个特征，若某传感器损坏导致一个特征无效，其余数据仍可用。&lt;ul&gt;
&lt;li&gt;使用可用特征的均值填补缺失值&lt;/li&gt;
&lt;li&gt;使用特殊值来填补确实值，如-1&lt;/li&gt;
&lt;li&gt;忽略有缺失值的样本&lt;/li&gt;
&lt;li&gt;使用相似样本的均值填补缺失值&lt;/li&gt;
&lt;li&gt;使用另外的机器学习算法预测缺失值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Logistic回归，确实只用0代替可以保留现有数据，并且无需对算法进行修改。如果在测试数据集中发现某一条数据的类别标签已经缺失，Logistic回归的简单做法是将该数据丢弃，但如果采用类似kNN的方法则不太可行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code 用logistic回归从疝气病症预测病马死亡率 - logRegres.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classifyVector&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inX, weights)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	prob = sigmoid(sum(inX*weights))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; prob &amp;gt; &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;colicTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	frTrain = open(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTraining.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	frTest = open(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTest.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	trainingSet = []; trainingLabels = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; frTrain.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		currLine = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineArr = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			lineArr.append(float(currLine[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		trainingSet.append(lineArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		trainingLabels.append(float(currLine[&lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; numTestVec = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; frTest.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		numTestVec += &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		currLine = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineArr = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i  &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			lineArr.append(float(currLine[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; int(classifyVector(array(lineArr), trainWeights)) != int(currLine[&lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;]) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorRate = (float(errorCount)/numTestVec)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the error rate of this test is %f&quot;&lt;/span&gt; % errorRate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; errorRate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;multiTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numTests = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; errorSum = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numTests):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		errorSum += colicTest()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;after %d iterations the average error rate is: %f&quot;&lt;/span&gt; % (numTests, errorSum/float(numTests))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Matplotlib绘制&quot;&gt;&lt;a href=&quot;#Matplotlib绘制&quot; class=&quot;headerlink&quot; title=&quot;Matplotlib绘制&quot;&gt;&lt;/a&gt;Matplotlib绘制&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;备份下列几份代码（来自《机器学习实战》的github），大致了解matplotlib绘制的基本方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;绘制等高线 - plotGD.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.cm &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; cm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.mlab &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; mlab&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;leafNode = dict(boxstyle=&lt;span class=&quot;string&quot;&gt;&quot;round4&quot;&lt;/span&gt;, fc=&lt;span class=&quot;string&quot;&gt;&quot;0.8&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arrow_args = dict(arrowstyle=&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;-&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matplotlib.rcParams[&lt;span class=&quot;string&quot;&gt;&#39;xtick.direction&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;out&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matplotlib.rcParams[&lt;span class=&quot;string&quot;&gt;&#39;ytick.direction&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;out&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;delta = &lt;span class=&quot;number&quot;&gt;0.025&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = np.arange(-&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, delta)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = np.arange(-&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, delta)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X, Y = np.meshgrid(x, y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Z1 = -((X-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Z2 = -(Y**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# difference of Gaussians&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Z = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; * (Z2 + Z1)+&lt;span class=&quot;number&quot;&gt;5.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Create a simple contour plot with labels using default colors.  The&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# inline argument to clabel will control whether the labels are draw&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# over the line segments of the contour, removing the lines beneath&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# the label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CS = plt.contour(X, Y, Z)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.annotate(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, xy=(&lt;span class=&quot;number&quot;&gt;0.05&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.05&lt;/span&gt;),  xycoords=&lt;span class=&quot;string&quot;&gt;&#39;axes fraction&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             xytext=(&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;), textcoords=&lt;span class=&quot;string&quot;&gt;&#39;axes fraction&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             va=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;, ha=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;, bbox=leafNode, arrowprops=arrow_args )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.text(-&lt;span class=&quot;number&quot;&gt;1.9&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1.8&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;P0&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.annotate(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, xy=(&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;),  xycoords=&lt;span class=&quot;string&quot;&gt;&#39;axes fraction&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             xytext=(&lt;span class=&quot;number&quot;&gt;0.35&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;), textcoords=&lt;span class=&quot;string&quot;&gt;&#39;axes fraction&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             va=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;, ha=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;, bbox=leafNode, arrowprops=arrow_args )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.text(-&lt;span class=&quot;number&quot;&gt;1.35&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1.23&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;P1&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.annotate(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, xy=(&lt;span class=&quot;number&quot;&gt;0.35&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;),  xycoords=&lt;span class=&quot;string&quot;&gt;&#39;axes fraction&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             xytext=(&lt;span class=&quot;number&quot;&gt;0.45&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0.35&lt;/span&gt;), textcoords=&lt;span class=&quot;string&quot;&gt;&#39;axes fraction&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             va=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;, ha=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;, bbox=leafNode, arrowprops=arrow_args )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.text(-&lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.8&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;P2&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.text(-&lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.6&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;P3&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.clabel(CS, inline=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, fontsize=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.title(&lt;span class=&quot;string&quot;&gt;&#39;Gradient Ascent&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;y&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成图像如下&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/Logistic%E5%9B%9E%E5%BD%92-plotGD-%E7%AD%89%E9%AB%98%E7%BA%BF.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机梯度上升过程中回归系数的变化 - plotGD.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; matplotlib.patches &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Rectangle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; logRegres&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stocGradAscent0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatrix, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m,n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alpha = &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    weights = ones(n)   &lt;span class=&quot;comment&quot;&gt;#initialize to all ones&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    weightsHistory=zeros((&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;*m,n))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            h = logRegres.sigmoid(sum(dataMatrix[i]*weights))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            error = classLabels[i] - h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            weights = weights + alpha * error * dataMatrix[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            weightsHistory[j*m + i,:] = weights&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; weightsHistory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stocGradAscent1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatrix, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m,n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alpha = &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    weights = ones(n)   &lt;span class=&quot;comment&quot;&gt;#initialize to all ones&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    weightsHistory=zeros((&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;*m,n))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataIndex = range(m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alpha = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;+j+i)+&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            randIndex = int(random.uniform(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,len(dataIndex)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            h = logRegres.sigmoid(sum(dataMatrix[randIndex]*weights))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            error = classLabels[randIndex] - h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#print error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            weights = weights + alpha * error * dataMatrix[randIndex]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            weightsHistory[j*m + i,:] = weights&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt;(dataIndex[randIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; weights&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; weightsHistory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dataMat,labelMat=logRegres.loadDataSet()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dataArr = array(dataMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myHist = stocGradAscent1(dataArr,labelMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n = shape(dataArr)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;#number of points to create&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xcord1 = []; ycord1 = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xcord2 = []; ycord2 = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;markers =[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;colors =[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;311&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;# take care&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type1 = ax.plot(myHist[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;X0&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;312&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type1 = ax.plot(myHist[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;X1&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;313&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type1 = ax.plot(myHist[:,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;iteration&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;X2&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成图像如下&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/Logistic%E5%9B%9E%E5%BD%92-plotSDerror-%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成sigmoid函数 - sigmoidPlot.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pylab &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t = arange(-&lt;span class=&quot;number&quot;&gt;60.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;60.3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + exp(-t))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax = subplot(&lt;span class=&quot;number&quot;&gt;211&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax.plot(t,s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#ax.axis([-5,5,0,1])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;Sigmoid(x)&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax = subplot(&lt;span class=&quot;number&quot;&gt;212&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;# x-y-index&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax.plot(t,s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax.axis([-&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])    &lt;span class=&quot;comment&quot;&gt;# x-index width&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;Sigmoid(x)&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成图像如下&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/logistic%E5%9B%9E%E5%BD%92-sigmoid%E5%87%BD%E6%95%B0.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Logistic回归总结&quot;&gt;&lt;a href=&quot;#Logistic回归总结&quot; class=&quot;headerlink&quot; title=&quot;Logistic回归总结&quot;&gt;&lt;/a&gt;Logistic回归总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Logistic回归的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，求解过程可以由最优化算法完成。随机梯度上升算法可以简化梯度上升算法，获取几乎相同的效果，并且占用更少的计算资源，在新数据到来时完成在线更新，而不需要重新读取整个数据集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/09/machinelearning5/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/09/machinelearning5/&quot;&gt;http://forec.github.io/2016/02/09/machinelearning5/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Logistic回归根据现有数据对边界回归线建立回归公式，以此进行分类。训练分类器时的做法就是寻找最佳拟合参数，使用的是最优化算法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 01-04）</title>
    <link href="http://forec.github.io/2016/02/04/machinelearning1-4/"/>
    <id>http://forec.github.io/2016/02/04/machinelearning1-4/</id>
    <published>2016-02-04T15:48:05.000Z</published>
    <updated>2016-02-14T07:50:04.480Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;最近在自学数据挖掘和机器学习方面的内容，参考《机器学习实战》。整理笔记备忘。下面为Chapter1~Chapter4内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Chapter-01&quot;&gt;&lt;a href=&quot;#Chapter-01&quot; class=&quot;headerlink&quot; title=&quot;Chapter 01&quot;&gt;&lt;/a&gt;Chapter 01&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用NumPy&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;random.rand(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# make 4*4 random array&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;mat1 = mat( random.rand(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) )  &lt;span class=&quot;comment&quot;&gt;# make 4*4 random matrix&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;mat1.I  &lt;span class=&quot;comment&quot;&gt;# get the reverse of mat1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;eye(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# make 4*4 unit matrix&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;deb源安装numpy和matplotlib：&lt;code&gt;pip install numpy&lt;/code&gt;，在此前需要安装python-dev。安装matplotlib前需要libpng，在sourceforge可以找到最新版本，之后&lt;code&gt;apt-get install python-matplotlib&lt;/code&gt;。python3和python2类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;标称型和数值型：分别从有限和无限目标集中取值。&lt;/li&gt;
&lt;li&gt;选择合适算法&lt;ul&gt;
&lt;li&gt;预测目标变量的值：监督学习算法 =&amp;gt; 目标变量为离散型：分类算法； 目标变量为连续型：回归算法。&lt;/li&gt;
&lt;li&gt;不预测目标变量：无监督学习算法 =&amp;gt; 唯一需求是将数据划分为离散的组：聚类算法； 需要估计数据与每个组的相似度：密度估计算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开发机器学习程序步骤：收集数据-&amp;gt;准备输入数据-&amp;gt;分析输入数据-&amp;gt;&lt;strong&gt;训练算法&lt;/strong&gt;-&amp;gt;&lt;strong&gt;测试算法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Chapter-02-k-近邻算法&quot;&gt;&lt;a href=&quot;#Chapter-02-k-近邻算法&quot; class=&quot;headerlink&quot; title=&quot;Chapter 02 - k-近邻算法&quot;&gt;&lt;/a&gt;Chapter 02 - k-近邻算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;已知样本集中每一数据与所属分类的对应关系，将待定数据的每个特征与样本集中数据对应的特征进行比较，取前k个最相似数据决断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;kNN-Category&quot;&gt;&lt;a href=&quot;#kNN-Category&quot; class=&quot;headerlink&quot; title=&quot;kNN - Category&quot;&gt;&lt;/a&gt;kNN - Category&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算已知类别数据集中的点和当前点之间的距离（map）&lt;/li&gt;
&lt;li&gt;按距离递增排序（sort）&lt;/li&gt;
&lt;li&gt;选取于当前点距离最小的k个点（take）&lt;/li&gt;
&lt;li&gt;统计k个点所在类别的出现频率（sortBy frequency）&lt;/li&gt;
&lt;li&gt;返回前k个点中出现频率最高的类别（length . group）&lt;/li&gt;
&lt;li&gt;Haskell的表示： reverse . sort . map length . group . sortBy frequency . take k . sort . map distance &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - kNN.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; operator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	group = array([[&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	labels = [&lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; group, labels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classify0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inX, dataSet, labels, k )&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataSetSize = dataSet.shape[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;# dataSet = group,  dataSet.shape[0] = 4, dataSet.shape[1] = 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	diffMat = tile(inX, (dataSetSize, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) -dataSet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			  	&lt;span class=&quot;comment&quot;&gt;# inX = [1,2] tile(inX,(4,2)) = array([[1,2,1,2],	tile(inX,(2,3)) = array([[1,2,1,2,1,2],&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#									  [1,2,1,2],							 [1,2,1,2,1,2]])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#									  [1,2,1,2],&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#									  [1,2,1,2]])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sqDiffMat = diffMat**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			  	&lt;span class=&quot;comment&quot;&gt;# diffMat = array([[ 0.  ,  0.1],  diffMat**2 = array([[0, 0.01],&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#  		  	       [ 0.  ,  0.  ],					   [0, 0.  ],&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#			       [ 1.  ,  1.  ],					   [1.,1.  ],&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#			       [ 1.  ,  0.9]])					   [1.,0.81]])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sqDistances = sqDiffMat.sum(axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;# sqDiffMat.sum(axis=1) = array([ 0.01, 0. , 2. , 1.81])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	distances = sqDistances**&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sortedDistIndicies = distances.argsort()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;# sortedDisIndicies = array([1, 0, 3, 2]), the indeices of the sorted distances&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	classCount = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(k) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		voteIlabel = labels[sortedDistIndicies[i]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			    &lt;span class=&quot;comment&quot;&gt;# get the first k data&#39;s label =&amp;gt; k=3, [&#39;A&#39;,&#39;A&#39;,&#39;B&#39;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classCount[voteIlabel] = classCount.get(voteIlabel,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;# classCount.get(voteIlabel,default) if voteIlabel doesn&#39;t exist, return default&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sortedClassCount = sorted(classCount.iteritems(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;							  key = operator.itemgetter(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), reverse =&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;# sortedClassCount = [(&#39;A&#39;,2),(&#39;B&#39;,1)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sortedClassCount[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;约会网站配对效果&quot;&gt;&lt;a href=&quot;#约会网站配对效果&quot; class=&quot;headerlink&quot; title=&quot;约会网站配对效果&quot;&gt;&lt;/a&gt;约会网站配对效果&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;流程：收集数据（文本文件）-&amp;gt;准备数据（用Python解析文本文件）-&amp;gt;分析数据（用Matplotlib画二维扩散图）-&amp;gt;训练算法（不适用k-近邻算法）-&amp;gt;测试算法（使用提供的部分数据作为测试样本）-&amp;gt;使用算法（产生命令行程序）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;准备数据-文件-gt-样本矩阵&quot;&gt;&lt;a href=&quot;#准备数据-文件-gt-样本矩阵&quot; class=&quot;headerlink&quot; title=&quot;准备数据 - 文件-&amp;gt;样本矩阵&quot;&gt;&lt;/a&gt;准备数据 - 文件-&amp;gt;样本矩阵&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据存放在文本文件datingTestSet.txt中，每行为一个样本，共1000行，每行包含三种特征。在kNN.py中创建file2matrix将输入文本文件转为样本矩阵和类标签向量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - kNN.py  &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;file2matrix&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	arrayOLines = fr.readlines()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numberOfLines = len(arrayOLines)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	returnMat = zeros((numberOfLines, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &lt;span class=&quot;comment&quot;&gt;# generate a matrix filled with zero&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	classLabelVector = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; arrayOLines:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		line = line.strip()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		listFromLine = line.split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		returnMat[index,:] = listFromLine[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classLabelVector.append(int(listFromLine[-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		index += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnMat, classLabelVector&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;分析数据-Matplotlib&quot;&gt;&lt;a href=&quot;#分析数据-Matplotlib&quot; class=&quot;headerlink&quot; title=&quot;分析数据 - Matplotlib&quot;&gt;&lt;/a&gt;分析数据 - Matplotlib&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;作用在于从已有的样本中观察数据分布的特点，选择合适的坐标，区分数据点从属的类别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;交互命令&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kNN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;datingDataMat, datingLabels = kNN.file2matrix(&lt;span class=&quot;string&quot;&gt;&#39;datingTestSet.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ax.scatter(datingDataMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],datingDataMat[:,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加区分，修改上面的ax.scatter为&lt;code&gt;ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*array(datingLabels),15.0*array(datingLabels))&lt;/code&gt;，需要从numpy库中导入array数组。此时绘制的图形采用数据中的第2列和第3列作为横纵坐标，区分出三种类型但不够清晰。若采用第1列和第2列作为坐标，得到散点图如下。&lt;br&gt;&lt;img src=&quot;http://7xqmj8.com1.z0.glb.clouddn.com/k-%E8%BF%91%E9%82%BB-%E7%BA%A6%E4%BC%9A%E7%BD%91%E7%AB%99.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;准备数据-归一化&quot;&gt;&lt;a href=&quot;#准备数据-归一化&quot; class=&quot;headerlink&quot; title=&quot;准备数据 - 归一化&quot;&gt;&lt;/a&gt;准备数据 - 归一化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单通过欧几里得距离衡量样本与数据间距离会受到数据大小范围影响，例如每年飞行常客里程数的差距远大于视频游戏百分比。因此将所有数据的特征值都归一到0~1之间或-1~1之间，公式为&lt;code&gt;newValue = (old - value - min) / ( max - min)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 归一化特征值 - kNN.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;autoNorm&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    minVals = dataSet.min(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	maxVals = dataSet.max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ranges = maxVals - minVals&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	normDataSet = zeros(shape(dataSet))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m = dataSet.shape[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	normDataSet = dataSet - tile(minVals, (m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	normDataSet = normDataSet / tile(ranges,(m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; normDataSet, ranges, minvals&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;测试算法&quot;&gt;&lt;a href=&quot;#测试算法&quot; class=&quot;headerlink&quot; title=&quot;测试算法&quot;&gt;&lt;/a&gt;测试算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;取样本中一部分作为测试数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 测试算法 - kNN.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;datingClassTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	hoRatio = &lt;span class=&quot;number&quot;&gt;0.10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	datingDataMat, datingLabels = file2matrix(&lt;span class=&quot;string&quot;&gt;&#39;datingTestSet.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	normMat, ranges, minVals = autoNorm(datingDataMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m = normMat.shape[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numTestVecs = int(m*hoRatio)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorCount = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numTestVecs):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m,:],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									 datingLabels[numTestVecs:m], &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the classifier came back with: %d, the real answer is: %d&quot;&lt;/span&gt;\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									% (classifierResult, datingLabels[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (classifierResult != datingLabels[i]): errorCount += &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the total error rate is :%f&quot;&lt;/span&gt; % (errorCount / float(numTestVecs))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;手写识别系统&quot;&gt;&lt;a href=&quot;#手写识别系统&quot; class=&quot;headerlink&quot; title=&quot;手写识别系统&quot;&gt;&lt;/a&gt;手写识别系统&lt;/h2&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;收集数据：提供32*32像素格式的txt文件&lt;/li&gt;
&lt;li&gt;准备数据：编写函数img2vector()将文本文件转换为样本矩阵&lt;/li&gt;
&lt;li&gt;分析数据：在命令提示符中检验数据正确性&lt;/li&gt;
&lt;li&gt;训练算法：不适用于k-近邻算法&lt;/li&gt;
&lt;li&gt;测试算法：使用部分数据集作为测试样本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;准备数据&quot;&gt;&lt;a href=&quot;#准备数据&quot; class=&quot;headerlink&quot; title=&quot;准备数据&quot;&gt;&lt;/a&gt;准备数据&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用trainingDigits中的大约2000个例子作为样本，平均每个0~9的数字有200个样本。使用testDigits目录下的测试数据作为测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - img2vector - kNN.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;img2vector&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	returnVect  = zeros((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range (&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineStr = fr.readline()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j  &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range (&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			returnVect[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;*i+j] = int(lineStr[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnVect&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;测试算法-1&quot;&gt;&lt;a href=&quot;#测试算法-1&quot; class=&quot;headerlink&quot; title=&quot;测试算法&quot;&gt;&lt;/a&gt;测试算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;测试946个文件，错误11个，修改变量k的值、随即训练样本的取样、训练样本的数目，都会对错误率产生影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - handwritingClassTest - kNN.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handwritingClassTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; os &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; listdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	hwLabels = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	trainingFileList = listdir(&lt;span class=&quot;string&quot;&gt;&#39;digits/trainingDigits&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m = len(trainingFileList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	trainingMat = zeros((m,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fileNameStr = trainingFileList[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fileStr = fileNameStr.split(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classNumStr = int(fileStr.split(&lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		hwLabels.append(classNumStr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		trainingMat[i,:] = img2vector(&lt;span class=&quot;string&quot;&gt;&#39;digits/trainingDigits/%s&#39;&lt;/span&gt; % fileNameStr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	testFileList=  listdir(&lt;span class=&quot;string&quot;&gt;&#39;digits/testDigits&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorCount = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mTest = len(testFileList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(mTest):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fileNameStr = testFileList[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fileStr = fileNameStr.split(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classNumStr = int(fileStr.split(&lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vectorUnderTest = img2vector(&lt;span class=&quot;string&quot;&gt;&#39;digits/testDigits/%s&#39;&lt;/span&gt; % fileNameStr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the classifier came back with: %d, the real answer is %d&quot;&lt;/span&gt;\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					% (classifierResult, classNumStr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (classifierResult != classNumStr) : errorCount += &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;\nthe total number of errors is: %d&quot;&lt;/span&gt; % errorCount&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;\nthe total error rate is: %f&quot;&lt;/span&gt; % (errorCount/float(mTest))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;k-近邻算法-总结&quot;&gt;&lt;a href=&quot;#k-近邻算法-总结&quot; class=&quot;headerlink&quot; title=&quot;k-近邻算法 总结&quot;&gt;&lt;/a&gt;k-近邻算法 总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;k-近邻算法是基于实例的学习，使用算法是必须有接近实际数据的训练样本数据，并且必须保存全部数据集，使用大量的存储空间。需要对数据集中的每个数据计算距离值，实际使用过程非常耗时。并且k-近邻算法无法给出任何数据的基础结构信息，因而我们无法知晓平均实例样本和典型实例样本具有什么样的特征。k-决策树是k-近邻算法的优化，减少存储空间和计算时间开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Chapter-03-决策树-熵度量&quot;&gt;&lt;a href=&quot;#Chapter-03-决策树-熵度量&quot; class=&quot;headerlink&quot; title=&quot;Chapter 03 - 决策树 - 熵度量&quot;&gt;&lt;/a&gt;Chapter 03 - 决策树 - 熵度量&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;k-近邻算法无法持久化分类器，每次分类都需要重新学习，并且无法给出数据的内在含义。决策树的主要优势在于其数据形式非常容易理解，并且可以保存在硬盘上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;特性和思想&quot;&gt;&lt;a href=&quot;#特性和思想&quot; class=&quot;headerlink&quot; title=&quot;特性和思想&quot;&gt;&lt;/a&gt;特性和思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;决策树优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关的特征数据。缺点：可能产生&lt;strong&gt;过度匹配&lt;/strong&gt;问题。适用于数值型和标称型，数值型需先离散化。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整体思路：大原则是“&lt;strong&gt;将无序的数据变得更加有序&lt;/strong&gt;”。从当前可供学习的数据集中，选择一个特性，根据这个特性划分出来的数据分类，可以获得最高的信息增益（在划分数据集前后信息发生的变化），也可以说是最小的熵（公式&lt;code&gt;l(xi) = p(xi)log(p(xi))&lt;/code&gt;，出现的概率越小，携带的信息量越大，&lt;strong&gt;熵越高，混合的数据也就越多&lt;/strong&gt;），&lt;strong&gt;信息增益是熵的减少，或者是数据无序度的减少&lt;/strong&gt;。在此划分之后，对划分出的各个分类再次进行算法，&lt;strong&gt;直到所有分类中均为同一类元素，或所有特性均已使用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - trees.py - 计算香农熵&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcShannonEnt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt; 		&lt;span class=&quot;comment&quot;&gt;# Calculate the shannonEnt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numEntries = len(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	labelCounts = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; featVec &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		currentLabel = featVec[-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; currentLabel &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; labelCounts.keys():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			labelCounts[currentLabel] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		labelCounts[currentLabel] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	shannonEnt = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; labelCounts:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		prob = float(labelCounts[key])/numEntries&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		shannonEnt -= prob * log(prob,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# p(x)logp(x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; shannonEnt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - trees.py - 按给定特征划分数据集&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;splitDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, axis, value)&lt;/span&gt;:&lt;/span&gt;   	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retDataSet = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; featVec &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; featVec[axis] == value:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			reducedFeatVec = featVec[:axis]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			reducedFeatVec.extend(featVec[axis+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			retDataSet.append(reducedFeatVec)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retDataSet&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - trees.py - 选择最优数据集划分特性&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;chooseBestFeatureToSplit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;			&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numFeatures = len(dataSet[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	baseEntropy = calcShannonEnt(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bestInfoGain = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt; ; bestFeature = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numFeatures):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		featList = [example[i] &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; example &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		uniqueVals = set(featList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		newEntropy = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; value &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; uniqueVals:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			subDataSet = splitDataSet(dataSet, i ,value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			prob = len(subDataSet)/float(len(dataSet))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			newEntropy += prob * calcShannonEnt(subDataSet)		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			    &lt;span class=&quot;comment&quot;&gt;# careful, newEntropy &amp;lt; 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		infoGain = baseEntropy - newEntropy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; infoGain &amp;gt; bestInfoGain:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			bestInfoGain = infoGain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			bestFeature = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bestFeature&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - trees.py - 选择该分类的代表种类&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;majorityCnt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(classList)&lt;/span&gt;:&lt;/span&gt; 		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	classCount = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; vote &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; classList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; vote &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; classCount.keys() :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			classCount[vote] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classCount[vote] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sortedClassCount = sorted(classCount.iteritems(),\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		key = operator.itemgetter(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), reverse = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sortedClassCount[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - trees.py - 递归构建决策树&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, labels)&lt;/span&gt;:&lt;/span&gt;			&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	classList = [example[-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; example &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; classList.count(classList[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) == len(classList):		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; classList[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(dataSet[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:			&lt;span class=&quot;comment&quot;&gt;# all the features have been used&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; majorityCnt(classList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bestFeat = chooseBestFeatureToSplit(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bestFeatLabel = labels[bestFeat]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	myTree = &amp;#123;bestFeatLabel:&amp;#123;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt;(labels[bestFeat])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	featValues = [example[bestFeat] &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; example &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	uniqueVals = set(featValues)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; value &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; uniqueVals:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		subLabels = labels[:]				&lt;span class=&quot;comment&quot;&gt;# deep copy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		myTree[bestFeatLabel][value] = createTree(splitDataSet\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(dataSet, bestFeat, value), subLabels)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; myTree&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Matplotlib绘制树形图&quot;&gt;&lt;a href=&quot;#Matplotlib绘制树形图&quot; class=&quot;headerlink&quot; title=&quot;Matplotlib绘制树形图&quot;&gt;&lt;/a&gt;Matplotlib绘制树形图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;绘制代码在treePlotter.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用决策树分类&quot;&gt;&lt;a href=&quot;#使用决策树分类&quot; class=&quot;headerlink&quot; title=&quot;使用决策树分类&quot;&gt;&lt;/a&gt;使用决策树分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用构造好的决策树对输入样例进行分类。已建立好的决策树可以使用pickle保存在本地。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - trees.py - 分类函数&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inputTree, featLabels, testVec)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; firstStr = inputTree.keys()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; secondDict = inputTree[firstStr]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; featIndex = featLabels.index(firstStr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; secondDict.keys():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; testVec[featIndex] == key:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; type(secondDict[key]).__name__ == &lt;span class=&quot;string&quot;&gt;&#39;dict&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    classLabel = classify(secondDict[key], featLabels, testVec)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    classLabel = secondDict[key]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; classLabel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - trees.py - 保存和读取决策树&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;storeTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inputTree, filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pickle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(filename,&lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; fw:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  pickle.dump(inputTree, fw)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;grabTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pickle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; pickle.load(fr)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Shell - 构建隐形眼镜决策树&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fr = open(&lt;span class=&quot;string&quot;&gt;&#39;lenses.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lenses = [inst.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; inst &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines()]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lensesLabels = [&lt;span class=&quot;string&quot;&gt;&#39;age&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;prescript&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;astigmatic&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;tearRate&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lensesTree = trees.createTree(lenses, lensesLabels)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;treePlotter.createPlot(lensesTree)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;得到的决策树如下&lt;img src=&quot;http://7xqmj8.com1.z0.glb.clouddn.com/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%90%E5%BD%A2%E7%9C%BC%E9%95%9C.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ID3决策树总结&quot;&gt;&lt;a href=&quot;#ID3决策树总结&quot; class=&quot;headerlink&quot; title=&quot;ID3决策树总结&quot;&gt;&lt;/a&gt;ID3决策树总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;上述为ID3算法构造，通过熵度量信息增益。另一个度量集合无序程度的方法是基尼不纯度，从一个数据集中随机选取子项，度量其被错误分到其他分组里的概率。然而ID3构造出的决策树可能产生&lt;strong&gt;过度匹配&lt;/strong&gt;问题，即叶子结点产生的匹配过多。可以通过裁剪决策树，合并相邻的无法产生大量信息增益的叶节点消除该问题。其他算法如C4.5和CART。k-近邻算法和ID3决策树都是结果确定的分类算法，数据实例最终会被明确划分到某个分类中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Chapter-04-朴素贝叶斯&quot;&gt;&lt;a href=&quot;#Chapter-04-朴素贝叶斯&quot; class=&quot;headerlink&quot; title=&quot;Chapter 04 - 朴素贝叶斯&quot;&gt;&lt;/a&gt;Chapter 04 - 朴素贝叶斯&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;基于贝叶斯决策理论的分类，在数据较少的情况下依然有效，可以处理多类别问题，但&lt;strong&gt;对于输入数据的准备方式较为敏感&lt;/strong&gt;。适用数据类型为标称型数据。对于待测数据X，Pi(x)表示X属于类别i的概率，取最高者作为最终类别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;条件概率和朴素贝叶斯决策&quot;&gt;&lt;a href=&quot;#条件概率和朴素贝叶斯决策&quot; class=&quot;headerlink&quot; title=&quot;条件概率和朴素贝叶斯决策&quot;&gt;&lt;/a&gt;条件概率和朴素贝叶斯决策&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;条件概率：在事件x的前提下发生事件c的概率为P(c|x)，其计算公式为&lt;code&gt;P(c|x) = P(x|c)P(c)/P(x)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;朴素贝叶斯分类器的两个假设：&lt;strong&gt;朴素&lt;/strong&gt;即&lt;strong&gt;独立&lt;/strong&gt;，指一个特征或者单词出现的可能性与其他特征没有关系；&lt;strong&gt;每个特征同等重要&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;朴素贝叶斯的一般过程&lt;ul&gt;
&lt;li&gt;收集数据&lt;/li&gt;
&lt;li&gt;准备数据：标称型或布尔型数据&lt;/li&gt;
&lt;li&gt;分析数据：有大量特征时可使用直方图&lt;/li&gt;
&lt;li&gt;训练算法：计算不同的独立特征的条件概率&lt;/li&gt;
&lt;li&gt;测试算法：计算错误率&lt;/li&gt;
&lt;li&gt;使用算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用朴素贝叶斯进行文档分类：使用文档中的每个词作为特征并观察它们是否出现，假设每个特征需要N个样本，有M个特征就需要N^M个样本，若特征之间相互独立，则所需要的样本数为M*N个。对于一篇文章，计算出其对应的数据向量，计算这个向量所属各个类别的概率，并取最高者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Python-文本分类&quot;&gt;&lt;a href=&quot;#Python-文本分类&quot; class=&quot;headerlink&quot; title=&quot;Python - 文本分类&quot;&gt;&lt;/a&gt;Python - 文本分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;以在线社区的留言板为例，屏蔽侮辱性的言论。通过统计文档中出现各个单词的数量，进行频率分析并确定待测留言是否属于侮辱性言论。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 从文本构建词向量 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	postingList = [[&lt;span class=&quot;string&quot;&gt;&#39;my&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;dog&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;has&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;flea&#39;&lt;/span&gt;, \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;string&quot;&gt;&#39;problems&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;help&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;please&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				   [&lt;span class=&quot;string&quot;&gt;&#39;maybe&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;not&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;take&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;him&#39;&lt;/span&gt;, \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 &lt;span class=&quot;string&quot;&gt;&#39;to&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;dog&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;park&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;stupid&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				   [&lt;span class=&quot;string&quot;&gt;&#39;my&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;dalmation&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;is&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;so&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;cute&#39;&lt;/span&gt;, \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;string&quot;&gt;&#39;I&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;love&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;him&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				   [&lt;span class=&quot;string&quot;&gt;&#39;stop&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;posting&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;stupid&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;worthless&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;garbage&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				   [&lt;span class=&quot;string&quot;&gt;&#39;mr&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;licks&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;ate&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;my&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;steak&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;how&#39;&lt;/span&gt;, \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;string&quot;&gt;&#39;to&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;stop&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;him&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				   [&lt;span class=&quot;string&quot;&gt;&#39;quit&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;buying&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;worthless&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;dog&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;food&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;stupid&#39;&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	classVec = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; postingList, classVec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createVocabList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vocabSet = set([])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; document &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vocabSet = vocabSet | set(document)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list(vocabSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setOfWords2Vec&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vocabList, inputSet)&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 贝努利模型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	returnVec = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] * len(vocabList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; inputSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; vocabList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			returnVec[vocabList.index(word)] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the word: %s i snot in my Vocabulary!&quot;&lt;/span&gt; % word&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnVec&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 从词向量计算概率 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;trainNB0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(trainMatrix, trainCategory)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numTrainDocs = len(trainMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numWords = len(trainMatrix[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pAbusive = sum(trainCategory)/float(numTrainDocs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p0Num = ones(numWords); p1Num = ones(numWords)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p0Denom = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;; p1Denom = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;# 初始化概率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numTrainDocs):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; trainCategory[i] == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p1Num += trainMatrix[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p1Denom += sum(trainMatrix[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p0Num += trainMatrix[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p0Denom += sum(trainMatrix[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p1Vect = log(p1Num / p1Denom)    &lt;span class=&quot;comment&quot;&gt;# 取对数避免出现0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p0Vect = log(p0Num / p0Denom)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p0Vect, p1Vect, pAbusive&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 计算最大概率 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classifyNB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vec2Classify, p0Vec, p1Vec, pClass1)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p1 = sum(vec2Classify * p1Vec) + log(pClass1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p0 = sum(vec2Classify * p0Vec) + log(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; - pClass1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p1 &amp;gt; p0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 测试分类函数 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testingNB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	listOPosts, listClasses = loadDataSet()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	myVocabList = createVocabList(listOPosts)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	trainMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; postinDoc &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; listOPosts:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		trainMat.append(setOfWords2Vec(myVocabList, postinDoc))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p0V, p1V, pAb = trainNB0(array(trainMat),array(listClasses))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	testEntry = [&lt;span class=&quot;string&quot;&gt;&#39;love&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;my&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;dalmation&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	thisDoc = array(setOfWords2Vec(myVocabList, testEntry))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; testEntry, &lt;span class=&quot;string&quot;&gt;&#39;classified as: &#39;&lt;/span&gt;, classifyNB(thisDoc, p0V, p1V, pAb)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	testEntry = [&lt;span class=&quot;string&quot;&gt;&#39;stupid&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;garbage&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	thisDoc = array(setOfWords2Vec(myVocabList, testEntry))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; testEntry, &lt;span class=&quot;string&quot;&gt;&#39;classified as: &#39;&lt;/span&gt;, classifyNB(thisDoc, p0V, p1V, pAb)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文档词袋模型：在词集中，每个词出现一次和出现多次是等同的，在词袋模型中，单词出现次数对概率有影响。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bagOfWords2VecMN&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vocabList, inputSet)&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 多项式模型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	returnVec = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] * len(vocabList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; inputSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; word &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; vocabList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			returnVec[vocabList.index(word)] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnVec&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;过滤垃圾邮件&quot;&gt;&lt;a href=&quot;#过滤垃圾邮件&quot; class=&quot;headerlink&quot; title=&quot;过滤垃圾邮件&quot;&gt;&lt;/a&gt;过滤垃圾邮件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;切分文本，并使用朴素贝叶斯交叉验证。将训练集中随机选择的文件从训练集中剔除，作为测试集，称为“留存交叉验证”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 文件解析 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;textParse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(bigString)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	listOfTokens = re.split(&lt;span class=&quot;string&quot;&gt;r&#39;\W*&#39;&lt;/span&gt;, bigString)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [tok.lower() &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; tok &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; listOfTokens &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(tok) &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 垃圾邮件测试 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;spamTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    docList = []; classList = []; fullText = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		wordList = textParse(open(&lt;span class=&quot;string&quot;&gt;&#39;email/spam/%d.txt&#39;&lt;/span&gt; % i).read())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		docList.append(wordList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		fullText.extend(wordList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		classList.append(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		wordList = textParse(open(&lt;span class=&quot;string&quot;&gt;&#39;email/ham/%d.txt&#39;&lt;/span&gt; %i).read())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		docList.append(wordList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		fullText.extend(wordList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		classList.append(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	vocabList = createVocabList(docList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trainingSet = range(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;); testSet = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		randIndex = int(random.uniform(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len(trainingSet))) &lt;span class=&quot;comment&quot;&gt;# 修改trainingSet,长度随之修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		testSet.append(trainingSet[randIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		&lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt;(trainingSet[randIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trainMat = []; trainClasses = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; docIndex &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; trainingSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		trainMat.append(setOfWords2Vec(vocabList, docList[docIndex]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		trainClasses.append(classList[docIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	p0V, p1V, pSpam = trainNB0(array(trainMat),array(trainClasses))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; docIndex &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; testSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		wordVector = setOfWords2Vec(vocabList, docList[docIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    			errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;the error rate is: &#39;&lt;/span&gt;, float(errorCount)/len(testSet)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;从RSS个人广告中获取区域倾向&quot;&gt;&lt;a href=&quot;#从RSS个人广告中获取区域倾向&quot; class=&quot;headerlink&quot; title=&quot;从RSS个人广告中获取区域倾向&quot;&gt;&lt;/a&gt;从RSS个人广告中获取区域倾向&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装feedparser，从RSS源收集内容。从美国两个城市中选取一些人，通过分析这些人发布的征婚广告信息，比较两个城市的人在广告用词上是否不同。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - RSS源分类器 - 高频词分类去除 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcMostFreq&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vocabList, fullText)&lt;/span&gt;:&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;# 计算出现频率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; operator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    freqDict = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; token &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; vocabList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        freqDict[token] = fullText.count(token)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sortedFreq = sorted(freqDict.iteritems(), key = operator.itemgetter(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), reverse = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sortedFreq[:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;localWords&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(feed)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; feedparser&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    feedLen = len(feed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    docList = []; classList = []; fullText = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    minLen = min([len(feedElem[&lt;span class=&quot;string&quot;&gt;&#39;entries&#39;&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; feedElem &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; feed])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(minLen):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(feedLen):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            wordList = textParse(feed[j][&lt;span class=&quot;string&quot;&gt;&#39;entries&#39;&lt;/span&gt;][i][&lt;span class=&quot;string&quot;&gt;&#39;summary&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            docList.append(wordList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fullText.extend(wordList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            classList.append(j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vocabList = createVocabList(docList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    top30Words = calcMostFreq(vocabList, fullText)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# print top30Words&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# for pairW in top30Words:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#     if pairW[0] in vocabList: vocabList.remove(pairW[0]) # 移除高频词&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trainingSet = range(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*minLen); testSet = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        randIndex = int(random.uniform(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len(trainingSet)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        testSet.append(trainingSet[randIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt;(trainingSet[randIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trainMat = []; trainClasses = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; docIndex &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; trainingSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trainClasses.append(classList[docIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p0V, p1V, pSpam = trainNB0(array(trainMat), array(trainClasses))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; docIndex &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; testSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;the error rate is: &#39;&lt;/span&gt;, float(errorCount)/len(testSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; vocabList, p0V, p1V&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注释掉移除高频词的三行代码后，错误率为54%，保留这些代码错误率为70%。留言中出现次数最多的三十个词涵盖了所有用词的30%。通过下面的代码测试错误率。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; bayes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ny = feedparser.parse(&lt;span class=&quot;string&quot;&gt;&#39;http://newyork.craigslist.org/stp/index.rss&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;sf = feedparser.parse(&lt;span class=&quot;string&quot;&gt;&#39;http://sfbay.craigslist.org/stp/index.rss&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;vocabList, pSF, pNY = bayes.localWords(ny, sf)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;the error rate &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;vocabList, pSF, pNY = bayes.localWords(ny, sf)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;the error rate &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.35&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - 显示地域相关用词 - bayes.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getTopWords&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ny,sf)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; operator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vocabList, p0V, p1V = localWords([ny,sf])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    topNY = []; topSF = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(p0V)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p0V[i] &amp;gt; -&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt; : topSF.append((vocabList[i],p0V[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p1V[i] &amp;gt; -&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt; : topNY.append((vocabList[i],p1V[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sortedSF = sorted(topSF, key = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; pair : pair[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], reverse = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;SF**SF**SF**SF**SF&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sortedSF:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; item[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sortedNY = sorted(topNY, key = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; pair : pair[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], reverse = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;NY**NY**NY**NY**NY&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sortedNY:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; item[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;朴素贝叶斯总结&quot;&gt;&lt;a href=&quot;#朴素贝叶斯总结&quot; class=&quot;headerlink&quot; title=&quot;朴素贝叶斯总结&quot;&gt;&lt;/a&gt;朴素贝叶斯总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;贝叶斯概率和准则提供了一种利用已知值来估计未知概率的有效方法。可以通过特征之间的条件独立性假设，降低对数据量的需求。下溢出问题可以通过对概率求对数解决，词袋模型在解决文档分类问题比词集模型有所提高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/04/machinelearning1-4/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/04/machinelearning1-4/&quot;&gt;http://forec.github.io/2016/02/04/machinelearning1-4/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在自学数据挖掘和机器学习方面的内容，参考《机器学习实战》。整理笔记备忘。下面为Chapter1~Chapter4内容。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C语言的一种错误传参做法</title>
    <link href="http://forec.github.io/2015/12/28/parameter-error/"/>
    <id>http://forec.github.io/2015/12/28/parameter-error/</id>
    <published>2015-12-28T01:36:09.000Z</published>
    <updated>2015-12-28T03:00:16.168Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;多次遇过的一个错误传参做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;C-C-中的堆和栈&quot;&gt;&lt;a href=&quot;#C-C-中的堆和栈&quot; class=&quot;headerlink&quot; title=&quot;C/C++中的堆和栈&quot;&gt;&lt;/a&gt;C/C++中的堆和栈&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;栈区由编译器自动分配和释放，存放函数的参数值，局部变量值等，下面称之为系统栈，因为由编译器环境系统为其分配。 &lt;/li&gt;
&lt;li&gt;堆区由程序员通过malloc, realloc, calloc分配和释放，若程序员申请堆空间后不free，程序结束时可能由操作系统回收。堆区的内存空间分配类似数据结构中的链表和散列表结合，在可用的内存/虚拟内存空间中寻找一块足够大的、满足malloc等分配函数要求的空间，标记该块空间为已使用，并返回该块空间的首地址。&lt;/li&gt;
&lt;li&gt;全局区/静态区存放全局变量和静态变量，其中在代码中初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后该区域由系统释放。&lt;/li&gt;
&lt;li&gt;文字常量区，存放const常量、字符串等。程序结束后由系统释放。&lt;/li&gt;
&lt;li&gt;程序代码区，存放函数体的二进制代码。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;按值传递&quot;&gt;&lt;a href=&quot;#按值传递&quot; class=&quot;headerlink&quot; title=&quot;按值传递&quot;&gt;&lt;/a&gt;按值传递&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;C语言没有C++的按引用传递，要在子函数中修改父函数里声明的局部变量，需要将该变量的地址作为参数传入子函数，在子函数中通过类似(*str)的方法修改str指向的内存中存储的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个简单的测试如下&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a )&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func1(a);	&lt;span class=&quot;comment&quot;&gt;/* 传递a的拷贝 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;, a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;测试结果a=2，在调用func1时参数为&lt;strong&gt;按值传递&lt;/strong&gt;，传入的a是main函数中声明的a变量的一个拷贝，将其称为a’。在系统栈中，a属于main函数在栈中的空间，而a’属于func1在系统栈中的空间。在func1中修改a’不会影响到main函数中a的内存域。正确的传参做法应修改如下。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * a )&lt;/span&gt;&lt;/span&gt;&amp;#123;	&lt;span class=&quot;comment&quot;&gt;/* 接收的参数类型为int *，代表一个指向int型的指针，也可认为是一个指向内存中int型大小空间开头的地址 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;		&lt;span class=&quot;comment&quot;&gt;/* 将a中存储的地址指向的内存空间赋值为1，若int为4个字节，则该块内存赋值后为 0x00000001 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func1(&amp;amp;a);	&lt;span class=&quot;comment&quot;&gt;/* 传递a的地址的拷贝 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;测试结果a=1。注意此处调用func1时仍然是&lt;strong&gt;按值传递&lt;/strong&gt;，但func1接收的参数类型不再是int，而是int * ，即指向int类型空间的地址，main函数里func1(&amp;amp;a)，是传入了一份(&amp;amp;a)的拷贝。在系统栈中，&amp;amp;a指向了main函数中变量a所占的内存地址。上面正确传参做法中注释部分，&amp;amp;a其实也可以视为一个变量，这个变量的类型是int * ，是一个指向int的指针。因而向func1传入的(&amp;amp;a)的拷贝(&amp;amp;a)’，其实就相当于传入了一个int * 类型变量的拷贝。(&amp;amp;a)’和(&amp;amp;a)存的值是相同的，但它们分别占据了系统栈中不同的内存空间，如果修改上述程序如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * b )&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	a = b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;, &amp;amp;a, &amp;amp;b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func1( &amp;amp;a, &amp;amp;b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;, &amp;amp;a, &amp;amp;b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;得到的运行结果不定（在不同时间、不同计算机上执行，内存地址不同），但格式类似如下：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[forec@forec ~]$ gcc wrongparameter2.c -o t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[forec@forec ~]$ ./t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;493409228&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;493409224&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;493409228&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面运行结果说明，main函数中的&amp;amp;a在执行func1前后没有变化，这和最初给出的错误传参做法是一致的，将父函数中a的地址&amp;amp;a作为参数传入子函数，&lt;strong&gt;子函数无法修改&amp;amp;a的值（也就是main里变量a的地址），只能修改&amp;amp;a指向的内存块的值&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;错误传参测试&quot;&gt;&lt;a href=&quot;#错误传参测试&quot; class=&quot;headerlink&quot; title=&quot;错误传参测试&quot;&gt;&lt;/a&gt;错误传参测试&lt;/h1&gt;&lt;h2 id=&quot;一维数组在子函数中动态分配&quot;&gt;&lt;a href=&quot;#一维数组在子函数中动态分配&quot; class=&quot;headerlink&quot; title=&quot;一维数组在子函数中动态分配&quot;&gt;&lt;/a&gt;一维数组在子函数中动态分配&lt;/h2&gt;&lt;p&gt;下面给出一种错误的一维数组动态分配示例。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * str1)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;starting malloc str1 with 10 * int ...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	str1 = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;In func1, after malloc, the value of str1 is %d\n&quot;&lt;/span&gt;, str1 );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		str1[i] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;In func1, the value of str1[] is&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,str1[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;putchar&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * str, i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Before func1, the value of array str is&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, str[i] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;putchar&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;In main function, str is %d\n&quot;&lt;/span&gt;, str );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func1(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;After func1, str is %d\n&quot;&lt;/span&gt;, str );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;After func1, the value of array str is&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, str[i] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;putchar&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行上面的代码，运行结果如下&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Before func1, the value of &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; str is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;649909861&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32764&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;649909857&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32764&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;649909841&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32764&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In main function, str is -&lt;span class=&quot;number&quot;&gt;649916608&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;starting &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt; str1 with &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In func1, after &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;, the value of str1 is &lt;span class=&quot;number&quot;&gt;30027792&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In func1, the value of str1[] is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After func1, str is -&lt;span class=&quot;number&quot;&gt;649916608&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After func1, the value of &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; str is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;649909861&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32764&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;649909857&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32764&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;649909841&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32764&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在代码中，为了突出区分str和传给func1的str的拷贝，将func1的参数用str1表示。可以看出，str的值（str是一个int * 变量，其值就是指向的int型的指针）在func1前后都没有变化，func1函数中变化的仅仅是str的拷贝str1。因此上面代码的传参方法有误。可行的传参方法有下面两种，下面的第一种是正确的，第二种在C语言中可行，因为C语言不存在垃圾回收，但这种习惯不好，容易造成野指针。并且在支持垃圾回收的语言中，函数结束后会释放函数执行过程中产生的垃圾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可行做法1&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ** str1)&lt;/span&gt;&lt;/span&gt;&amp;#123;	&lt;span class=&quot;comment&quot;&gt;/* 要为int *类型赋值，传入int** */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;starting malloc str1 with 10 * int ...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*str1 = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;In func1, after malloc, the value of str1 is %d\n&quot;&lt;/span&gt;, *str1 );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		(*str1)[i] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;In func1, the value of str1[] is&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,(*str1)[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;putchar&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * str, i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func1(&amp;amp;str);	&lt;span class=&quot;comment&quot;&gt;/* 传入指针str所在的地址 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码和之前代码的不同之处在于，func1的接收参数变为了int &lt;em&gt;* 类型，是一个指向int型指针的指针，因此向func1传入str的地址，就可以在func1里修改str的值。在func1中，要修改main中str的值，只需要对( \&lt;/em&gt; str1)进行操作。运行结果如下。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Before func1, the value of &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; str is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1242502757&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32767&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1242502753&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32767&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1242502737&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32767&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In main function, str is -&lt;span class=&quot;number&quot;&gt;1242510416&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;starting &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt; str1 with &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In func1, after &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;, the value of str1 is &lt;span class=&quot;number&quot;&gt;28885008&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In func1, the value of str1[] is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After func1, str is &lt;span class=&quot;number&quot;&gt;28885008&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After func1, the value of &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; str is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可行做法2&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * func1( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;str&lt;/span&gt; )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;str&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;str&lt;/span&gt;, i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;str&lt;/span&gt; = func1( &lt;span class=&quot;keyword&quot;&gt;str&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为func1设一个int *类型的返回值，之所以func1对str1的修改无法影响str，是因为str1仅仅是str的拷贝。因此在func1结束时把str1返回，并赋值给str。运行结果和上面的做法1相同。&lt;/p&gt;
&lt;h2 id=&quot;二维数组在子函数中动态分配&quot;&gt;&lt;a href=&quot;#二维数组在子函数中动态分配&quot; class=&quot;headerlink&quot; title=&quot;二维数组在子函数中动态分配&quot;&gt;&lt;/a&gt;二维数组在子函数中动态分配&lt;/h2&gt;&lt;p&gt;这类错误引发的主要场景在二维数组，尤其是结构体数组的分配上。考虑下面测试代码。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ** str2)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	str2 = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;**)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;In func2, the value of str2 is %d\n&quot;&lt;/span&gt;,str2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		str2[i] = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot; The value of str2[%d] is %d\n&quot;&lt;/span&gt;, i, str2[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;And the value of the array is &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; j &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; j++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			str2[i][j] = i * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, str2[i][j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;putchar&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ** str2; 				&lt;span class=&quot;comment&quot;&gt;/* str2 is stored in stack, which was not initialized */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, j ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Before run func2, the str2 is %d\n&quot;&lt;/span&gt;, str2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func2(str2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;After run func2, return to main, the str2 is %d\n&quot;&lt;/span&gt;, str2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;str2[i] is %d\n&quot;&lt;/span&gt;, str2[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;The value of total str2 is :&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; j &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; j++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, str2[i][j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;putchar&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果如下&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Before run func2, the str2 is -&lt;span class=&quot;number&quot;&gt;1427732048&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;In func2, the value of str2 is &lt;span class=&quot;number&quot;&gt;10940432&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940528&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940576&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940624&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;23&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;26&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940672&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;33&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;34&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;35&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;36&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;37&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;38&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;39&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940720&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;41&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;43&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;44&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;47&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;49&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940768&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;51&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;53&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;54&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;55&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;57&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;58&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;59&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940816&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;61&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;62&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;63&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;65&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;66&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;67&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;68&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;69&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940864&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;70&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;71&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;73&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;74&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;75&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;76&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;77&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;78&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;79&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940912&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;81&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;82&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;83&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;84&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;85&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;86&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;87&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;89&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; The value of str2[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;] is &lt;span class=&quot;number&quot;&gt;10940960&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;And the value of the &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;91&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;92&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;93&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;94&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;95&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;96&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;97&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;98&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After run func2, &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; to main, the str2 is -&lt;span class=&quot;number&quot;&gt;1427732048&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727973&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727969&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727953&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727942&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727925&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727831&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727796&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str2[i] is -&lt;span class=&quot;number&quot;&gt;1427727780&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The value of total str2 is :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;段错误 (核心已转储)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看出，main中的str2并没有受func2执行的影响。联系上面一维数组的动态分配，可以联想到，要么让func2返回str2的值，要么传入str2的地址，而func2接收int &lt;em&gt;*&lt;/em&gt; 类型的参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确做法1&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *** str2)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*str2 = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;**)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;In func2, the value of str2 is %d\n&quot;&lt;/span&gt;,*str2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		(*str2)[i] = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)*&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot; The value of str2[%d] is %d\n&quot;&lt;/span&gt;, i, (*str2)[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;And the value of the array is &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; j &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ; j++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(*str2)[i][j] = i * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;, (*str2)[i][j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;putchar&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ** str2, i, j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	func2(&amp;amp;str2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;正确做法2&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ** &lt;span class=&quot;title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ** str2)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; str2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;headerlink&quot; title=&quot;野指针&quot;&gt;&lt;/a&gt;野指针&lt;/h2&gt;&lt;p&gt;对malloc分配的堆空间，free对应的首地址后一定要将指针变量赋为NULL。如&lt;code&gt;p = ( int * )malloc(sizeof(int) * 10)&lt;/code&gt;，若free(p)，则一定要 p = NULL，否则p指向的内存空间已经释放，而p指向了垃圾内存，成为野指针。再次调用p会引发不允许的内存访问。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2015/12/28/parameter-error/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2015/12/28/parameter-error/&quot;&gt;http://forec.github.io/2015/12/28/parameter-error/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;多次遇过的一个错误传参做法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Language" scheme="http://forec.github.io/categories/Language/"/>
    
    
      <category term="Mistakes" scheme="http://forec.github.io/tags/Mistakes/"/>
    
  </entry>
  
  <entry>
    <title>最大流（一）</title>
    <link href="http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/"/>
    <id>http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/</id>
    <published>2015-12-25T00:43:42.000Z</published>
    <updated>2015-12-25T12:10:07.334Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;简述最大流问题，给出一种解决最大流的最简单方法，及在二分图匹配中的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;流网络&quot;&gt;&lt;a href=&quot;#流网络&quot; class=&quot;headerlink&quot; title=&quot;流网络&quot;&gt;&lt;/a&gt;流网络&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;流网络G=（V，E）是一个有向图，E中的每条边（u，v）均有一个非负容量c（u，v）&amp;gt;=0，对于不属于E中的边（u，v），则c（u，v）=0。流网络中有源点s和汇点t，方便起见假设每个顶点都处在从源点s到汇点t的某条路径上，也就是说对每个V中的顶点v，都有s～&amp;gt;v~&amp;gt;t的路径存在。因此，图G为连通图，并且|E|&amp;gt;=|V|-1。流网络具备三个基本性质。&lt;ul&gt;
&lt;li&gt;容量限制：对于所有V中的顶点u,v，都有f(u,v) &amp;lt;= c(u,v)。&lt;/li&gt;
&lt;li&gt;反对称性：对于所有V中的顶点u,v，都有f(u,v) = -f(v,u)。&lt;/li&gt;
&lt;li&gt;流守恒性：对所有V中的非s、t顶点u，都有Sum{ f(u,v)，v为V中全部顶点 }= 0。&lt;br&gt;f(u,v)称为从顶点u到顶点v的流，它可以为正、负或零。流f的值的定义为|f| = Sum{ f(s,v)，v为V中所有顶点 }，也就是从源点s出发的总流量，|f|表示流的值，而不是绝对值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流网络性质的解释：容量限制说明从一个顶点到另一个顶点的网络流不能超过设定的容量。反对称性说明从顶点u到顶点v的流是其反向流的负值。流守恒性说明从非源点或非汇点的顶点出发的总网络流为0，也可以说，除s和t外，进入一个顶点的总流为0，可以阐述为流进等于流出。&lt;/li&gt;
&lt;li&gt;最大流问题：给出一个具有源点s和汇点t的流网络G，找出从s到t的最大流值。举个例子说明，下图是一个简单的流网络，从源点s到汇点t的最大流为5，将有向边想象成城市间的公路，该流网络就转化为城市间的物流问题。另外，图中不存在双向边，假如为图中权值为6的有向边配备一条“反向通道”，该反向通道的权值为3，也就是城市间可以相互运输，则可以利用&lt;strong&gt;抵消处理&lt;/strong&gt;将反向通道剔除。因为运输同一种物品，从u到v运送6个，从v到u运送3个，实质相当于从u到v运送6-3=3个，因此任意顶点间流传输问题都可以通过抵消转化为单向传输问题：只沿正向流的方向传输。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/%E6%9C%80%E5%A4%A7%E6%B5%81.jpg&quot; width=&quot;200px&quot;&gt;&lt;/li&gt;
&lt;li&gt;多个源点或多个汇点：考虑上一篇差分约束系统，我们通过构造了一个额外的源点s0得到了差分约束系统的最短路模型。在最大流问题中，如果出现多个源点或者多个汇点，可以为其增加一个超级源点s0或超级汇点t0,并将s0和所有源点si相连，权值为正无穷，将所有汇点ti和超级汇点t0相连，权值为正无穷。问题就转化为从超级源点s0到超级汇点t0的最大流问题。&lt;/li&gt;
&lt;li&gt;隐含求和记号简化流网络的表达：使用函数f，f的任意自变量都可以是顶点的集合，表示的值为自变量代表的元素所有可能求和情况，例如f(X,Y) = Sum{ f(x,y) ，x in X and y in Y }。因此流守恒可以表示为f(u,V) = 0，流的值|f| = f(s,V) = f(V,t)。对于下面几个恒等式，建议参考基尔霍夫第一第二定律证明。（1）对于所有的X包含于V，f(X, X) = 0，（2）对所有X，Y包含于V，f(X, Y) = -f(Y,X)，（3）对所有X,Y,Z包含于V，其中X and Y = None，有&lt;code&gt;f(X or Y, Z) = f(X, Z)+f(Y, Z)&lt;/code&gt;，&lt;code&gt;f(Z, X or Y) = f(Z, X)+f(Z, Y)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Ford-Fulkerson方法&quot;&gt;&lt;a href=&quot;#Ford-Fulkerson方法&quot; class=&quot;headerlink&quot; title=&quot;Ford-Fulkerson方法&quot;&gt;&lt;/a&gt;Ford-Fulkerson方法&lt;/h1&gt;&lt;h2 id=&quot;方法解释和定理&quot;&gt;&lt;a href=&quot;#方法解释和定理&quot; class=&quot;headerlink&quot; title=&quot;方法解释和定理&quot;&gt;&lt;/a&gt;方法解释和定理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最大流问题的Ford-Fulkerson方法包含多种不同运行时间的实现，其依赖于三种流网络中常见的思想：残留网络（residual network），增广路径（augmenting path）和割（cut）。Ford-Fulkerson方法是一种迭代方法，开始时对所有V中的u，v有f(u,v)=0，即初始状态时流的值为0。每次迭代可以通过寻找一条“增广路径”来增加流值。增广路径时从源点s到汇点t的一条路径，沿着该路径可以向现有流量压入更多流值。反复进行该过程，直到所有增广路径都被寻找出。后面将证明算法的正确性。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;FORD-FULKERSON-METHORD&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(G, s, t)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	initialize flow f to &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while there exists an augmenting path &lt;span class=&quot;tag&quot;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		do augment flow f along &lt;span class=&quot;tag&quot;&gt;p&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return f&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;残留网络&lt;/strong&gt;：给定一个流网络G和一个流f，该流网络在此流基础上的残留网络Gf由可以容纳更多网络流的边组成。举例来说，有一个流网络G=（V,E），源点s汇点t，设f是G中的一个流，考察V中一对顶点u，v，在不超过容量c(u,v)的条件下，从u到v可以压入额外的网络流量，就是(u,v)的残留容量，即&lt;code&gt;cf(u,v) = c(u,v) - f(u,v)&lt;/code&gt;。在残留网络Gf中，每条残留边都能容纳一个严格为正的网络流。定义Ef为残留网络的边集，Ef中的边既可以是E中的边，也可以是它们的反向边。如果E中存在边（u，v）并且f(u,v)&lt;c(u,v)，则cf(u,v) ==&quot;&quot; c(u,v)-f(u,v)=&quot;&quot;&gt; 0，并且若f(u,v)&amp;gt;0，则f(v,u)&lt;0，此时cf(v,u) ==&quot;&quot; c(v,u)=&quot;&quot; -=&quot;&quot; f(v,u)=&quot;&quot;&gt;0，因此(u,v)的反向边(v,u)也存在于Ef中。对于一对顶点(u,v)，只有在初始网络中存在连接两个顶点的边，则残留网络中才能出现连接这两点的边，因此|Ef| &amp;lt;= 2|E|。残留网络中的流和初始网络中的流的关系为|f+f’| = |f|+|f’|。&lt;/0，此时cf(v,u)&gt;&lt;/c(u,v)，则cf(u,v)&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增广路径&lt;/strong&gt;：增广路径p是残留网络Gf中从s到t的一条简单路径，增广路径上的每条边(u, v)可以容纳从u到v的某额外正网络流。称能够沿一条增广路径p的每条边传输的网络流的最大量为p的残留容量，cf(p) = min{ cf(u,v), (u,v) in p }。在已有流f的基础上加上fp，则可以得到G的另一个流，且新流的流值更接近最大值，因为|fp|为正，|f| + |fp|&amp;gt;|f|。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流网络的割&lt;/strong&gt;：Ford-Fulkerson方法沿增广路径反复增加流，直到找到最大流。流网络G=(V,E)的割（S，T）将V划分为S和T=V-S两部分，这里的划分类似于最小生成树中的点集划分，但此处针对的是有向图而非无向图。对于一个流f，穿过割（S，T）的净流量被定义为f(S,T)，割(S,T)的容量为c(S, T)，一个网络的最小割是网络中所有割中具有最小容量的割。对于最大流问题介绍中的图片，假如将左侧的s和距离其最近的顶点划分为S，剩下的两个顶点（含t）划分为T，则通过该割的&lt;strong&gt;净流量&lt;/strong&gt;为2+3=5，2是图中最顶部顶点向t提供的流，3是s向图中最底部顶点提供的流。该割的&lt;strong&gt;容量&lt;/strong&gt;为3+1+6=10。通过割的净流量可能包括顶点间的负网络流，但割的容量完全由非负值组成，即通过割（S，T）的净流由双向的正网络流组成，用从S到T的正网络流减去从T到S的正网络流；而割（S，T）的容量仅由从S到T的边计算而得，从T到S的边在计算c（S，T）时不包含在内。可以证明，&lt;strong&gt;流经任意割的净流都是相同的，且f(S,T) = |f|&lt;/strong&gt;。证明如下：根据流守恒性，f(S-s,V) = 0，因此f(S,T) = f(S,V)-f(S,S) = f(S,V) = f(s,V)+f(S-s,V) = f(s,V) = |f|。还可以证明，&lt;strong&gt;对一个流网络G中任意流f来说，其值的上界为G的任意割的容量&lt;/strong&gt;，即|f|=f(S, T) = Sum{ f(u, v), u in S, v in T } &amp;lt;= Sum{ c(u, v), u in S, v in T } = c(S，T)。从该式可以直接得出一个结论，&lt;strong&gt;网络的最大流必定不超过此网络最小割的容量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大流最小割定理&lt;/strong&gt;：如果f是具有源点s和汇点t的流网络G=（V，E）中的一个流，则下列条件等价：（1）f是G的一个最大流，（2）残留网络Gf不包含增广路径，（3）对G的某个割（S，T），有|f|=c（S，T）。结合上面提到的网络的最大流不超过此网络最小割的容量，可以得出&lt;strong&gt;网络的最大流等于某一最小割的容量&lt;/strong&gt;。证明如下。&lt;ul&gt;
&lt;li&gt;(1)-&amp;gt;(2)：假设f是G的最大流，而Gf包含一条增广路径p，因此流的和f+fp是G的一个流，并且由增广路径的定义，f+fp的流值严格大于|f|，这与假设矛盾。&lt;/li&gt;
&lt;li&gt;(2)-&amp;gt;(3)：假设Gf不包含增广路径，即Gf不包含从s到v的路径。定义S={ v in V且Gf中从s到v存在路径 }，T=V-S。对于这样的割（S，T），s在S中，t在T中，并且对每对顶点(u, v)，都有f(u,v) = c(u,v)，否则(u,v)属于Ef，v就属于了集合S，这和前提矛盾。因此|f| = f(S, T) = c(S, T)。&lt;/li&gt;
&lt;li&gt;(3)-&amp;gt;(1)：对所有割（S，T），都有f&amp;lt;=c(S,T)，因此条件|f| = c(S, T)说明此时f是一个最大流。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本的Ford-Fulkerson算法实现&quot;&gt;&lt;a href=&quot;#基本的Ford-Fulkerson算法实现&quot; class=&quot;headerlink&quot; title=&quot;基本的Ford-Fulkerson算法实现&quot;&gt;&lt;/a&gt;基本的Ford-Fulkerson算法实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Ford-Fulkerson方法的每次迭代中，找出任意增广路径p，并把沿p每条边的流f加上其残留容量cf（p）。下面的实现中，通过更新有边相连的每对顶点间的网络流来计算最大流。如果一对顶点间在任意方向都没有边相连，则隐含假设该对顶点间的f = 0。&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FORD-FULKERSON(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;, s, t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; each edge(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;, v) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;E&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		f[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;][v] &amp;lt;- 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		f[v][&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;] &amp;lt;- 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; there exists a path p from s to t &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the residual network Gf:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;cf&lt;/span&gt;(p) &amp;lt;- min&amp;#123; &lt;span class=&quot;keyword&quot;&gt;cf&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;, v): (&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;, v) is &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; p &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; each edge(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;, v) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; p:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			f[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;][v] &amp;lt;- f[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;][v] + &lt;span class=&quot;keyword&quot;&gt;cf&lt;/span&gt;(p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			f[v][&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;] &amp;lt;- -f[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;][v]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上述基本实现方法，运行时间取决于如何确定第四行中的增广路径，如果选择不好，在边权有无理数的情况下算法可能不会终止：流的值随着求和运算不断增加，但始终无法收敛到流的最大值。若采用广度优先搜索来选择增广路径，则算法运行时间为多项式复杂度。通常情况下算法处理的问题中权值都为整数，如果是有理数可以按照一定比例转化为整数。在整数条件下，该种实现Ford-Fulkerson算法的运行时间为O(E|f&lt;em&gt;|)，其中f&lt;/em&gt;是算法求出的最大流，原因在于第7行的循环为E次，寻找一条增广路径需要的深度优先搜索为E复杂度，而while最多执行f&lt;em&gt;次，每次至少增加流值1个单位。在f&lt;/em&gt;较小时可以取得不错的运行效果，但当流网络中的最大流f*很大，例如我们将上面示例图中除了中间那条权值为1的边之外的其他边，权值都设为1000000，显然最大流为2000000,但增广路径会在权值为1的边上往返出现，因此一共要运行2000000×5次。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Edmonds-Karp算法&quot;&gt;&lt;a href=&quot;#Edmonds-Karp算法&quot; class=&quot;headerlink&quot; title=&quot;Edmonds-Karp算法&quot;&gt;&lt;/a&gt;Edmonds-Karp算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果在第四行用BFS实现对增广路径p的计算，即若增广路径时残留网络中从s到t的最短路径（每条边设为单位距离），则能改进Ford-Fulkerson的界，该种实现方法为Edmonds-Karp算法，运行时间为O(VE^2)。令R（u，v）表示每条边为单位长度的图Gf中，从u到v的最短路径长度。下证时间复杂度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对具有源点s和汇点t的流网络G=（V，E）运行Edmonds-Karp算法，对所有非源非汇点顶点v，残留网络Gf中的最短路径长度R（u，v）随着每个流的增加而单调递增&lt;/strong&gt;。假设这个顶点v的流增加引起了从s到v的最短路径的减少，下面会推出矛盾。假设f是第一次流增加之前的流，该增加导致了某个最短路径距离的减小；设f’时增加以后的流。设v是在流增加时最小距离Rf’（u，v）被减小的顶点，因此Rf’（s，v）&amp;lt; Rf（s，v）。设p=s～&amp;gt;u-&amp;gt;v是Gf’中从s到v的最短路径，因此（u，v）在Ef’中，且Rf’（s，u）=Rf’（s，v）-1。顶点u到s的距离不会因为v的流增加而减小，因此Rf’（s，u）&amp;gt;=Rf（s，u）。可以断言（u，v）不属于Ef，否则根据三角不等式有Rf（s，v）&amp;lt;=Rf（s，u）+1 &amp;lt;= Rf’（s，u）+1 = Rf’（s，v），这和假设Rf’（s，v）&amp;lt;Rf(s,v)矛盾。因此，如果有（u，v）不在Ef中而在Ef’中，只有流从v向u增加。Edmonds-Karp算法总是沿着最短路径增加流，因此Gf中从s到u的最短路径以（v，u）作为最后一条边。因此Rf（s，v）=Rf（s，u）-1&amp;lt;=Rf’（s，u）-1=Rf’（s，v）-2。因为开始假设Rf’（s，v）&amp;lt;Rf（s，v），因此假设矛盾。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对具有源点s和汇点t的一个流网络G=（V，E）运行Edmonds-Karp算法，对流进行增加的全部次数为O(VE)&lt;/strong&gt;。在一个残留网络Gf中，如果其增广路径p的残留容量是边（u，v）的残留容量，即cf（p）=cf（u，v），称此边（u，v）对增广路径p关键。在沿增广路径p增流后，路径p上的任何关键边都从残留网络中消失。此外，任何增广路径上都至少有一条关键边。下证|E|条边中每一条都可以至多|V|/2-1次成为关键边。设u，v为V中顶点，且它们之间由E中的一条边相连，由于增广路径为最短路径，因此（u，v）第一次作为关键边时，有Rf（s，v）=f（s，u）+1。一旦对流增加，边（u，v）立刻从残留网络中消失，直到从v到u的边出现增流，才会使（u，v）再次出现在增广路径上。假设此时G的流为f’，则Rf’（s，u）=Rf’（s，v）+1，又Rf（s，v）&amp;lt;=Rf’（s，v），得Rf’（s，u）=Rf’（s，v）+1&amp;gt;=Rf（s，v）+1=Rf（s，u）+2。因此对于边（u，v），从其成为关键边到再次成为关键边，源点到u的最短距离至少增加2，初始时从源点到u的距离至少为0。因此在u变为从s不可达之前，距离至多为|V|-2（排除s和t），因此在（u，v）第一次成为关键边后，至多还能成为关键边(|V|-2)/2次，总计至多|V|/2次。在残留网络中可能有O（E）对顶点间有边相连，因此全部关键边的数目规模为O（VE）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Edmonds-Karp邻接表实现&quot;&gt;&lt;a href=&quot;#Edmonds-Karp邻接表实现&quot; class=&quot;headerlink&quot; title=&quot;Edmonds-Karp邻接表实现&quot;&gt;&lt;/a&gt;Edmonds-Karp邻接表实现&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; INF &lt;span class=&quot;number&quot;&gt;0x7fffffff&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; N &lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[N][N];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; visited[N], pre[N];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; V, E, s, t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;, &amp;amp;V, &amp;amp;E);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, j, u, v, w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; E; i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d %d&quot;&lt;/span&gt;, &amp;amp;u, &amp;amp;v, &amp;amp;w );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[v][u] != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[v][u] -= w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[u][v] = w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;,&amp;amp;s, &amp;amp;t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; source, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end )&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p = end, min = INF;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ( p != source )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		min = ( min &amp;gt; &lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[pre[p]][p] ? &lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[pre[p]][p] : min );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p = pre[p];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; min;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;title&quot;&gt;BFS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; source, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end )&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt; = ( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * ) &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt; ( &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ) * V ), i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(visited, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(visited));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; front = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, rear = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;[rear++] = source;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	visited[source] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pre[source] = source;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ( front != rear )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;[front++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; V ; i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( !visited[i] &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[s][i] )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;[rear++] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				visited[i] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				pre[i] = s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( i == end)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxFlow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; source, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end )&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flow = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ( BFS( source, end ) )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cfp = cf( source, end );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		flow += cfp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p = end;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ( p != source )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[pre[p]][p] = &lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[pre[p]][p] - cfp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;[p][pre[p]] += cfp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p = pre[p];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; flow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;maxFlow:%d\n&quot;&lt;/span&gt;, maxFlow(s,t));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;转化为最大流问题的最大无向二分图匹配问题&quot;&gt;&lt;a href=&quot;#转化为最大流问题的最大无向二分图匹配问题&quot; class=&quot;headerlink&quot; title=&quot;转化为最大流问题的最大无向二分图匹配问题&quot;&gt;&lt;/a&gt;转化为最大流问题的最大无向二分图匹配问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;最大无向二分图匹配问题：给定一个无向图G=（V，E），一个匹配是编辑E的子集，令匹配为M，满足对所有V中顶点v，M中至多有一条边和v相关联。若M中有边和v关联，则称v被匹配，否则v是无匹配的。最大匹配是求解最大势的匹配，即让|M|最大。假定顶点集合V可以被划分为L和R两部分，L和R不相交，且E中的所有边均为一个顶点在L中，另一个顶点在R中，则该图为二分图。方便起见假设该图每个顶点都至少有一条关联的边。&lt;/li&gt;
&lt;li&gt;为该无向二分图建立流网络，其中最大流对应最大匹配的数量。二分图G对应的流网络G’=（V’，E’）定义如下：设源点s和汇点t不属于V，在V’中向V加入超级源点s和超级汇点t，从s引出|L|条有向边，分别指向L中的每个顶点，R中的每个顶点也均引出一条指向t的有向边。此外在G中，L和R之间的|E|条边，均在G’中成为自L指向R的|E|条有向边。&lt;strong&gt;所有边均赋予单位容量&lt;/strong&gt;。因为V中每个顶点都至少有一条关联边，因此|E|&amp;gt;=|V|/2，所以|E|&amp;lt;=|E’|=|E|+|V|&amp;lt;=3|E|，因此|E’|的规模为O(E)。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2015/12/25/Graph-Algorithms-flow/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/&quot;&gt;http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简述最大流问题，给出一种解决最大流的最简单方法，及在二分图匹配中的应用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>差分约束系统</title>
    <link href="http://forec.github.io/2015/12/24/Graph-Algorithms6/"/>
    <id>http://forec.github.io/2015/12/24/Graph-Algorithms6/</id>
    <published>2015-12-24T02:32:37.000Z</published>
    <updated>2015-12-24T07:12:39.690Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;差分约束的最短路径算法证明和解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;差分约束系统&quot;&gt;&lt;a href=&quot;#差分约束系统&quot; class=&quot;headerlink&quot; title=&quot;差分约束系统&quot;&gt;&lt;/a&gt;差分约束系统&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;差分约束系统用一个m×n的线性规划矩阵表示m个不等式，这m个不等式中共n个变量x1,x2,…,xn，每个不等式满足如下形式：xi - xj &amp;lt;= bk（1 &amp;lt;= i, j &amp;lt;= n, 1 &amp;lt;= k &amp;lt;= m），在矩阵中的表示为，每一行都有一个1和一个-1,其他元素都为0。例如&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;-1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;-1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;-1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;-1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;用上面的矩阵乘一个n×1的变量矩阵x = (xi)，使其满足一个m×1的常数矩阵（bk）。等价于找出下面8个不等式的可行解：x1 - x2 &amp;lt;= b1; x1 - x5 &amp;lt;= b2; x2 - x5 &amp;lt;= b3; x3 - x1 &amp;lt;= b4; x4 - x1 &amp;lt;= b5; x4 - x1 &amp;lt;= b6; x5 - x3 &amp;lt;= b7; x5 - x4 &amp;lt;= b8。对于bk = (0, -1, 1, 5, 4, -1, -3, -3)的一个序列，x的一个可行解为(-5, -3, 0, -1, -4)，同样，对于任意x’ = x+d，d为任意常数，x’也是该不等式组的一组解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;约束图&quot;&gt;&lt;a href=&quot;#约束图&quot; class=&quot;headerlink&quot; title=&quot;约束图&quot;&gt;&lt;/a&gt;约束图&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;观察差分约束系统的不等式，发现其与最短路径松弛操作相似。松弛操作的判断条件是d[v] &amp;lt;= d[u] + w(u, v)，差分约束方程中为xi - xj &amp;lt;= bk，因此xi &amp;lt;=&amp;gt; d[v]，xj &amp;lt;=&amp;gt; d[u]，w(u, v) &amp;lt;=&amp;gt; bk，据此建边vj-&amp;gt;vi，权值为bk，变量x1,x2,…,xn分别对应结点s1,s2,s3,…,sn。&lt;/li&gt;
&lt;li&gt;在上述图中，附加一个源点s0,将其与所有顶点相连，并将s0的所有出边权值均设为0。下面将证明，给定一个差分约束系统Ax&amp;lt;=b，设G=(V,E)为该系统对应的约束图，则如果G不包含负权环，从s0到其它各点的最短路径权值就是一组可行解，否则此系统不存在可行解。证明过程如下：当G不包含负权回路时，对于任意边(vi, vj)，根据三角不等式d[vj] &amp;lt;= d[vi] + w(vi, vj)，设d[vi] = xi， d[vj] = xj，那么xj - xi &amp;lt;= w(vi , vj)，因此满足对应边（vi, vj）的差分约束。而当G中包含负权回路时，假设负权回路为&lt;v1, v2,=&quot;&quot; ...=&quot;&quot; ,=&quot;&quot; vk=&quot;&quot;&gt;，其中v1 = vk（源点s0没有入边，不可能出现在负权环上），因此整个负权环对应如下的差分约束：x2 - x1 &amp;lt;= w(v1,v2)；x3 - x2 &amp;lt;= w(v2, v3);…;xk - xk-1 &amp;lt;= w(vk-1, vk)，将这k-1个不等式相加，则左边为0,而右边是负数，矛盾。因此不存在解。&lt;/v1,&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;最大解与最小解&quot;&gt;&lt;a href=&quot;#最大解与最小解&quot; class=&quot;headerlink&quot; title=&quot;最大解与最小解&quot;&gt;&lt;/a&gt;最大解与最小解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;当差分约束条件给出其中一个解xi，即固定解的一个元素，求解的其他元素所能取到的最大解或最小解。在约束图的创建中，我们将从源点引出的边权值都赋为0,其实隐含着：d[vi] - d[v0] &amp;lt;= 0这样的条件，因此求出的解一定小于等于零，如果我们把s0也看作一个变量x0,那么上面例子中的解就是(0, -5, -3, 0, -1, -4)，也就是预先指定了x0的解为0。这里的x0就是源点s0的偏移量，例如当题中增加条件，要求解的所有元素都小于某个值，此时只要将该值设置为s0的偏移量即可。&lt;/li&gt;
&lt;li&gt;对于这类有一个未知数已经定死的情况，还有一个性质：通过最短路径算法求出的一组解是所有解中的最大值。考虑到Bellman-Ford等单源最短路径算法的初始化都是d[vi] = 正无穷，通过各种约束条件使d[vi]的值不短减小来满足，因此当所有约束条件都满足，无法松弛任意边时，求出的解就是最大解。同样，如果要求所求得的解是所有解中的最小解，只要将问题转化为求解最长路径，松弛条件变为d[v] &amp;gt;= d[u] + w(u, v)，此时的不等式变为xj - xi &amp;gt;= -bk，因此建边vi-&amp;gt;vj，权值为-bk，求其最长路径，即为最小值。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2015/12/24/Graph-Algorithms6/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2015/12/24/Graph-Algorithms6/&quot;&gt;http://forec.github.io/2015/12/24/Graph-Algorithms6/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;差分约束的最短路径算法证明和解释。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="http://forec.github.io/2015/12/23/Graph-Algorithms5/"/>
    <id>http://forec.github.io/2015/12/23/Graph-Algorithms5/</id>
    <published>2015-12-23T02:20:51.000Z</published>
    <updated>2015-12-23T14:27:21.201Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;分析图论中各类最短路径问题的算法设计，给出Bellman-Ford，Dijkstra，SPFA和Floyd-Warshall算法描述和代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;问题分类&quot;&gt;&lt;a href=&quot;#问题分类&quot; class=&quot;headerlink&quot; title=&quot;问题分类&quot;&gt;&lt;/a&gt;问题分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;最短路径问题中，给出的是一个带权有向图G=（V，E），无向图可以认为是双向的有向图。加权函数w：E-&amp;gt;R为从边到实型权值的映射，路径p=&lt;v0,v1,...,vk&gt;的权指其组成边的所有权值之和。定义从u到v的最短路径为所有从u到v的路径中权值最小的路径，若不存在从u到v的路径则权值为正无穷。&lt;/v0,v1,...,vk&gt;&lt;/li&gt;
&lt;li&gt;单源最短路径及其变体&lt;ul&gt;
&lt;li&gt;单源最短路径：已知图G=（V，E），求从V中某个给定源点s到V中的其他所有顶点的最短路径。&lt;/li&gt;
&lt;li&gt;单终点最短路径：将E反向，转化为单源最短路径。&lt;/li&gt;
&lt;li&gt;单对顶点最短路径问题：对于某对给定顶点（u，v），找出u到v的最短路径。通常解决办法为找到u的单源最短路径。&lt;/li&gt;
&lt;li&gt;每对顶点间最短路径问题：对每个顶点求单源最短路径，或采用Floyd-Warshall。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;算法设计&quot;&gt;&lt;a href=&quot;#算法设计&quot; class=&quot;headerlink&quot; title=&quot;算法设计&quot;&gt;&lt;/a&gt;算法设计&lt;/h1&gt;&lt;h2 id=&quot;可能情况分析&quot;&gt;&lt;a href=&quot;#可能情况分析&quot; class=&quot;headerlink&quot; title=&quot;可能情况分析&quot;&gt;&lt;/a&gt;可能情况分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最短路径的算法很明显依赖于最优子结构性质：假设当前求出了（u，v）的最短路径p，并且p上有两个中间节点（u’，v’），则u’到v’的最短路径一定是路径p上从u’到v’的路径。即：&lt;strong&gt;最短路径的子路径是最短路径&lt;/strong&gt;。证明采用反证法。&lt;/li&gt;
&lt;li&gt;假设你有两个传送门u和v，穿过一个传送门就可以到达另一个传送门的位置，并且从u到v会倒退时间t1,从v到u会前进时间t2，t1&amp;gt;t2。此时你就可以无止境的穿越到过去的任意一个时间点，也就是说从u到v和从v到u均有路径，并且路径权值（从u到v和从v到u穿过传送门所需的时间之和t1+t2）是负数。此时形成了负权环，称其为负权回路（&lt;strong&gt;回路上的权值之和为负数&lt;/strong&gt;，而不一定每条权值均为负数），负权回路上的最短路径是没有意义的，只要不停在u和v两点间穿梭，就可以让权值变为负无穷。但是，假如t2&amp;gt;t1，此时只能任意穿越到未来，也就是说当负权路径存在但不存在负权回路时，不影响最短路径算法的求解。&lt;/li&gt;
&lt;li&gt;回路问题：图G=（V，E）的任意一条无环路径至多包含|V|个不同的顶点，以及|V|-1条边。最短路径一定不能包含负权回路，同样也不能包含正权回路：假设最短路径上存在正权回路，则将该回路从路径中移除后，路径权值减小，但仍满足u-&amp;gt;v。&lt;h2 id=&quot;数据的记录和操作的实现&quot;&gt;&lt;a href=&quot;#数据的记录和操作的实现&quot; class=&quot;headerlink&quot; title=&quot;数据的记录和操作的实现&quot;&gt;&lt;/a&gt;数据的记录和操作的实现&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;通常情况下最短路径的目的不仅在于其路径权值大小，还在于路径自身如何行走。最短路径的记录方法可以联想到链式结构，采用前趋数组p[v]记录到达v的前一个顶点。打印路径时，从v开始逆向打印，直到遇到源点s。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;松弛技术&lt;/strong&gt;：对每个顶点v，均设置一个属性d[v]，在求解过程中描述从源点s到v的最短路径上权值的上界，求解结束后就是最短路径的权值，称为最短路径估计。初始化d[v]全部为正无穷，p[v]全部为nil（空）。d[s]=0（源点到自身的距离为0）。在求最短路径过程中，总是不停使用一种替换策略来寻求更小权值：当迄今为止找到的d[v]（s到v的权值）小于d[u]+w(u,v)时，就应当松弛边（u，v）。因此松弛操作要测试是否可以通过u来更新迄今为止所找到的v的最短路径。每次松弛操作可以减小最短路径估计，并更新前缀p[v]。下面的伪代码给出了对边（u，v）的松弛操作。&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RELAX(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;, v, w)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;[v] &amp;gt; &lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;] + &lt;span class=&quot;literal&quot;&gt;w&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;,v)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   then &lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;[v] &amp;lt;- &lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;] + &lt;span class=&quot;literal&quot;&gt;w&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;,v)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   		p[v] = &lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正确性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角不等式：当最短路径求出后，对任意边(u,v)属于E，有d[v] &amp;lt;= d[u] + w(u,v)。&lt;/li&gt;
&lt;li&gt;上界性质：在求解最短路径过程中，对任意顶点v属于V，都有d[v] &amp;gt;= MinPath(s,v)，这里用MinPath(s,v)代表从s到v实际的最短路径。一旦d[v]到达MinPath(s,v)，就不再改变。&lt;/li&gt;
&lt;li&gt;无路径性质：若从s到v不存在路径，则d[v] = MinPath(s,v) = 正无穷。&lt;/li&gt;
&lt;li&gt;收敛性质：若s ~&amp;gt; u -&amp;gt; v是图G中从s到u和v的最短路径，并且在松弛边（u，v）之前有d[u] = MinPath(s,u)，松弛操作后都有d[v] = MinPath(s,v)。&lt;/li&gt;
&lt;li&gt;前趋子图性质：对于所有的v，一旦d[v] = MinPath(s,v)，则前趋子图就是一个以s为根的最短路径树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;单源最短路径&quot;&gt;&lt;a href=&quot;#单源最短路径&quot; class=&quot;headerlink&quot; title=&quot;单源最短路径&quot;&gt;&lt;/a&gt;单源最短路径&lt;/h1&gt;&lt;h2 id=&quot;Bellman-Ford&quot;&gt;&lt;a href=&quot;#Bellman-Ford&quot; class=&quot;headerlink&quot; title=&quot;Bellman-Ford&quot;&gt;&lt;/a&gt;Bellman-Ford&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;经过算法分析可知，松弛操作是求解最短路径的核心。需要解决的是如何通过多次松弛操作得到最短路径。&lt;/li&gt;
&lt;li&gt;在算法分析的第一步，得到最短路径问题满足最优子结构，因此整个求解的过程是不断完善的，也就是在已经求解出的d[u]基础上更新更多的结点。因此思路可以按层次或按步骤展开。&lt;/li&gt;
&lt;li&gt;Bellman-Ford算法：初始化在算法分析中，伪代码如下&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BELLMAN_FORD(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;, w, s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    INITIALIZE_SINGLE_SOURCE(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;,s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i from 1 to |V(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;)|-1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; each edge(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;,v) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;E&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            RELAX(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;, v, w)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; each edge(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;,v) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;E&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;[v] &amp;gt; &lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;] + &lt;span class=&quot;literal&quot;&gt;w&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;,v):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; FALSE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TRUE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行过程：第一行初始化d和p数组，第2~4行，对每条边都进行松弛操作，并重复该过程|V(G)|-1次，结束后即可得最短路径。5~7行，判断得到的最短路径是否满足要求，即判断图中是否存在负权回路，存在则返回false，否则返回true。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第2~4行的操作中，共对所有边重复松弛了|V|-1次。理解如下：在第一次对所有边 的松弛中，得到了源点到所有最短路径长度为1的点的最短路径，也就是说，如果s~&amp;gt;v的实际最短路径长度仅为一条边，则经过第一次循环的松弛操作，该最短路径就已经确定。第二次循环，在第一次循环已经确定的最短路基础上，可以得到源点到所有最短路径长度为两条边的点的最短路径。算法分析中已经得到，图G=（V，E）的任意无环路径最多只能有|V|-1条边，因此经过|V|-1次循环后，可以得到源点到所有顶点的最短路径。&lt;/li&gt;
&lt;li&gt;在第5~7行的操作中，如果发现某条边还可以继续松弛，意味着2~4行求出的最短路径还可以更短，这就违背了算法分析中的收敛性质。因此存在负权环，返回FALSE。&lt;/li&gt;
&lt;li&gt;BELLMAN-FORD算法可以求解图中存在负权的情况，对负权环的存在可以报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Dijkstra算法&quot;&gt;&lt;a href=&quot;#Dijkstra算法&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra算法&quot;&gt;&lt;/a&gt;Dijkstra算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Bellman-Ford算法的时间复杂度为O(VE)，Dijkstra算法可以将时间复杂度提升到O(V^2)，利用二叉最小堆实现优先队列进行维护则可以提升到O((V+E)lgV)，利用斐波那契堆可以将运行时间提升到O(VlgV+E)。&lt;/li&gt;
&lt;li&gt;回顾求解最小生成树的Prim算法，在初始化阶段设置了一个集合S’只含任意一个结点，用来标记已在最小生成树中的结点，每次从顶点集合V-S’中取出一个顶点，该顶点满足：在所有V-S’的顶点中，该顶点到S’中的顶点距离最小。重复这个过程|V|-1次就可以得到最小生成树。参照这种思想设计Dijkstra算法。&lt;/li&gt;
&lt;li&gt;Bellman-Ford算法可以理解为按层次展开。由Prim算法，推测Dijkstra则是按集合划分的“最短路径子图”（自己乱起的名字），初始状态该子图G’只包含源点s，每个计算周期后，向该集合增加一个结点u，并且源点到这个集合的所有结点的最短路径均已求出。这样重复n-1次后即可求出所有结点的最短路径。&lt;/li&gt;
&lt;li&gt;如何实现上述推测：&lt;br&gt;上述操作的可行性，可以通过数学归纳法证明：（1）初始化状态下，s到s的最短路径为nil。（2）假设在第k次操作后，G’中含有k+1个结点，除s外还有k个结点，且s到这k个结点的最短路径已经求出。在第k+1次操作中，如何求出应该加入到G’的下一个结点？考虑到Bellman-Ford算法对所有边的|V|-1次松弛操作，当对所有边进行第一次松弛操作后，就已经求出了到源点s最短路径仅含1条边的点集。因此在Dijkstra算法的&lt;strong&gt;第k次操作中&lt;/strong&gt;，利用加入的第k个结点对剩下的结点中与其直接相连的结点进行松弛操作，就可以得到&lt;strong&gt;基于已求出最短路径的前k个结点的最短路径估计&lt;/strong&gt;。也就是，此时V-G’中的顶点的最短路径估计，都已经完全利用了前k个结点的最短路径（在第i次操作中利用了加入的第i个结点）。因此V-G’中顶点最短路径估计最小的顶点，就是k+1次操作需要加入的结点。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;伪代码：&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DIJKSTRA(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;, w, s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	INITIALIZE_SINGLE_SOURCE(&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;,s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	S &amp;lt;- Nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Q &amp;lt;- V[&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; Q != Nil:		# Q为剩余未加入&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;’的顶点，Q=V-&lt;span class=&quot;keyword&quot;&gt;G&lt;/span&gt;’&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  &lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt; &amp;lt;- EXTRACT-&lt;span class=&quot;literal&quot;&gt;MIN&lt;/span&gt;(Q)	# 选出Q中最短路径估计最小的顶点，用优先队列维护&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  S &amp;lt;- S | &amp;#123;&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; each vertex v &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Adj[&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;]:	# 与&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;有直接边相连的顶点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  	  RELAX(&lt;span class=&quot;keyword&quot;&gt;u&lt;/span&gt;, v, w)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要注意的是，Dijkstra算法的正确性是依赖于：更长的最短路径是从短的最短路径发展而来的，例如s~&amp;gt;v的路径是从s~&amp;gt;u维护出来的，存在的问题在于&lt;strong&gt;短的最短路径一旦确定就不能修改&lt;/strong&gt;。而Dijkstra总是选择&lt;strong&gt;当前能连到的V-G’中最近的顶点&lt;/strong&gt;插入集合G’中，即使用了贪心策略。想象一个图：一共三个顶点1、2、3，1到2距离为3，1到3距离为4，而3到2距离为-2。在Dijkstra算法运算后，1到2、3的距离分别为3和4，而实际上1到2的距离应该为2。尽管在G’中有了1、2后，插入3会重新松弛与3相连的边，但Dijkstra不允许对已经在G’中的结点松弛（如果松弛成功，此前已经确定的最短路径都会发生改变，则算法是错误的）。因此&lt;strong&gt;Dijkstra不能处理存在负权边的图&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SPFA&quot;&gt;&lt;a href=&quot;#SPFA&quot; class=&quot;headerlink&quot; title=&quot;SPFA&quot;&gt;&lt;/a&gt;SPFA&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由Bellman-Ford和Dijkstra衍生的Priority Queue-Based Bellman-Ford，国内ACM称为SPFA，与Dijkstra区别在于一个结点能否多次入队。可以处理负权边，适合临接表存储，是Bellman-Ford的优化。又可以看做是BFS的多次入队算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Bellman-Ford无论是否已求出最短路径，一定要重复松弛所有边|V|-1次，SPFA将松弛的次数减少。Dijkstra中，一个结点一旦进入了“最短路径子图”就无法再修改其路径和权值，而在SPFA中，并不设置这样一个“写保护”的集合，仅有一个表示最短路径估计的d数组。&lt;/li&gt;
&lt;li&gt;算法流程：初始化相同，d[s]=0，设置一个队列，将源点s入队。每次从队中取出一个结点u，并用该结点松弛和其直接相连的所有边，如果发现有一条边（u，v）在松弛操作后更新，则很有可能其它顶点因为d[v]的更新而产生新的最短路径，所以要将v入队。以此循环往复，直到队列为空，整个图没有可以继续松弛的边，则SPFA结束。算法执行时需要设置一个inq数组,inq[v]表示v当前是否在队列中，以防止一个结点在队列中同时出现多次。对于图中存在负权环的情况，可以依据结点入队的次数进行判断。Bellman-Ford对所有边松弛|V|-1次后就能求得最短路径，因此如果某个顶点入队了|V|次，就意味着出现了负权环。&lt;/li&gt;
&lt;li&gt;伪代码&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;SPFA&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(G, w, s)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;INITIALIZE_SINGLE_SOURCE&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(G,s)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Queue &amp;lt;- s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while Queue is not nil:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		u &amp;lt;- Queue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;InQueueCount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(u)&lt;/span&gt;&lt;/span&gt; &amp;gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(G)&lt;/span&gt;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		   return FALSE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; each vertex v &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Adj[u]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;RELAX&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(u, v, w)&lt;/span&gt;&lt;/span&gt; and not inq[v]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   Queue &amp;lt;- v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return TRUE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;优化&quot;&gt;&lt;a href=&quot;#优化&quot; class=&quot;headerlink&quot; title=&quot;优化&quot;&gt;&lt;/a&gt;优化&lt;/h2&gt;&lt;h3 id=&quot;Dijkstra算法优化&quot;&gt;&lt;a href=&quot;#Dijkstra算法优化&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra算法优化&quot;&gt;&lt;/a&gt;Dijkstra算法优化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;二叉堆实现的优先队列优化&lt;br&gt;Dijkstra算法每次要从V-G’中选取最短路径估计最短的结点加入G’，因此可以利用优先队列对顶点集V维护，类似Prim的二叉堆维护。可以直接copy最小生成树中Prim的二叉堆部分代码。&lt;/li&gt;
&lt;li&gt;斐波那契堆实现的Dijkstra优化&lt;br&gt;目前还不会&lt;h3 id=&quot;SPFA算法优化&quot;&gt;&lt;a href=&quot;#SPFA算法优化&quot; class=&quot;headerlink&quot; title=&quot;SPFA算法优化&quot;&gt;&lt;/a&gt;SPFA算法优化&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;SLF：Small Label First，假设要加入的结点是j，队首元素为i，若d[j]&amp;lt;d[i]则将j插入队首，否则插入队尾。速度可提升15～20%。&lt;/li&gt;
&lt;li&gt;LLL：Large Label Last，假设队首元素为i，队列中的所有结点的d平均值为x，若d[i]&amp;gt;x，则将i插入队尾，查找下一元素，直到找到某一个i使得d[i]&amp;lt;=x，则将i出队进行松弛。SLF+LLL可将效率提升约50%。&lt;/li&gt;
&lt;li&gt;SPFA效率不稳定，若无负权边，通常采用Dijkstra。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;多对顶点间最短路径&quot;&gt;&lt;a href=&quot;#多对顶点间最短路径&quot; class=&quot;headerlink&quot; title=&quot;多对顶点间最短路径&quot;&gt;&lt;/a&gt;多对顶点间最短路径&lt;/h1&gt;&lt;h2 id=&quot;动态规划求解算法&quot;&gt;&lt;a href=&quot;#动态规划求解算法&quot; class=&quot;headerlink&quot; title=&quot;动态规划求解算法&quot;&gt;&lt;/a&gt;动态规划求解算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据的记录：在单源最短路径中我们采用前缀数组pre[i]记录以i为终点的最短路径上的前一个结点，在多对顶点间最短路径问题中，将此数组延伸为二维数组，用pre[i][j]记录从i到j的最短路径上，j的前趋结点。这时打印路径的方法可以用以下伪代码描述。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;PRINT_ALL_PAIRS_SHORTEST_PATH&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( pre, i, j)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;i&lt;/span&gt; = j :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   then print &lt;span class=&quot;tag&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; pre[i][j] = Nil:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 then print &lt;span class=&quot;string&quot;&gt;&quot;No path from&quot;&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;to&quot;&lt;/span&gt; j&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;PRINT_ALL_PAIRS_SHORTEST_PATH&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( pre, i, pre[i][j] )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 	  print j&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简要描述设计动态规划算法的步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述一个最优解的结构&lt;/li&gt;
&lt;li&gt;递归定义一个最优解的值&lt;/li&gt;
&lt;li&gt;按自底向上的方式计算一个最优解的值&lt;/li&gt;
&lt;li&gt;从计算出的信息中构造出一个最优解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体分析最短路径问题&lt;ul&gt;
&lt;li&gt;最短路径的结构：在单源最短路径中我们已经得到最短路径满足&lt;strong&gt;最优子结构&lt;/strong&gt;，即最短路径的所有子路径也是最短路径。&lt;/li&gt;
&lt;li&gt;最短路径问题的&lt;strong&gt;状态转移方程&lt;/strong&gt;：考虑状态转移方程，首先考虑如何通过变量表示整个递推过程，再用类似数学归纳法给出递推过程，通常用“恰好”和“至多”定义某个可递推的变量。对于i、j之间的最短路径，这条最短路径&lt;strong&gt;至多&lt;/strong&gt;包含m条边，用L(i,j,m)表示从i到j，至多包含m条边的任何路径的权值最小值。当m=0时，i = j。因此当i=j时，L(i,j,0) = 0，否则L(i,j,0)=正无穷。对于m非0情况，我们可以发现，至多包含m条边时的最短路径，要么是最多包含m-1条边的最短路径，要么是在m-1条边的最短路径的基础上计算出在m条边下的最短路径（这里用例子说明，假如L(i,j,m)不是L(i,j,m-1)，则一定是走了一条i~&amp;gt;k -&amp;gt; j的路径，根据&lt;strong&gt;最优子结构&lt;/strong&gt;，i~&amp;gt;k的路径一定是最短路径，这在推导m-1时已经得到了，因此i~&amp;gt;k的权值L(i,k,m-1)+w(k,j)就是L(i,j,m)。用递归式表达即&lt;code&gt;L(i,j,m) = min{ L(i,k,m-1) + w(k,j) }, k from 1 to n&lt;/code&gt;。这个式子包含了L(i,j,m)=L(i,j,m-1)的情况，因为w(j,j)=0。因为图G=(V,E)的任一最短路径至多只能包含|V|-1条边，因此L(i,j,|V|-1)就是任意i到j的最短路径的权值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自底向上&lt;/strong&gt;计算最短路径权值：对于一个给定的临界矩阵W，和一个已经求好的L(k-1)，可以用以下伪代码求出L(k)。&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;EXTEND_SHORTEST_PATHS(&lt;span class=&quot;keyword&quot;&gt;L&lt;/span&gt;,W)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt; &amp;lt;- rows(&lt;span class=&quot;keyword&quot;&gt;L&lt;/span&gt;)	# 顶点数目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	let &lt;span class=&quot;keyword&quot;&gt;L&lt;/span&gt;&#39; be &lt;span class=&quot;keyword&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;×&lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;matrix&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i from 1 to &lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j from 1 to &lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;L&lt;/span&gt;&#39;[i][j] = &lt;span class=&quot;keyword&quot;&gt;INF&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k from 1 to &lt;span class=&quot;keyword&quot;&gt;n&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&lt;span class=&quot;keyword&quot;&gt;L&lt;/span&gt;&#39;[i][j] = &lt;span class=&quot;literal&quot;&gt;min&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;L&lt;/span&gt;[i][k] + &lt;span class=&quot;literal&quot;&gt;w&lt;/span&gt;(k,j) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;L&lt;/span&gt;&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，可以加上一重循环，求出L(m)。时间复杂度O(V^4)。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;SLOW-ALL-PAIRS-SHORTEST-PATHS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(W)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	n &amp;lt;- &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(W)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Let &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; = W&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; m from &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; to n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(m)&lt;/span&gt;&lt;/span&gt; &amp;lt;- &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;EXTEND-SHORTEST-PATHS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( L(m-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;, W )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(m-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与矩阵乘法相结合：&lt;br&gt;考虑两个矩阵A和B相乘C = A·B，对与i，j=1,2,…,n，计算c(ij) = Sum( a(ik)·b(kj) , k from 1 to n )，记此式为&lt;em&gt;‘。上面给出的递推公式，作如下替换：l(m-1) -&amp;gt; a，w -&amp;gt; b， l(m) -&amp;gt; c， + -&amp;gt; · ， min -&amp;gt; + ，则得到了式&lt;/em&gt;‘。因此，EXTEND_SHORTEST_PATHS(A,B)实际返回的是A·B，因此L(1) = L(0)·W， L(2) = L(1)·W = W^2，…，L(n-1) = L(n-2)·W = W^(n-1)。&lt;/li&gt;
&lt;li&gt;改进运行时间：对矩阵的乘方作快速幂运算。改进后的时间复杂度为O(V^3·lgV)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Floyd-Warshall&quot;&gt;&lt;a href=&quot;#Floyd-Warshall&quot; class=&quot;headerlink&quot; title=&quot;Floyd-Warshall&quot;&gt;&lt;/a&gt;Floyd-Warshall&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;同样是动态规划算法，利用了最短路径结构的另一个特点，不同于基于矩阵乘法算法中的特征。Floyd考虑最短路径上的中间结点，对于一条从u到v的简单路径（不含环）p，中间结点是p上除了u和v之外的其他结点。此算法应用广泛，在群论中用于计算传递闭包，图论中还可用于计算最大流。&lt;/li&gt;
&lt;li&gt;Floyd-Warshall算法基于以下最优子结构：将G的V个顶点编号为1,2,3,…,V，任意一对顶点(i,j)，考虑从i到j并且所有中间结点都属于集合{1,2,3,…,k}的路径，并设p是这些路径中的最短路径，则可推导出“从i到j并且所有中间结点都属于集合{1,2,3,…,k,k+1}的最短路径p’”。推导过程如下：假设顶点k+1不是路径p’的中间结点，则p’的所有中间结点都在集合{1,2,3,…,k}中，因此p’=p。假设顶点k+1是路径p’的中间结点，则可将p’分解为i~&amp;gt;k+1, k+1~&amp;gt;j，分别记为p1和p2，根据最短路径最优子结构，p1和p2分别是从i到k+1和从k+1到j的最短路径，p1和p2的中间结点均属于{1,2,3,…,k}。&lt;/li&gt;
&lt;li&gt;递归解：记D(i,j,k)为上述的p的权值，则k=0时有D(i,j,k) = w(i,j)，k非0时有D(i,j,k) = min{ D(i,j,k-1), d(i,k,k-1) + d(k,j,k-1) }。根据该方程，我们知道D(i,j,k)的值从D(i,j,k-1)推出，因此&lt;strong&gt;D(i,j,k-1)必须在D(i,j,k)之前计算&lt;/strong&gt;。因此将k放在伪代码的最外层循环。伪代码如下。&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;FLOYD-WARSHALL&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(W)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	n &amp;lt;- &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;rows&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(W)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;lt;- W&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k from &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to n:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;i&lt;/span&gt; from &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to n:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j from &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to n:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i,j,k)&lt;/span&gt;&lt;/span&gt; = min ( &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i,j,k-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; , &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i,k,k-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;+&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(k,j,k-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h1&gt;&lt;h2 id=&quot;Dijkstra-堆优化&quot;&gt;&lt;a href=&quot;#Dijkstra-堆优化&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra+堆优化&quot;&gt;&lt;/a&gt;Dijkstra+堆优化&lt;/h2&gt;&lt;h2 id=&quot;SPFA-SLF-LLL&quot;&gt;&lt;a href=&quot;#SPFA-SLF-LLL&quot; class=&quot;headerlink&quot; title=&quot;SPFA+SLF+LLL&quot;&gt;&lt;/a&gt;SPFA+SLF+LLL&lt;/h2&gt;&lt;h2 id=&quot;Floyd-Warshall-1&quot;&gt;&lt;a href=&quot;#Floyd-Warshall-1&quot; class=&quot;headerlink&quot; title=&quot;Floyd-Warshall&quot;&gt;&lt;/a&gt;Floyd-Warshall&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2015/12/23/Graph-Algorithms5/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2015/12/23/Graph-Algorithms5/&quot;&gt;http://forec.github.io/2015/12/23/Graph-Algorithms5/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分析图论中各类最短路径问题的算法设计，给出Bellman-Ford，Dijkstra，SPFA和Floyd-Warshall算法描述和代码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>计组与体系结构笔记（六）</title>
    <link href="http://forec.github.io/2015/11/14/Computer-Organization-Architecture6/"/>
    <id>http://forec.github.io/2015/11/14/Computer-Organization-Architecture6/</id>
    <published>2015-11-14T08:48:06.000Z</published>
    <updated>2015-12-26T14:21:24.431Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;输入/输出和存储系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;AMDAHL定律、输入-输出结构&quot;&gt;&lt;a href=&quot;#AMDAHL定律、输入-输出结构&quot; class=&quot;headerlink&quot; title=&quot;AMDAHL定律、输入/输出结构&quot;&gt;&lt;/a&gt;AMDAHL定律、输入/输出结构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;计算机系统整体性能的速度提升取决于某个特定部件本身的加速率和该部件在系统中的使用率。公式表示为 S = ( (1-f)+f/k )^-1。式中，S为系统整体性能的加速率，f表示较快部件完成的工作部分，k为新部件的加速率。例如，某计算机需要70%时间执行CPU操作和30%时间等待磁盘服务，当前有两种升级方案：10000￥使得处理器价格提高50%，或7000￥使得磁盘处理能力为当前系统的250%。若选择升级处理器，则f = 0.70，k = 1.5，S = 1 / ((1-0.7)+0.7/1.5) = 1.30；若选择升级磁盘，则f = 0.30，k = 2.5，S约为1.22。由此可看出升级处理器带来的整体性能提升更高，但考虑价格因素，对提升的每个百分点，升级CPU需要333￥，而升级磁盘只要318￥。&lt;/li&gt;
&lt;li&gt;输入/输出定义为在外部设备和由CPU、主存储器组成的主机系统之间移动编码数据的一个子系统部件。&lt;/li&gt;
&lt;li&gt;输入输出子系统包括&lt;ul&gt;
&lt;li&gt;用于I/O功能的主存储器模块&lt;/li&gt;
&lt;li&gt;提供将数据从系统中移入和移出所需要的总线通道&lt;/li&gt;
&lt;li&gt;主机和外围设备中的控制模块&lt;/li&gt;
&lt;li&gt;连接外部元件的接口、连接主机系统和外围设备的电缆等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协议&lt;/strong&gt;：在发送设备和接收设备之间交换的各种信号的具体形式和信号所代表的意义，包括命令信号、状态信号、数据传递信号。接收设备对命令和发送来的数据做出应答的协议交换称为&lt;strong&gt;握手&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;通常处理大量数据信息的外部设备都有缓冲存储器，如打印机、磁带驱动器等，缓冲器允许主机系统以尽可能快的方式将大量数据发送到外围设备中。设备控制电路负责从系统的缓冲器中提取或输入数据，例如包括在写数据时对磁盘定位，将打印头或激光术移动到下一字符位置，启动打印头，弹出打印纸等操作。&lt;/li&gt;
&lt;li&gt;磁盘和磁带属于&lt;strong&gt;持久性存储&lt;/strong&gt;，其相对易失性存储时间更长。数据在磁性介质中可以保存约5年，在光学介质中可保存大约100年。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;I-O控制方法&quot;&gt;&lt;a href=&quot;#I-O控制方法&quot; class=&quot;headerlink&quot; title=&quot;I/O控制方法&quot;&gt;&lt;/a&gt;I/O控制方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序控制的I/O&lt;/strong&gt;：系统为每个I/O设备至少分配一个专用的寄存器，CPU持续不断的监视每个寄存器，等待数据到达，该方法称为&lt;strong&gt;轮询&lt;/strong&gt;。一旦CPU检测到某个“数据就绪”的条件，就为该寄存器准备指令执行等操作。该方法的优点在于：可以通过编程控制每个外部设备的行为，改变程序就可以调整系统所控制的外部设备的数目和类型，以及轮询的权限和时间间隔。缺点在于：不断对寄存器轮询使得&lt;strong&gt;CPU持续处于繁忙等待循环&lt;/strong&gt;中，直到开始服务某个I/O请求。如果没有任何I/O任务要处理，CPU就无法从事任何有用的操作。因此程序控制的I/O最适合用于自动提款机等一些用来控制或监视外部事件的系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断控制的I/O&lt;/strong&gt;：在有数据发送需求时由外部设备通知CPU，如果没有外部设备发出服务请求来中断CPU，则CPU继续执行其他任务。通常使用CPU的标志寄存器中的一个二进制位表示中断信号，该位称为中断标志。一旦中断标志置位，操作系统就会中断正在执行的程序，并保存该程序的状态和各种可变的信息，提取请求中断的I/O设备的地址矢量。在完成I/O操作后CPU会完全恢复到中断前状态并继续执行。该方法和程序控制I/O的相似之处为：都可以对I/O服务程序进行修改以适应外部硬件的改变。许多主流操作系统均使用中断控制的I/O，为防止病毒制造者修改I/O设备地址矢量指向恶意代码，操作系统均提供了保护机制防止这类操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接存储器存取（DMA）&lt;/strong&gt;：无论何种中断控制的I/O，CPU都需要从I/O设备移入和移出数据。在这个过程中，CPU会完全运行一些类似如下为代码的指令&lt;figure class=&quot;highlight monkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WHILE&lt;/span&gt; More-input &lt;span class=&quot;literal&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ADD &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TO&lt;/span&gt; Byte-count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;IF&lt;/span&gt; Byte-count &amp;gt; Total-bytes-&lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt;-be-transferred &lt;span class=&quot;keyword&quot;&gt;THEN&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;EXIT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;ENDIF&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Place byte in destination buffer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Raise byte-ready signal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Initialize timer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;REPEAT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		WAIT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;UNTIL&lt;/span&gt; Byte-acknowledged, Timeout, &lt;span class=&quot;literal&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENDWHILE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些指令非常简单，可以使用一个专用芯片编程。如果一个系统使用DMA，则CPU不再需要执行冗长的I/O指令，仅需为DMA提供需要传输数据字节的地址、字节数以及目标I/O设备地址。CPU和DMA的通信由CPU上的专用I/O寄存器完成。DMA执行I/O操作的具体细节时，CPU会继续执行下一个任务，DMA完成后会发送一个中断请求通知CPU。&lt;br&gt; 程序控制的I/O每次传输一个字节，中断控制的I/O每次可以按字节或小数据块形式传输，具体取决于I/O设备。通常速度较慢的设备如键盘，传输相同字节数的数据要比磁盘驱动器和打印机产生更多的中断过程。DMA方法是面向数据块的I/O处理方式，只在一组字节的传输结束后才中断CPU。当DMA发出I/O完成的信号后，CPU会给出下一个要读取或写入的内存地址，而传输失败时，CPU会独自做出适当的相应，因此DMA的I/O需要很少的CPU参与。&lt;br&gt; &lt;strong&gt;DMA控制器和CPU共享存储器总线&lt;/strong&gt;，任一时刻只能有一个设备控制总线，通常I/O设备比CPU从内存中提取程序指令和数据的优先级高，因为很多I/O设备操作都限制在紧凑的时间参数内，如果特定的时间周期内没有检测到事件发生，这些I/O设备就会被强制超时休息，并中止当前I/O进程。为避免超时休息，DMA会利用平时由CPU使用的存储器周期完成I/O操作，称为&lt;strong&gt;周期窃取&lt;/strong&gt;。因为I/O趋向于在总线上产生突发式的传输，即成块成组的发送数据，在这些突发式传输的间隙，CPU会被授权访问总线。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通道控制的I/O&lt;/strong&gt;：DMA适用于小型单用户计算机，对于大型多用户计算机通常采用I/O通道的智能型DMA接口。一个或多个的I/O处理器可以控制多条不同的I/O路径，这些路径被称为通道路径。对于慢速设备如打印机，通道路径可以复用，允许几个这类设备仅通过一个控制器管理。在IBM的大型计算机中，一个多路复用的通道路径称为&lt;strong&gt;多路复用器通道&lt;/strong&gt;，而服务于磁盘控制器和其他快速设备的通道称为&lt;strong&gt;选择器通道&lt;/strong&gt;。I/O通道由一些被称为I/O处理器（IOP）的小CPU控制，IOP具有执行程序的能力，其与DMA的主要区别在于1）&lt;strong&gt;I/O处理器的智能特性&lt;/strong&gt;：能够对协议进行协商，发出各种设备命令，独立于CPU传输，CPU只负责为其创建程序指令、通知其指令所在地址。2）通道控制的I/O系统都配备单独的总线，用来格力主机和I/O操作，&lt;strong&gt;IOP只在从主存储器提取指令时才使用系统存储器总线&lt;/strong&gt;。因此通道控制的I/O通常在高吞吐量的环境中使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;磁盘技术&quot;&gt;&lt;a href=&quot;#磁盘技术&quot; class=&quot;headerlink&quot; title=&quot;磁盘技术&quot;&gt;&lt;/a&gt;磁盘技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;磁盘驱动器技术出现前，顺序存储介质如打孔卡片、磁带、纸带等是唯一可用的持久性存储介质。如果某个用户所需的数据写在磁带卷轴的尾部，必须读完整卷才能读取，并且每次只能阅读一个记录。1956年IBM公司发布第一台商用磁盘计算机，简称RAMAC，使用随机访问方法的会计和控制计算机。其使用的磁盘驱动器，每个磁盘直径24英寸，磁盘每一面只能容纳50000个7位字符，售价数百万美元。到2000年，IBM推广的磁盘直径尺寸仅为1英寸，保存1GB字节数据，平均访问时间15ms，价格低于300$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;磁盘驱动器&quot;&gt;&lt;a href=&quot;#磁盘驱动器&quot; class=&quot;headerlink&quot; title=&quot;磁盘驱动器&quot;&gt;&lt;/a&gt;磁盘驱动器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;磁盘驱动器被称为&lt;strong&gt;随机存储设备&lt;/strong&gt;，或直接存储设备。磁盘上的每个存储单元被称为&lt;strong&gt;扇区&lt;/strong&gt;，有独一无二的存取地址。这些扇区按照同心圆环的形式划分为一圈一圈的&lt;strong&gt;磁道&lt;/strong&gt;（每个同心圆环为一个磁道），每个磁道上的扇区数都相同，因此数据在磁盘中心写入的数据比磁盘边缘更加密集。有的厂商会把全部扇区制作为近似相同的容量，这样外部磁道可以放置比内部磁道更多的扇区，存储更多信息，这种方法称为&lt;strong&gt;分区位&lt;/strong&gt;，现在很少被使用，因为需要更复杂的驱动控制电路。磁道从磁盘最外的磁道0开始编号，在一条磁道分布的圆周上，&lt;strong&gt;扇区的分配顺序可能不连续&lt;/strong&gt;，这样允许驱动器电路有时间在读取下一个扇区之前处理完扇区进程的内容，这种技术称为&lt;strong&gt;交叉存储技术&lt;/strong&gt;。现代磁盘驱动器大多一次读取一条磁道，而不是一次读取一个扇区，因此交叉存储技术已经不再流行。&lt;/li&gt;
&lt;li&gt;磁盘（hard）包括控制电路和一个或多个金属/玻璃盘片，称为碟片。盘片上镀有一层薄的磁性材料薄膜，碟片堆叠在转轴上，通过一个马达带动磁盘碟片旋转，速度可达每分钟15000rpm，典型的磁盘转速为5400rpm和7200rpm。磁盘的读写头安装在一个旋转的磁盘驱动臂上，磁盘驱动臂通过其转轴上缠绕的线圈的感应磁场来进行准确定位，&lt;strong&gt;整个梳状的读写头可以向磁盘中心移动或从磁盘中心移开&lt;/strong&gt;。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/磁盘.jpg&quot; alt=&quot;磁盘扇区格式&quot;&gt;对于一个堆叠的磁盘结构，磁盘上的各个磁道上下一一对应，形成一个圆柱面。&lt;strong&gt;一组梳状的读写头每次可以访问一个柱面&lt;/strong&gt;。通常磁盘的可用面上都有一个磁头，但对于一些老式的磁盘系统特别是移动磁盘，最上层碟片的上表面和最下层磁盘的下表面常常都是不用的。&lt;strong&gt;磁盘磁头从来都不会触及磁盘的表面，而是悬浮在磁盘表面的上方&lt;/strong&gt;，之间仅仅相隔几个微米厚的空气层。当磁盘系统断电后，磁头退到一个安全的地方，这一过程称为&lt;strong&gt;停靠磁头&lt;/strong&gt;。如果读写头接触到磁盘表面，就会损坏磁盘，称为&lt;strong&gt;磁头撞损&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寻道时间&lt;/strong&gt;指磁盘驱动臂定位到指定的磁道上所需的时间。寻道时间并不包括磁头读取磁盘目录的时间。&lt;strong&gt;磁盘目录&lt;/strong&gt;将逻辑文件信息如my_story.doc，映射到对应的物理扇区位置，如第7柱面中第3表面的第72扇区。部分高性能的磁盘会在每个可用面的每个磁道上都提供一个读写头，消除了寻道时间。&lt;strong&gt;旋转延迟&lt;/strong&gt;是指读写头定位到指定的扇区所需的时间。旋转延迟和寻道时间的和为存取时间。&lt;/li&gt;
&lt;li&gt;在每次执行读写操作前都必须读取磁盘目录，由于磁盘最外层的磁道在相同面积内有最低的位密度，因此与内层磁道相比更不容易出现位错误。为保证更高的可靠性，可以把磁盘目录存放在最外层磁道，即磁道0。因此每次存取操作驱动臂都必须向外摆动到磁道0，然后回到所需数据的磁道上。随着记录技术和纠错算法发展，目前已经允许磁盘目录放到能够提供最佳性能的位置上，即最中间的磁道上。实际情况中，操作系统以群组的形式为扇区分配地址，称为&lt;strong&gt;区块&lt;/strong&gt;。每个块中扇区的数目决定了分配表的大小，如果分配的块越小，则当一个文件不能装满整个块时，浪费的空间就越小；而如果每个块中的扇区数目过少，则记录块的分配表会很大，查找速度会减慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##　软盘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软盘组织方式与硬盘相似，按照磁道和扇区寻址。区别在于软盘的磁性材料涂层附着在一个软性的聚酯塑料基片上，并且由于软盘不能像硬盘一样密封，因此软盘的数据密度和旋转速度受到很大限制。软盘的读写头必须接触到磁盘的磁表面，当读写头上有其他颗粒时，摩擦会引起磁性涂层的磨损，因此必须定期清洗磁头。软盘的组织结构和操作规范更统一。以3.5’’ 1.44MB DOS/Windows软盘为例，每个扇区含512个字节，每条磁道有18个扇区，软盘的每一面有80条磁道。扇区0为软盘的引导扇区，紧接着的是两个完全相同的&lt;strong&gt;文件分配表&lt;/strong&gt;（File Allocation Table，FAT）的副本，标准的1.44MB软盘的每个FAT大小为9个扇区长。每个区块是一个可编址的单元，1.44MB软盘中每个区块即为一个扇区。磁盘根目录占据从扇区19开始的14个扇区，每个根目录的条目占用32字节，每个根目录存储文件名、文件属性、文件时间表、文件大小、存放的起始区块编号，起始的区块编号指向FAT中的某个条目。如果某个数据文件占用多个区块，则允许追踪这个数据文件跨越的扇区链。&lt;/li&gt;
&lt;li&gt;FAT是一个简单的表结构，采用位图形式记录磁盘上每个区块的基本信息，指示区块是否处于空闲、保留、数据占用或坏区状态。因为每个1.44MB磁盘包含18×80×2 = 2880个扇区，所以每个FAT条目需要12位用来指出一个区块。实际上每个FAT条目都为16位宽，因此称为&lt;strong&gt;FAT16&lt;/strong&gt;。若一个文件跨越多个区块，则该文件的第一个FAT条目中同样包含一个转向该文件下一个FAT条目的指针。&lt;/li&gt;
&lt;li&gt;举例：假设文件占用了从扇区121开始的4个扇区，读取文件时会进行如下操作&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;FAT索引&lt;/td&gt;&lt;td&gt;120&lt;/td&gt;&lt;td&gt;121&lt;/td&gt;&lt;td&gt;122&lt;/td&gt;&lt;td&gt;123&lt;/td&gt;&lt;td&gt;124&lt;/td&gt;&lt;td&gt;125&lt;/td&gt;&lt;td&gt;126&lt;/td&gt;&lt;td&gt;127&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FAT内容&lt;/td&gt;&lt;td&gt;97&lt;/td&gt;&lt;td&gt;124&lt;/td&gt;&lt;td&gt;EOF&lt;/td&gt;&lt;td&gt;1258&lt;/td&gt;&lt;td&gt;126&lt;/td&gt;&lt;td&gt;&lt;bad&gt;&lt;/bad&gt;&lt;/td&gt;&lt;td&gt;122&lt;/td&gt;&lt;td&gt;577&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;1.读取磁盘目录查找文件起始区块121,读取第一个区块取回文件第一部分。2.读取位于区块121的FAT条目查找文件剩余部分，表中可得下一数据区块对应的FAT条目为124。3.读取区块124和相应的FAT条目，之处下一数据在126。4.读取区块126和相应的FAT条目，之处下一数据在122。5.读取区块122和对应的FAT，在下一扇区位置找到&lt;eof&gt;标志，因此结束。&lt;/eof&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;独立磁盘冗余阵列&quot;&gt;&lt;a href=&quot;#独立磁盘冗余阵列&quot; class=&quot;headerlink&quot; title=&quot;独立磁盘冗余阵列&quot;&gt;&lt;/a&gt;独立磁盘冗余阵列&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;1988年美国加州大学伯克利分校的David Patterson、Garth Gibson和Randy Katz三人发表了“廉价磁盘冗余阵列的实例”的论文，创造RAID一词，介绍了如何利用若干数量的廉价小磁盘替代大型机上的大型昂贵的单磁盘。论文中三人定义了5种类型（称为级）的RAID，每一级RAID具有不同的性能和可靠性，后来经过各厂商发展，增加了其他RAID级。更高编号的RAID层次不一定是更好的RAID系统，下面使用的编号方法保留了Berkeley命名方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;RAID Level 0：简称RAID-0，是将数据以条带形式存放在几个磁盘表面上，一个记录会占用几个磁盘表面的多个扇区，又称为磁盘跨区、块交错数据分带或磁盘分带。分带是简单的将逻辑顺序的数据进行分段，分段可以小到单一位，或某个特定大小的块。因为RAID-0不提供冗余，因此在各种RAID配置结构中，RAID-0有最佳性能，尤其在每个磁盘都有自己的独立控制器和高速缓存时。RAID-0非常廉价，但系统整体可靠性为单个磁盘期望性能的几分之一。如阵列由5个磁盘组成，每个磁盘设计寿命50000小时，则整个系统期望设计寿命50000/5 = 10000 小时。磁盘数增加，失效概率随之增加。没有冗余导致RAID-0没有容错能力，因此RAID-0的唯一好处在于性能，通常用于非关键的而又需要高速读取、写入的数据，或改变不太频繁和经常被分的数据，或低成本场合。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/RAID0.jpg&quot; alt=&quot;RAID-0&quot;&gt;&lt;/li&gt;
&lt;li&gt;RAID Level 1：称为磁盘镜像，是所有RAID级中失效保护最佳的方案，存储方式和RAID-0相同，但每次写入数据都会复制到另一组完全相同的磁盘上。这种方式的读取性能更优异，尤其在镜像盘（第二组磁盘）和住驱动器相差180度旋转时，减少一半反应时间。RAID-1适合于面向事务、高可用率的工作环境，以及高容错率的应用，如会计、工资表。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/RAID1.jpg&quot; alt=&quot;RAID-1&quot;&gt;&lt;/li&gt;
&lt;li&gt;RAID Level 2：因为RAID-1方案成本为RAID-0的两倍，因此RAID-2只是用磁盘组中的一个或几个磁盘存储其他磁盘中的数据信息。RAID-2在每个条带中只写入一位数据，而不采用任意大小的块写入数据，这样需要至少八个磁盘表面才能存放数据，另外需要一组磁盘驱动器存放纠错信息，这些纠错位由海明编码生成。如果磁盘阵列中的任何一个驱动器损坏，可以用海明驱动器重建这个驱动器。同样，如果海明驱动器出错，也可以用数据驱动器重建。然而，所有驱动器必须严格同步，并且生成海明编码的过程非常耗时。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/RAID2.jpg&quot; alt=&quot;RAID-2&quot;&gt;&lt;/li&gt;
&lt;li&gt;RAID Level 3：RAID-3同RAID-2一样，每次按照一位的方式将数据交错分配到各个驱动器的条带中，但与RAID-2不同的是，RAID-3只使用一个驱动器来保存简单的奇偶校验位，只需对每一位进行异或即可。利用这种方法可以对一个损坏的驱动器重建，例如6号驱动器损坏并要被替换，只要对其他7个数据驱动器和奇偶校验器上的数据异或即可。RAID-3需要同步操作，比RAID-1和RAID-2更经济，不适合面向事务的应用程序，更适合读写大块数据块的情况。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/RAID3.jpg&quot; width=&quot;500px&quot; alt=&quot;RAID-3&quot;&gt;&lt;/li&gt;
&lt;li&gt;RAID Level 4：RAID-4和RAID-2一样，是理论上的RAID级。使用一个奇偶校验位驱动器和一组数据磁盘，将数据写入统一大小的条带中，奇偶校验位也存储为条带。然而RAID-4使系统性能严重下降，因为数据盘对奇偶校验盘有竞争情况。假设正在处理奇偶校验块，如果有一个条带1和条带4的写入请求，在RAID-0和RAID-1时会直接写入，而RAID-4的奇偶校验则成为了瓶颈。&lt;/li&gt;
&lt;li&gt;RAID Level 5：RAID-5是所有以RAID为基础的应用系统中使用数量最多的，能够以最少的成本提供最佳的保护，改进了RAID-4，将奇偶校验位写到多个磁盘上而非一个磁盘。但在所有RAID层次中，RAID-5需要的磁盘控制器是最复杂的。图中绿色方块代表奇偶校验位。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/RAID5.gif&quot; alt=&quot;RAID-5&quot;&gt;&lt;/li&gt;
&lt;li&gt;RAID Level 6：前面所有的RAID系统只能允许最多有一个磁盘出错，但通常磁盘驱动器出错呈现成簇的倾向（寿命相同，灾难性事件）。RAID-6对每排数据使用两组纠错条带，除使用奇偶校验位外还使用Reed-Soloman纠错编码提供二层保护。RAID-6的写入性能很差，并且生成Reed-Soloman编码需要的代价很大，因此目前没有商业配置的RAID-6系统。&lt;/li&gt;
&lt;li&gt;RAID混合系统：如RAID-10，将RAID-0的分带和RAID-1的镜像结合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;数据压缩&quot;&gt;&lt;a href=&quot;#数据压缩&quot; class=&quot;headerlink&quot; title=&quot;数据压缩&quot;&gt;&lt;/a&gt;数据压缩&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;压缩系数 = 1 - 压缩后的文件大小/压缩前的文件大小 × 100%&lt;/li&gt;
&lt;li&gt;字符的熵：衡量一个消息中的信息量。如果某个符号x在一个消息中出现的概率为P(x)，则该字符的熵H = -P(x)×log(2)P(x)。整个消息的平均熵则为消息中所有n个符号的熵求和取平均。&lt;strong&gt;熵为编码一个消息所需的二进制位数建立了低限&lt;/strong&gt;。除了这个低限外的其他位不会增加信息。例如“Hello World!”中，平均的符号熵为3.022，因此低限为3.022×12个字符 = 36.26或37位，因此如果用8位ASCII编码表示，则冗余位为8×12 - 37 = 59个。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;赫夫曼编码&quot;&gt;&lt;a href=&quot;#赫夫曼编码&quot; class=&quot;headerlink&quot; title=&quot;赫夫曼编码&quot;&gt;&lt;/a&gt;赫夫曼编码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按照消息中不同字符出现的频率构成赫夫曼树，之后按照左分支标记0，右分支标记1的方式编码。这样频率最高的符号在编码中占用最少的位，并产生的是前缀编码。&lt;/li&gt;
&lt;li&gt;赫夫曼编码实际将实数集的元素映射为整数子集中的元素，因此精度上的欠缺可能使产生的编码有冗余，不能刚好使用平均熵的位数压缩。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;算术编码&quot;&gt;&lt;a href=&quot;#算术编码&quot; class=&quot;headerlink&quot; title=&quot;算术编码&quot;&gt;&lt;/a&gt;算术编码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编码方式：将实数集映射到实数集中，利用消息中符号集的概率在0和1之间分割实数轴。使用越频繁的符号，分割所得到的区间快越大。&lt;/li&gt;
&lt;li&gt;举例：“HELLO WORLD!”在该语句中共有12个字符，这些符号中出现最低的概率是1/12，其他概率都是1/12的整数倍，因此可将0到1之间的区间划分为12个部分。除了L和O之外，其他每个符号都分配了1/12的区间，符号L和O则分配了3/12和2/12的区间。区间映射关系如下表&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;符号&lt;/td&gt;&lt;td&gt;频率&lt;/td&gt;&lt;td&gt;区间&lt;/td&gt;&lt;td&gt;符号&lt;/td&gt;&lt;td&gt;频率&lt;/td&gt;&lt;td&gt;区间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;D&lt;/td&gt;&lt;td&gt;1/12&lt;/td&gt;&lt;td&gt;[0.0…0.083)&lt;/td&gt;&lt;td&gt;R&lt;/td&gt;&lt;td&gt;1/12&lt;/td&gt;&lt;td&gt;[0.667…0.750)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;E&lt;/td&gt;&lt;td&gt;1/12&lt;/td&gt;&lt;td&gt;[0.083…0.167)&lt;/td&gt;&lt;td&gt;W&lt;/td&gt;&lt;td&gt;1/12&lt;/td&gt;&lt;td&gt;[0.750…0.833)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;H&lt;/td&gt;&lt;td&gt;1/12&lt;/td&gt;&lt;td&gt;[0.167…0.250)&lt;/td&gt;&lt;td&gt;(space)&lt;/td&gt;&lt;td&gt;1/12&lt;/td&gt;&lt;td&gt;[0.833…0.917)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;3/12&lt;/td&gt;&lt;td&gt;[0.250…0.500)&lt;/td&gt;&lt;td&gt;!&lt;/td&gt;&lt;td&gt;1/12&lt;/td&gt;&lt;td&gt;[0.917…1.0)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O&lt;/td&gt;&lt;td&gt;2/12&lt;/td&gt;&lt;td&gt;[0.500…0.667)&lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;通过连续划分与符号所分配区间成比例的数值范围（0.0到1.0）来对消息进行编码。例如当前区间位置为1/8，而字母L获得了1/4的当前区间，如上表，接下来对L编码，将1/8乘以1/4得到L的新的当前区间1/32。如果下一个字符是另一个字母L，则将1/32再乘以1/4得到当前的区间值1/128。这个编码过程会一直持续下去，直到整条消息编码完成。过程可用伪代码描述。&lt;figure class=&quot;highlight vbnet&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ALGORITHM Arith_Code( Message )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HiVal &amp;lt;- &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LoVal &amp;lt;- &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;WHILE&lt;/span&gt; ( more characters &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; process )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;Char&lt;/span&gt; &amp;lt;- &lt;span class=&quot;keyword&quot;&gt;Next&lt;/span&gt; message character&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Interval &amp;lt;- Hival - Loval&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CharHival &amp;lt;- Upper interval limit &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Char&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CharLoval &amp;lt;- Lower interval limit &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Char&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        HiVal &amp;lt;- Loval + Interval * CharHival&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LoVal &amp;lt;- Loval + Interval * CharLoval&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ENDWHILE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OUTPUT ( Loval )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;END&lt;/span&gt; Arith_Code&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该过程用表格表示：&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;符号&lt;/td&gt;&lt;td&gt;区间&lt;/td&gt;&lt;td&gt;CharLoVal&lt;/td&gt;&lt;td&gt;CharHiVal&lt;/td&gt;&lt;td&gt;LoVal&lt;/td&gt;&lt;td&gt;HiVal&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;0.0&lt;/td&gt;&lt;td&gt;1.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;H&lt;/td&gt;&lt;td&gt;1.0&lt;/td&gt;&lt;td&gt;0.167&lt;/td&gt;&lt;td&gt;0.25&lt;/td&gt;&lt;td&gt;0.167&lt;/td&gt;&lt;td&gt;0.25&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;E&lt;/td&gt;&lt;td&gt;0.083&lt;/td&gt;&lt;td&gt;0.083&lt;/td&gt;&lt;td&gt;0.167&lt;/td&gt;&lt;td&gt;0.173889&lt;/td&gt;&lt;td&gt;0.180861&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;0.006972&lt;/td&gt;&lt;td&gt;0.25&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;td&gt;0.1756320&lt;/td&gt;&lt;td&gt;0.1773750&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;0.001743&lt;/td&gt;&lt;td&gt;0.25&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;td&gt;0.17606775&lt;/td&gt;&lt;td&gt;0.17650350&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O&lt;/td&gt;&lt;td&gt;0.00043575&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;td&gt;0.667&lt;/td&gt;&lt;td&gt;0.176285625&lt;/td&gt;&lt;td&gt;0.176358395&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;(space)&lt;/td&gt;&lt;td&gt;0.00007277025&lt;/td&gt;&lt;td&gt;0.833&lt;/td&gt;&lt;td&gt;0.917&lt;/td&gt;&lt;td&gt;0.1763462426&lt;/td&gt;&lt;td&gt;0.1763523553&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;W&lt;/td&gt;&lt;td&gt;0.00000611270&lt;/td&gt;&lt;td&gt;0.75&lt;/td&gt;&lt;td&gt;0.833&lt;/td&gt;&lt;td&gt;0.1763508271&lt;/td&gt;&lt;td&gt;0.1763513345&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;O&lt;/td&gt;&lt;td&gt;0.00000050735&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;td&gt;0.667&lt;/td&gt;&lt;td&gt;0.1763510808&lt;/td&gt;&lt;td&gt;0.1763511655&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;R&lt;/td&gt;&lt;td&gt;0.00000008473&lt;/td&gt;&lt;td&gt;0.667&lt;/td&gt;&lt;td&gt;0.75&lt;/td&gt;&lt;td&gt;0.1763511373&lt;/td&gt;&lt;td&gt;0.176351444&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;0.00000000703&lt;/td&gt;&lt;td&gt;0.25&lt;/td&gt;&lt;td&gt;0.5&lt;/td&gt;&lt;td&gt;0.1763511391&lt;/td&gt;&lt;td&gt;0.1763511409&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;D&lt;/td&gt;&lt;td&gt;0.00000000176&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0.083&lt;/td&gt;&lt;td&gt;0.1763511391&lt;/td&gt;&lt;td&gt;0.1763511392&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;!&lt;/td&gt;&lt;td&gt;0.00000000015&lt;/td&gt;&lt;td&gt;0.917&lt;/td&gt;&lt;td&gt;1.0&lt;/td&gt;&lt;td&gt;0.176351139227&lt;/td&gt;&lt;td&gt;0.176351139239&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt;0.176351139227&lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;
&lt;h2 id=&quot;Ziv-Lempel字典系统&quot;&gt;&lt;a href=&quot;#Ziv-Lempel字典系统&quot; class=&quot;headerlink&quot; title=&quot;Ziv-Lempel字典系统&quot;&gt;&lt;/a&gt;Ziv-Lempel字典系统&lt;/h2&gt;&lt;h2 id=&quot;JPEG压缩&quot;&gt;&lt;a href=&quot;#JPEG压缩&quot; class=&quot;headerlink&quot; title=&quot;JPEG压缩&quot;&gt;&lt;/a&gt;JPEG压缩&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2015/11/14/Computer-Organization-Architectur6/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2015/11/14/Computer-Organization-Architecture6/&quot;&gt;http://forec.github.io/2015/11/14/Computer-Organization-Architecture6/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;输入/输出和存储系统。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成与体系结构" scheme="http://forec.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
