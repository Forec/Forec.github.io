<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Forec&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://forec.github.io/"/>
  <updated>2016-02-26T13:41:06.383Z</updated>
  <id>http://forec.github.io/</id>
  
  <author>
    <name>Forec</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习笔记（Chapter 14 - SVD简化）</title>
    <link href="http://forec.github.io/2016/02/26/machinelearning14/"/>
    <id>http://forec.github.io/2016/02/26/machinelearning14/</id>
    <published>2016-02-26T13:38:59.000Z</published>
    <updated>2016-02-26T13:41:06.383Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;从数据中提取一些关键信息可以使用奇异值分解（Singular Value Decomposition，SVD），可以简化数据，去除噪声，将数据映射到低维空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;SVD应用&quot;&gt;&lt;a href=&quot;#SVD应用&quot; class=&quot;headerlink&quot; title=&quot;SVD应用&quot;&gt;&lt;/a&gt;SVD应用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;奇异值分解的优点是简化数据，去除噪声，提高算法结果，用小得多的数据集表示原始数据集，实际上是取出了噪声。缺点是数据的转换可能难以理解。适用于数值型数据。&lt;/li&gt;
&lt;li&gt;隐性语义索引（Latent Semantic Indexing，LSI）是SVD最早的应用之一。LSI中，一个矩阵是由文档和词语组成的，在该矩阵上应用SVD时，会构建出多个奇异值。这些奇异值代表了文档中的概念或主题，该特点可以用于更高效的文档搜索。在词语拼写错误或者出现同义词时，只基于词语存在与否的搜索方法会遇到问题，如果使用SVD从上千篇相似文档中抽取概念，那么同义词会被映射为同一概念。&lt;/li&gt;
&lt;li&gt;推荐系统。利用SVD从数据中构建一个主题空间，然后再在该空间下计算其相似度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;矩阵分解&quot;&gt;&lt;a href=&quot;#矩阵分解&quot; class=&quot;headerlink&quot; title=&quot;矩阵分解&quot;&gt;&lt;/a&gt;矩阵分解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;很多情况下数据中的一小段携带了数据集中的大部分信息。其他信息要么是噪声，要么是毫不相关的信息。矩阵分解可以将原始矩阵表示成新的易于处理的形式，过程类似代数中的因子分解。SVD是最常见的一种矩阵分解技术，SVD将原始数据集Data分解为三个矩阵：&lt;code&gt;U&lt;/code&gt;，&lt;code&gt;∑&lt;/code&gt;和&lt;code&gt;V^T&lt;/code&gt;，这三个矩阵分别是mxm，mxn和nxn。其中&lt;strong&gt;矩阵&lt;code&gt;∑&lt;/code&gt;只有对角元素，其他元素均为0，并且&lt;code&gt;∑&lt;/code&gt;的对角元素是从大到小排列的，这些对角元素称为奇异值&lt;/strong&gt;，它们对应了原始数据Data的奇异值。&lt;strong&gt;这里的奇异值就是矩阵&lt;code&gt;Data*Data^T&lt;/code&gt;的特征值的平方根&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在某个奇异值的数目（r个）之后，其他奇异值都置为0，这意味着数据集只有r个重要特征，其余特征都是噪声或者冗余特征。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;numpy中的linalg有一个svd方法：&lt;code&gt;U, Sigma, VT = linalg.svd(Data)&lt;/code&gt;。注意∑虽然是矩阵，但为了节约空间以array的形式返回。下面的代码(svdRec.py)展示了对样例矩阵求∑的过程。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadExData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;Data=svdRec.loadExData()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;U, Sigma, VT = linalg.svd(Data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;Sigma&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array([  &lt;span class=&quot;number&quot;&gt;9.72140007e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;5.29397912e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;6.84226362e-01&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;1.70188300e-16&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;5.01684085e-47&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从上面返回的&lt;code&gt;∑&lt;/code&gt;矩阵可以看出，前三个数值比最后两个值大了很多，因此可以将最后两个值去掉，构成一个3x3的对角矩阵&lt;code&gt;Sig3&lt;/code&gt;。若要从&lt;code&gt;U&lt;/code&gt;，&lt;code&gt;∑&lt;/code&gt;和&lt;code&gt;V^T&lt;/code&gt;中构造原始矩阵的近似矩阵，只需要用&lt;code&gt;U&lt;/code&gt;的前三列和&lt;code&gt;V^T&lt;/code&gt;的前三行。实际操作中，确定要保留的奇异值的个数有两种方法：一是将所有的奇异值map成平方和，之后从前向后叠加，直到累加到总值的90%；二是启发式策略，当矩阵有上万的奇异值时，只保留前3000个，前提是对数据有足够的了解，确保3000个奇异值足够覆盖总平方和的90%。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;Sig3 = eye(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)*Sigma[:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array([[ &lt;span class=&quot;number&quot;&gt;9.72140007&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;        ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;        ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;        ,  &lt;span class=&quot;number&quot;&gt;5.29397912&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;        ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;        ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;        ,  &lt;span class=&quot;number&quot;&gt;0.68422636&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;U[:,:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]*mat(Sig3)*VT[:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix([[  &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;number&quot;&gt;2.26272993e-16&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.25622472e-16&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;2.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.00000000e+00&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;number&quot;&gt;2.48715978e-16&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.47198095e-16&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          -&lt;span class=&quot;number&quot;&gt;1.18232247e-15&lt;/span&gt;,  -&lt;span class=&quot;number&quot;&gt;1.18297299e-15&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;5.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;5.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;5.00000000e+00&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;number&quot;&gt;2.90999863e-16&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.87530416e-16&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,  -&lt;span class=&quot;number&quot;&gt;7.77156117e-16&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;number&quot;&gt;2.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.00000000e+00&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;3.33066907e-16&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;6.10622664e-16&lt;/span&gt;,  -&lt;span class=&quot;number&quot;&gt;4.99600361e-16&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;number&quot;&gt;3.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;3.00000000e+00&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;1.04083409e-16&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.87350135e-16&lt;/span&gt;,  -&lt;span class=&quot;number&quot;&gt;1.80411242e-16&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.00000000e+00&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基于协同过滤的推荐引擎&quot;&gt;&lt;a href=&quot;#基于协同过滤的推荐引擎&quot; class=&quot;headerlink&quot; title=&quot;基于协同过滤的推荐引擎&quot;&gt;&lt;/a&gt;基于协同过滤的推荐引擎&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;协同过滤通过将用户和其他用户的数据进行对比来实现推荐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;相似度计算&quot;&gt;&lt;a href=&quot;#相似度计算&quot; class=&quot;headerlink&quot; title=&quot;相似度计算&quot;&gt;&lt;/a&gt;相似度计算&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;利用不同用户对某一件物品的评分来计算相似度。举例如下表。&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;鳗鱼饭&lt;/td&gt;&lt;td&gt;日式炸鸡&lt;/td&gt;&lt;td&gt;寿司饭&lt;/td&gt;&lt;td&gt;烤牛肉&lt;/td&gt;&lt;td&gt;手撕猪肉&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Jim&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;John&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sally&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;可以使用多种方法计算相似度。&lt;ul&gt;
&lt;li&gt;欧氏距离：计算手撕牛肉和烤牛肉的距离为&lt;code&gt;sqrt[(4-4)^2+(3-3)^2+(2-1)^2]=1&lt;/code&gt;，手撕牛肉和鳗鱼饭的距离为&lt;code&gt;sqrt[(4-2)^2+(3-5)^2+(2-2)^2=2.83&lt;/code&gt;。可以使用“相似度=1/(1+距离)”来将相似度控制在0~1之间。&lt;/li&gt;
&lt;li&gt;皮尔逊相关系数：该方法较欧氏距离的优势在于，它对用户评分的量级不敏感，例如所有评分都是5分和所有评分都是1分在这里是相同的。numpy中皮尔逊相关系数计算由&lt;code&gt;corrcoef()&lt;/code&gt;方法完成，通过&lt;code&gt;0.5+0.5*corrcoef()&lt;/code&gt;控制相似度在0~1之间。&lt;/li&gt;
&lt;li&gt;余弦相似度：对于两个向量，计算其夹角余弦值来比较相似程度。numpy中提供了&lt;code&gt;linalg.norm()&lt;/code&gt;方法用于计算单个向量的2范数（平方和取根）。因为cos在-1~1之间，同样用&lt;code&gt;0.5+0.5*cos&lt;/code&gt;来控制相似度在0~1之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上面几种相似度计算的代码如下，分别为&lt;code&gt;eulidSim&lt;/code&gt;，&lt;code&gt;pearsSim&lt;/code&gt;和&lt;code&gt;cosSim&lt;/code&gt;。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; linalg &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; la&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;eulidSim&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inA, inB)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;/(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; + la.norm(inA - inB))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pearsSim&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inA, inB)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(inA) &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;*corrcoef(inA, inB, rowvar = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cosSim&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inA, inB)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    num = float(inA.T * inB)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    denom = la.norm(inA) * la.norm(inB)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;*(num/denom)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myMat = mat(svdRec.loadExData())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.eulidSim(myMat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], myMat[:,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.13367660240019172&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.cosSim(myMat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], myMat[:,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.54724555912615336&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.pearsSim(myMat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], myMat[:,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.23768619407595826&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基于用户还是物品&quot;&gt;&lt;a href=&quot;#基于用户还是物品&quot; class=&quot;headerlink&quot; title=&quot;基于用户还是物品&quot;&gt;&lt;/a&gt;基于用户还是物品&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通过计算两种菜肴之间的距离是基于物品的相似度。另一种计算用户距离的方法是基于用户的相似度。在上面的表格示例中，行与行之间的比较是基于用户的相似度，列与列之间的比较是基于物品的相似度。使用哪一种相似度取决于用户或物品的数目。基于X的相似度计算所需的时间会随着X的增长而增长，通常如果用户数目很多并且会不断增长，我们倾向于使用基于物品的相似度计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;推荐引擎评价&quot;&gt;&lt;a href=&quot;#推荐引擎评价&quot; class=&quot;headerlink&quot; title=&quot;推荐引擎评价&quot;&gt;&lt;/a&gt;推荐引擎评价&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通常用于推荐引擎评价的指标是“最小方均根误差（RMSE）”，它计算均方误差的平均值并开根。若评级在1~5分，而RMSE的结果为1.0，说明预测值和用户给出的真实评价差了一分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;餐馆菜肴推荐引擎&quot;&gt;&lt;a href=&quot;#餐馆菜肴推荐引擎&quot; class=&quot;headerlink&quot; title=&quot;餐馆菜肴推荐引擎&quot;&gt;&lt;/a&gt;餐馆菜肴推荐引擎&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个用户，系统会为此用户选择N个最好的推荐菜。整个流程需要做到：寻找用户没有评分的菜肴，在这些没有评分的所有菜肴中，对每种菜计算一个可能的评级分数，即预测用户会对该菜肴做出的评分。最后将评分从高到低排序，返回前N个物品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;推荐没有品尝过的菜肴：两个函数，&lt;code&gt;standEst()&lt;/code&gt;用于在给定计算相似度方法的前提下，计算用户对某种物品的可能评分；&lt;code&gt;recommend()&lt;/code&gt;是推荐引擎，调用standEst函数，并返回前N个最好物品。在standEst的执行过程中，假设要计算用户u对其未打分的菜肴i的可能评分，则需要通过其他物品j和物品i建立联系。扫描所有n个物品，如果用户u对某个物品j有过评分，则寻找所有用户中即对i又对j评分过的用户群体users，根据users们的打分，计算出物品i和物品j的相似度。最后将这个相似度乘以用户u对物品j的评分累加到ratSimTotal变量，将相似度累加到simTotal变量。最后返回ratSimTotal/simTotal就是可能评分。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;standEst&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMat, user, simMeas, item)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n = shape(dataMat)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    simTotal = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;; ratSimTotal = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        userRating = dataMat[user,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; userRating == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        overLap = nonzero(logical_and(dataMat[:,item].A&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dataMat[:,j].A&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(overLap) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: similarity = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: similarity = simMeas(dataMat[overLap, item],\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dataMat[overLap, j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        simTotal += similarity&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ratSimTotal += similarity * userRating&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; simTotal == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ratSimTotal/simTotal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;recommend&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMat, user, N=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, simMeas = cosSim, estMethod = standEst)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unratedItems = nonzero(dataMat[user,:].A==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(unratedItems) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;you rated everything&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    itemScores = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; unratedItems:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        estimatedScore = estMethod(dataMat, user, simMeas, item)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        itemScores.append((item, estimatedScore))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sorted(itemScores, key=&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; k: k[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], reverse=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)[:N]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myMat = mat(svdRec.loadExData())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myMat[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=myMat[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=myMat[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=myMat[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myMat[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] =&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix([[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.recommend(myMat,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2.5&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.9703483892927431&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.recommend(myMat,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,simMeas = svdRec.eulidSim)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2.5&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.9866572968729499&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.recommend(myMat,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,simMeas = svdRec.pearsSim)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2.5&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在代码中加入&lt;code&gt;loadExData2()&lt;/code&gt;方法，利用svd处理该矩阵，分析当前矩阵可以发现前三个奇异值就已经占据总能量的90%。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;U, Sigma, VT = linalg.svd(mat(svdRec.loadExData2()))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;Sigma&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array([ &lt;span class=&quot;number&quot;&gt;15.77075346&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;11.40670395&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;11.03044558&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;4.84639758&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;3.09292055&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.58097379&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.00413543&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.72817072&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;0.43800353&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.22082113&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.07367823&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;Sig2 = Sigma**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;sum(Sig2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;541.99999999999966&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;sum(Sig2)*&lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;487.79999999999973&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;sum(Sig2[:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;378.8295595113579&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;sum(Sig2[:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;500.50028912757938&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为前三个奇异值已经包含了90%的能量，因此可以将11维数据缩减为3维。添加&lt;code&gt;svdEst&lt;/code&gt;方法用于简化数据，这里对原书代码做了一点修改，自动提取前90%能量的奇异值。评估相似度时使用的矩阵是一个nxi的矩阵，这里的i是提取的奇异值个数，n是物品数目。不同用户对物品k的评分已经被压缩到第k行的i个数据中，只要计算两个1xi向量的相似度即可。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;svdEst&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMat, user, simMeas, item)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n = shape(dataMat)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    simTotal = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;; ratSimTotal = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    U, Sigma, VT = la.svd(dataMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sumTotal = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; singular &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Sigma:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sumTotal += singular**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    singularMax = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(Sigma)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        singularMax += Sigma[i]**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; singularMax &amp;gt;= sumTotal*&lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SigI = mat(eye(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)*Sigma[:i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xformedItems = dataMat.T * U[:,:i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * SigI.I&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# n x m     m x i    i x i   =&amp;gt;     n x i&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        userRating = dataMat[user,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; userRating == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; j == item: &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        similarity = simMeas(xformedItems[item,:].T,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            xformedItems[j,:].T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;the %d and %d similarity is: %f&#39;&lt;/span&gt; % (item, j, similarity)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        simTotal += similarity&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ratSimTotal += similarity * userRating&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; simTotal == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ratSimTotal/simTotal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myMat = mat(svdRec.loadExData2())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.recommend(myMat, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, N=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, estMethod = svdRec.svdEst)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;the &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; similarity &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.485722&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;the &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; similarity &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.486944&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.3329499901459845&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.3315447178728395&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.3314474877128624&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;svdRec.recommend(myMat, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, simMeas = svdRec.pearsSim)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.3333333333333335&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.3333333333333335&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SVD在大数据集上会显著降低程序速度，可以仅在程序调入运行时离线加载一次。其中计算出的相似度是物品和物品之间的相似度，不同的用户也可以重复使用，因此可以将计算结果离线。当出现冷启动问题时，可以将推荐看成搜索问题，为物品添加标签，使用基于内容的推荐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基于SVD的图像压缩&quot;&gt;&lt;a href=&quot;#基于SVD的图像压缩&quot; class=&quot;headerlink&quot; title=&quot;基于SVD的图像压缩&quot;&gt;&lt;/a&gt;基于SVD的图像压缩&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;用一个32*32（1024像素）的矩阵表示一个图像，通过svd对该矩阵降维，实现压缩重构。运行结果太长，但基本还原了原来的矩阵（可以观察出部分像素点不同）。&lt;code&gt;U&lt;/code&gt;和&lt;code&gt;V^T&lt;/code&gt;都是32x2的矩阵，有两个奇异值，因此总数字数目为64x2+2=130，获得了几乎10倍的压缩比。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printMat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inMat, thresh=&lt;span class=&quot;number&quot;&gt;0.8&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; float(inMat[i,k]) &amp;gt; thresh:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;imgCompress&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(numSV=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, thresh=&lt;span class=&quot;number&quot;&gt;0.8&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myl = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&#39;0_5.txt&#39;&lt;/span&gt;).readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        newRow = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            newRow.append(int(line[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        myl.append(newRow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myMat = mat(myl)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;****original matrix******&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printMat(myMat, thresh)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    U,Sigma,VT = la.svd(myMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SigRecon = mat(zeros((numSV, numSV)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numSV):&lt;span class=&quot;comment&quot;&gt;#construct diagonal matrix from vector&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SigRecon[k,k] = Sigma[k]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reconMat = U[:,:numSV]*SigRecon*VT[:numSV,:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;****reconstructed matrix using %d singular values******&quot;&lt;/span&gt; % numSV&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printMat(reconMat, thresh)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;SVD总结&quot;&gt;&lt;a href=&quot;#SVD总结&quot; class=&quot;headerlink&quot; title=&quot;SVD总结&quot;&gt;&lt;/a&gt;SVD总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;SVD可以逼近矩阵并从中提取重要特征。通过保留矩阵80%~90%的能量，可以去除噪声，保留重要特征，在稀疏矩阵的压缩上作用显著。SVD的其中一个应用是推荐引擎，协同过滤基于用户喜好或者行为数据来推荐，核心是相似度计算方法，SVD可以将高维用户群体降维成少数奇异值，提高推荐引擎效果。在大规模数据集上，SVD的冗余计算会占用过多时间，可以通过离线方式SVD分解和相似度计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/26/machinelearning14/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/26/machinelearning14/&quot;&gt;http://forec.github.io/2016/02/26/machinelearning14/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从数据中提取一些关键信息可以使用奇异值分解（Singular Value Decomposition，SVD），可以简化数据，去除噪声，将数据映射到低维空间。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 13 - PCA简化）</title>
    <link href="http://forec.github.io/2016/02/25/machinelearning13/"/>
    <id>http://forec.github.io/2016/02/25/machinelearning13/</id>
    <published>2016-02-25T04:15:43.000Z</published>
    <updated>2016-02-25T04:18:10.621Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在低维下，数据更容易进行处理，其相关特征可能在数据中明确显示出来。PCA是降维技术中最广泛的一种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;降维技术&quot;&gt;&lt;a href=&quot;#降维技术&quot; class=&quot;headerlink&quot; title=&quot;降维技术&quot;&gt;&lt;/a&gt;降维技术&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;数据往往拥有超出显示能力的更多特征，简化数据不止使得数据容易显示，同时降低算法计算开销、去除噪声、使得结果易懂。&lt;/li&gt;
&lt;li&gt;主成分分析（Principal Component Analysis，PCA）将数据从原来的坐标系转移到新的坐标系，新坐标系的选择由数据本身决定，新坐标系的第一个坐标轴是原始数据中方差最大的方向，新坐标系的第二个坐标轴和第一个坐标轴正交、并且具有最大方差。该过程一直重复，次数为原始数据中维度。大部分方差都包含在前面几个新坐标轴中，因此可以忽略剩下的坐标轴。&lt;/li&gt;
&lt;li&gt;因子分析（Factor Analysis）假设观察数据的生成中有一些观察不到的隐变量，即观察数据是由这些隐变量和某些噪声的线性组合，那么隐变量的数据可能比观察数据的数目少，找到隐变量就可以实现数据的降维。&lt;/li&gt;
&lt;li&gt;独立成分分析（Independent Component Analysis，ICA）假设数据从N个数据源生成，类似因子分析，假设这些数据源之间在统计上相互独立，如果数据源数目少于观察数据数目，就实现降维过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;PCA&quot;&gt;&lt;a href=&quot;#PCA&quot; class=&quot;headerlink&quot; title=&quot;PCA&quot;&gt;&lt;/a&gt;PCA&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;PCA可以降低数据复杂性，识别最重要的多个特征，但有时不一定需要，并且可能损失有用信息。适用于数值型数据。&lt;/li&gt;
&lt;li&gt;对于下图的数据，要找出一条直线尽可能覆盖这些点，第一条坐标轴旋转到最大方差的方向，数据的最大方差给出了数据的最重要的信息。在选择了覆盖数据最大差异性的坐标轴之后，选择第二条坐标轴与第一条正交。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/pca%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE.png&quot; width=&quot;400px&quot;&gt;在下面的示例中，只需要一维信息，另一维信息只是对分类缺乏贡献的噪声数据。可以采用决策树，也可以使用SVM获得更好的分类间隔，但是分类超平面很难解释。PCA降维可以同时获得SVM和决策树的优点。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/pca%E9%99%8D%E7%BB%B42.png&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PCA过程实现：第一个主成分从数据差异性最大的方向获取，可以通过数据集的&lt;a href=&quot;http://pinkyjie.com/2010/08/31/covariance/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;协方差矩阵 Convariance&lt;/a&gt;和&lt;a href=&quot;http://www.tongji.edu.cn/~math/xxds/kcja/kcja_b/5-2.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;特征值&lt;/a&gt;分析求得。下面pca函数的流程为，首先去除平均值，之后计算协方差矩阵&lt;code&gt;cov&lt;/code&gt;，计算协方差矩阵的特征值和特征向量&lt;code&gt;linalg.eig&lt;/code&gt;，将特征值从大到小排序，保留对应的最上面的N个特征向量，最后将数据转换到上述N个特征向量构建的新空间中。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fileName, delim = &lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fr = open(fileName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stringArr = [line.strip().split(delim) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines()]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datArr = [map(float, line) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; stringArr]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mat(datArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pca&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMat, topNfeat = &lt;span class=&quot;number&quot;&gt;999999&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meanVals = mean(dataMat, axis = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meanRemoved = dataMat - meanVals&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    covMat = cov(meanRemoved, rowvar = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;# n*n&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    eigVals, eigVects = linalg.eig(mat(covMat))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 1*n, n*n&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    eigValInd = argsort(eigVals)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    eigValInd = eigValInd[:-(topNfeat+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redEigVects = eigVects[:,eigValInd]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lowDDataMat = meanRemoved * redEigVects&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reconMat = (lowDDataMat * redEigVects.T) + meanVals&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lowDDataMat, reconMat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行示例如下，下图是构造出的第一主成分。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/pca%E9%99%8D%E7%BB%B4.png&quot; width=&quot;400px&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;dataMat = pca.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;testSet.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lowDMat, reconMat = pca.pca(dataMat, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;shape(lowDMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ax.scatter(dataMat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], dataMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        marker = &lt;span class=&quot;string&quot;&gt;&#39;^&#39;&lt;/span&gt;, s = &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ax.scatter(reconMat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], reconMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        marker = &lt;span class=&quot;string&quot;&gt;&#39;o&#39;&lt;/span&gt;, s = &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;利用PCA对半导体制造数据降维&quot;&gt;&lt;a href=&quot;#利用PCA对半导体制造数据降维&quot; class=&quot;headerlink&quot; title=&quot;利用PCA对半导体制造数据降维&quot;&gt;&lt;/a&gt;利用PCA对半导体制造数据降维&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://archive.ics.uci.edu/ml/machine-learning-databases/secom/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据集&lt;/a&gt;来自UCI机器学习数据库，包含590个特征，其中几乎所有样本都存在特征缺失，用NaN表示，通过replaceNanWithMean将缺失的NaN数据用其他样本的相同特征值平均值填充。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;replaceNanWithMean&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datMat = loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;secom.data&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    numFeat = shape(datMat)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numFeat):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meanVal = mean(datMat[nonzero(~isnan(datMat[:,i].A))[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        datMat[nonzero(isnan(datMat[:,i].A))[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], i] = meanVal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; datMat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从特征值可以看出，有超过20%特征值为0，这些特征都是其他特征的副本。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;dataMat = pca.replaceNanWithMean()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;meanVals = mean(dataMat, axis=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;meanRemoved = dataMat - meanVals&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;covMat = cov(meanRemoved, rowvar=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;eigVals, eigVects = linalg.eig(mat(covMat))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array([  &lt;span class=&quot;number&quot;&gt;5.34151979e+07&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.17466719e+07&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;8.24837662e+06&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;2.07388086e+06&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.31540439e+06&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;4.67693557e+05&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;2.90863555e+05&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.83668601e+05&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;2.37155830e+05&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;2.08513836e+05&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.96098849e+05&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;1.86856549e+05&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,   &lt;span class=&quot;number&quot;&gt;0.00000000e+00&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下图是前二十个主成分占总方差的百分比，大部分方差都包含在前面几个主成分中，前6个特征覆盖了96.8%的方差。因此可以将590个特征缩减到这6个特征。现实中我们无法精确知道所需要的主成分数目，必须通过实验取不同值来确定。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/pca%E6%96%B9%E5%B7%AE%E5%8D%A0%E6%AF%94.png&quot; width=&quot;400px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;PCA总结&quot;&gt;&lt;a href=&quot;#PCA总结&quot; class=&quot;headerlink&quot; title=&quot;PCA总结&quot;&gt;&lt;/a&gt;PCA总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;降维技术使数据更易使用，并且它们往往能够去除数据中的噪声，通常作为预处理步骤，在算法应用前清洗数据。PCA可以从数据中识别主要特征，它通过沿着数据最大方差方向旋转坐标轴实现。如果要处理的数据过多无法放入内存，可以使用在线PCA分析，参考论文“Incremental Eigenanalysis for Classification”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/25/machinelearning13/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/25/machinelearning13/&quot;&gt;http://forec.github.io/2016/02/25/machinelearning13/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在低维下，数据更容易进行处理，其相关特征可能在数据中明确显示出来。PCA是降维技术中最广泛的一种。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 12 - FP-growth算法）</title>
    <link href="http://forec.github.io/2016/02/24/machinelearning12/"/>
    <id>http://forec.github.io/2016/02/24/machinelearning12/</id>
    <published>2016-02-24T12:19:23.000Z</published>
    <updated>2016-02-24T13:02:07.606Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;FP-growth算法基于Apriori构建，先将数据集存储在FP树内，再发现频繁项集，速度通常快于Apriori两个数量级以上。FP-growth只需要对数据库扫描两次，而Apriori需要对每个潜在的频繁项集扫描一次数据集。Apriori算法拓展性更好，可以用于并行计算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;FP树&quot;&gt;&lt;a href=&quot;#FP树&quot; class=&quot;headerlink&quot; title=&quot;FP树&quot;&gt;&lt;/a&gt;FP树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;FP-growth算法速度优于Apriori，但实现相对困难，在某些数据集上性能会下降，适用于标称型数据。FP代表频繁模式，FP-growth算法将数据存储在FP树中。&lt;/li&gt;
&lt;li&gt;FP树通过链接来连接相似元素，被连接的元素项可以看成一个链表。与搜索树不同的是，一个元素项可以在FP树中出现多次，FP树会存储项集的出现频率，而每个项集以路径的方式存储在树中（类似字典树），存在相似元素的集合会共享树的一部分。树节点上给出集合中的单个元素及其在序列中的出现次数，路径会给出该序列的出现次数。&lt;/li&gt;
&lt;li&gt;下表是用来生成下面示例的FP树的数据。&lt;table style=&quot;height: 170px; width: 426px;&quot; border=&quot;1&quot;&gt;&lt;caption&gt;生成FP树的事务数据样例&lt;/caption&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;事务ID&lt;/td&gt;&lt;td style=&quot;text-align: center;&quot;&gt;事务中的元素项&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;001&lt;/td&gt;&lt;td&gt;r, z, h, j, p&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;002&lt;/td&gt;&lt;td&gt;z, y, x, w, v, u, t, s&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;003&lt;/td&gt;&lt;td&gt;z&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;004&lt;/td&gt;&lt;td&gt;r, x, n, o, s&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;005&lt;/td&gt;&lt;td&gt;y, r, x, z, q, t, p&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align: center;&quot;&gt;006&lt;/td&gt;&lt;td&gt;y, z, x, e, q, s, t, m&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/FP%E6%A0%91-1.jpg&quot; width=&quot;200px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;构建FP树&quot;&gt;&lt;a href=&quot;#构建FP树&quot; class=&quot;headerlink&quot; title=&quot;构建FP树&quot;&gt;&lt;/a&gt;构建FP树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为FP树建立新的数据类，定义如下，fpGrowth.py。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;treeNode&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, nameValue, numOccur, parentNode)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.name = nameValue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.count = numOccur&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.nodeLink = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.parent = parentNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.children = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, numOccur)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.count += numOccur&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;disp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ind = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;*ind, self.name, &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;, self.count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; child &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; self.children.values():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            child.disp(ind+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除了FP树外，还需要一个头指针表headerTable来存储FP树中元素第一次出现的位置和该元素的总数。上例中FP树的headerTable如下。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/FP-%E6%A0%912.jpg&quot; width=&quot;300px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;构造FP树过程如下：第一次遍历数据集会获得每个元素项的出现频率，之后去掉不满足最小支持度的元素项。再下一步构建FP树，读入每个项集并将其添加到一条路径中，若路径不存在则新建。每个事务都是一个无序集合，为了保证相同元素项只出现一次，需要对每个过滤后的事务中的元素项排序后再添加到树中，排序基于元素项的绝对出现频率由大到小开始。构造过程如下图。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/Fp%E6%A0%91-3.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建树代码如下。函数createTree使用处理好的数据集和最小支持度作为参数，返回建好的FP树和FP树的headerTable。函数updateTree输入参数为一个项集、当前的FP树、当前FP树的headerTable和当前项集出现次数，updateTree将这个项集插入到当前的FP树中，具体实现是如果这个项集只有一个元素，那么如果这个元素已经存在FP树中，就增加它的count值，否则为它在当前FP树下新分配一个节点，并更新headerTable，如果这个项集不止一个元素，那么对剩下的元素递归调用updateTree。updateHeader是updateTree的子函数，用来更新headerTable，确保节点链接指向树中该元素项的每个实例。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, minSup = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    headerTable = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; trans &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; trans:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            headerTable[item] = headerTable.get(item, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) + dataSet[trans]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; headerTable.keys():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; headerTable[k] &amp;lt; minSup:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;del&lt;/span&gt;(headerTable[k])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    freqItemSep = set(headerTable.keys())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(freqItemSep) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; headerTable:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        headerTable[k] = [headerTable[k], &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retTree = treeNode(&lt;span class=&quot;string&quot;&gt;&#39;Null Set&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; tranSet, count &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet.items():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        localD = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; tranSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; freqItemSep:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                localD[item] = headerTable[item][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(localD) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            orderedItems = [v[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; v &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sorted(localD.items(),\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                key = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; p: p[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], reverse = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            updateTree(orderedItems, retTree, headerTable, count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retTree, headerTable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;updateTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(items, inTree, headerTable, count)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; inTree.children:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inTree.children[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]].inc(count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inTree.children[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]] = treeNode(items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], count, inTree)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; headerTable[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] == &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            headerTable[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = inTree.children[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            updateHeader(headerTable[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], inTree.children[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(items) &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        updateTree(items[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;::], inTree.children[items[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]], headerTable, count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;updateHeader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nodeToTest, targetNode)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (nodeToTest.nodeLink != &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nodeToTest = nodeToTest.nodeLink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nodeToTest.nodeLink = targetNode&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建树使用的数据集是处理过原始数据得到的一个字典。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadSimpDat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    simpDat = [[&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;h&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;j&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;p&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               [&lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;y&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;v&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;u&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;t&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               [&lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               [&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;n&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;o&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               [&lt;span class=&quot;string&quot;&gt;&#39;y&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;q&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;t&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;p&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               [&lt;span class=&quot;string&quot;&gt;&#39;y&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;e&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;q&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;t&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;m&#39;&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; simpDat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createInitSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retDict = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; trans &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        retDict[frozenset(trans)] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retDict&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面代码对simpDat建立的FP树如下。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;simpDat = fpGrowth.loadSimpDat()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;initSet = fpGrowth.createInitSet(simpDat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myFpTree, myHeaderTab = fpGrowth.createTree(initSet, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myFpTree.disp()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Null Set   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   x   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     r   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   z   &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     y   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      s   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       t   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      r   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       t   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;从FP树中挖掘频繁项集&quot;&gt;&lt;a href=&quot;#从FP树中挖掘频繁项集&quot; class=&quot;headerlink&quot; title=&quot;从FP树中挖掘频繁项集&quot;&gt;&lt;/a&gt;从FP树中挖掘频繁项集&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;从FP树获取频繁项集的步骤如下：从FP树中获取条件模式基，利用条件模式基构建一个条件FP树，迭代上面两步，直到树包含一个元素项为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;抽取条件模式基&quot;&gt;&lt;a href=&quot;#抽取条件模式基&quot; class=&quot;headerlink&quot; title=&quot;抽取条件模式基&quot;&gt;&lt;/a&gt;抽取条件模式基&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对于保存在headerTable中的每一个元素项，他们自身都是一个长度为一的频繁项集，首先要获得其对应的条件模式基。条件模式基是以所查找元素项为结尾的路径集合，每条路径都是一条前缀路径。例如在最初的FP树例子中，元素r的前缀路径是{x,s}、{z,x,y}和{z}，而这每一条前缀路径都对应一个计数值，计数值等于起始元素项的计数值，这里就是r出现的次数（1次）。这些前缀路径会被用来构建条件FP树，因为headerTable中包含了每个元素第一次出现的位置，因此可以通过headerTable遍历每个元素并且上溯整棵树到根节点。&lt;/li&gt;
&lt;li&gt;函数ascendTree用来迭代上溯整棵树，findPrefixPath用来找到参数basePat对应的所有条件模式基，期间不停调用ascendTree。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ascendTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(leafNode, prefixPath)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; leafNode.parent != &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prefixPath.append(leafNode.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ascendTree(leafNode.parent, prefixPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;findPrefixPath&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(basePat, treeNode)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condPats = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; treeNode != &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prefixPath = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ascendTree(treeNode, prefixPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(prefixPath) &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            condPats[frozenset(prefixPath[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:])] = treeNode.count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        treeNode = treeNode.nodeLink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; condPats&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fpGrowth.findPrefixPath(&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;, myHeaderTab[&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, frozenset([&lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, frozenset([&lt;span class=&quot;string&quot;&gt;&#39;y&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创建条件FP树&quot;&gt;&lt;a href=&quot;#创建条件FP树&quot; class=&quot;headerlink&quot; title=&quot;创建条件FP树&quot;&gt;&lt;/a&gt;创建条件FP树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对于每一个频繁项都要创建一棵条件FP树，使用条件模式基作为输入数据，用相同的建树代码构建条件树，之后递归地发现频繁项、发现条件模式基，并且继续构造条件树，直到条件树中没有元素。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数mineTree对参数inTree代表的FP树进行频繁项集挖掘。首先对headerTable中出现的单个元素按出现频率从小到大排序，之后将每个元素的条件模式基作为输入数据，建立针对当前元素的条件树，如果生成的这棵条件树仍有元素，就在这棵条件树里寻找频繁项集，因为prefix参数是在递归过程中不断向下传递的，因此由最初的headerTable中的某个元素x衍生出的所有频繁项集都带有x。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mineTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inTree, headerTable, minSup, preFix, freqItemList)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bigL = [v[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; v &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sorted(headerTable.items(), key = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; p: p[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; basePat &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; bigL:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        newFreqSet = preFix.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        newFreqSet.add(basePat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        freqItemList.append(newFreqSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        condPattBases = findPrefixPath(basePat, headerTable[basePat][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        myCondTree, myHead = createTree(condPattBases, minSup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; myHead != &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;conditional tree for: &#39;&lt;/span&gt;, newFreqSet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            myCondTree.disp(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mineTree(myCondTree, myHead, minSup, newFreqSet, freqItemList)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mineTree函数递归过程稍微复杂，可以通过下面这幅图（链接是图的&lt;a href=&quot;http://www.cnblogs.com/qwertWZ/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原作者&lt;/a&gt;）来了解。在mineTree的&lt;code&gt;for basePat in bigL&lt;/code&gt;中，当前的basePat是&lt;code&gt;t&lt;/code&gt;的情况下的递归过程。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/Fp%E6%A0%91-4.jpg&quot; width=&quot;500px&quot;&gt;下面是代码运行时以t为basePat情况下的部分输出。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;freqItems = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fpGrowth.mineTree(myFpTree, myHeaderTab, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,set([]), freqItems)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conditional tree &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;:  set([&lt;span class=&quot;string&quot;&gt;&#39;t&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Null Set   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   y   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     z   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conditional tree &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;:  set([&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;t&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Null Set   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   y   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conditional tree &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;:  set([&lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;t&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Null Set   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   y   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conditional tree &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;:  set([&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;z&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;t&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Null Set   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   y   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;在Twitter源中发现关键词&quot;&gt;&lt;a href=&quot;#在Twitter源中发现关键词&quot; class=&quot;headerlink&quot; title=&quot;在Twitter源中发现关键词&quot;&gt;&lt;/a&gt;在Twitter源中发现关键词&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用python-twitter库，链接是&lt;a href=&quot;https://github.com/bear/python-twitter&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源代码&lt;/a&gt;和&lt;a href=&quot;http://dev.twitter.com/doc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Twitter API文档&lt;/a&gt;，最好直接阅读python-twitter在github上源代码中的api.py文件。使用API需要从twitter开发服务网站获得两个app开发证书集合。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数getLotsOfTweets处理OAuth认证并从twitter获取搜索相关的1400条推文。textParse将获取到的推文处理，mineTweets对每条推文调用textParse，生成FP树并返回所有频繁项集组成的list。注释掉的&lt;code&gt;api.VerifyCredentials()&lt;/code&gt;可以查看api是否授权成功。作者写书时候的api现在已经更新了，GetSearch方法里的&lt;code&gt;per_page&lt;/code&gt;和&lt;code&gt;page&lt;/code&gt;参数都已经取消，现在是&lt;code&gt;count&lt;/code&gt;和&lt;code&gt;since_id&lt;/code&gt;，另外有一个&lt;code&gt;since&lt;/code&gt;参数是起始日期，格式XXXX-XX-XX，因为是用pip安装的python-twitter，和github上的源码不同步，这里没有用。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; twitter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getLotsOfTweets&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(searchStr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CONSUMER_KEY = &lt;span class=&quot;string&quot;&gt;&quot;a9TIv9g****84UScUZ3Zk30uA&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CONSUMER_SECRET =&lt;span class=&quot;string&quot;&gt;&quot;4qcZYvP8RWjK****akMJEPuvu0kZq0vfSc45JOENLpwDiyhFh1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ACCESS_TOKEN_KEY = &lt;span class=&quot;string&quot;&gt;&quot;702455247084453888-****3kaZzXIu1NmNoSFvGNFSx3z5P6Z&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ACCESS_TOKEN_SECRET = &lt;span class=&quot;string&quot;&gt;&quot;fldNq1f0oHUqOafR****01uxWGxCLJt253lKPCbrX0acx&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    api = twitter.Api(consumer_key = CONSUMER_KEY,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        consumer_secret = CONSUMER_SECRET,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        access_token_key = ACCESS_TOKEN_KEY,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        access_token_secret = ACCESS_TOKEN_SECRET)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resultsPages = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fetching page %d&quot;&lt;/span&gt; % i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        searchResults = api.GetSearch(searchStr, count = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, since_id = i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#, since=&quot;2016-02-21&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resultsPages.append(searchResults)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sleep(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; resultsPages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;textParse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(bigString)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    urlsRemoved = re.sub(&lt;span class=&quot;string&quot;&gt;&#39;(http[s]?:[/][/]|www.)([a-z]|[A-Z]|[0-9]|[/.]|[-])*&#39;&lt;/span&gt;,\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, bigString)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listOfTokens = re.split(&lt;span class=&quot;string&quot;&gt;r&#39;\W*&#39;&lt;/span&gt;, urlsRemoved)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [tok.lower() &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; tok &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; listOfTokens &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(tok) &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mineTweets&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tweetArr, minSup=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    parsedList = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            parsedList.append(textParse(tweetArr[i][j].text))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initSet = createInitSet(parsedList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myFPtree, myHeaderTab = createTree(initSet, minSup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myFreqList = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mineTree(myFPtree, myHeaderTab, minSup, set([]), myFreqList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; myFreqList&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行结果如下。现在是2月24日，2月22日苹果和FBI之间的争论开始，用Apple作为关键词看一下最近的记录。lotsOfTweets的下标是我随机抽取的，大部分都和FBI有关。得到频繁项集可以发现有许多都是fbi、iphone、cifrado等组成，和最近的热点相近。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lotsOfTweets = fpGrowth.getLotsOfTweets(&lt;span class=&quot;string&quot;&gt;&#39;Apple&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetching page &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetching page &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....https://t.co/rjhZgCPXbC &lt;span class=&quot;comment&quot;&gt;#Apple&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lotsOfTweets[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;].text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;u&#39;RT @BIUK_Tech: Apple will use a free speech defence in its war \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;with the FBI $AAPL https://t.co/1rI51zTq8p&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lotsOfTweets[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;89&lt;/span&gt;].text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;u&#39;Watch Bill Gates talk about the privacy debate between Apple and\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; the FBI https://t.co/8mQ5smXOYE&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;lotsOfTweets[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;].text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;u&quot;&#39;Perang Panas&#39; FBI Vs Apple, Publik AS Terbelah: Mayoritas publik\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; yang disurvei mendukung FBI. https://t.co/ZNmPT699b1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;listOfTerms = fpGrowth.mineTweets(lotsOfTweets, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;len(listOfTerms)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1570&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; t &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; listOfTerms:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(t) == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;fbi&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; t:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;... &lt;/span&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set([&lt;span class=&quot;string&quot;&gt;u&#39;fbi&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;cifrado&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;entender&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set([&lt;span class=&quot;string&quot;&gt;u&#39;fbi&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;cifrado&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;iphone&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set([&lt;span class=&quot;string&quot;&gt;u&#39;fbi&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;del&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;cifrado&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set([&lt;span class=&quot;string&quot;&gt;u&#39;fbi&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;entender&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;con&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set([&lt;span class=&quot;string&quot;&gt;u&#39;fbi&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;iphone&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;u&#39;entender&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;FP-growth算法总结&quot;&gt;&lt;a href=&quot;#FP-growth算法总结&quot; class=&quot;headerlink&quot; title=&quot;FP-growth算法总结&quot;&gt;&lt;/a&gt;FP-growth算法总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;FP-growth算法是一种用于发现数据集中频繁模式的有效方法，利用Apriori原则执行，支队数据集扫描两遍。数据及存储在FP树结构中，该树构建完成后，通过查找元素项的条件模式基、构建条件FP树来发现频繁项集并递归此过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/24/machinelearning12/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/24/machinelearning12/&quot;&gt;http://forec.github.io/2016/02/24/machinelearning12/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;FP-growth算法基于Apriori构建，先将数据集存储在FP树内，再发现频繁项集，速度通常快于Apriori两个数量级以上。FP-growth只需要对数据库扫描两次，而Apriori需要对每个潜在的频繁项集扫描一次数据集。Apriori算法拓展性更好，可以用于并行计算。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 11 - Apriori算法）</title>
    <link href="http://forec.github.io/2016/02/22/machinelearning11/"/>
    <id>http://forec.github.io/2016/02/22/machinelearning11/</id>
    <published>2016-02-22T13:17:17.000Z</published>
    <updated>2016-02-22T13:33:08.344Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;商店通过会员卡等忠诚度计划，可以获取顾客所购买商品的组合信息，从而更好地安排商品定价、市场促销等。从大规模数据集中寻找物品间的隐含关系被称作关联分析或者关联规则学习。Apriori算法可以解决计算代价极高的物品组合问题，从而在合理的时间范围内找到频繁项集和关联规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;关联分析&quot;&gt;&lt;a href=&quot;#关联分析&quot; class=&quot;headerlink&quot; title=&quot;关联分析&quot;&gt;&lt;/a&gt;关联分析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;关联分析是一种在大规模数据集中寻找关系的任务，这些关系可以有两种形式：频繁项集或者关联规则。频繁项集是经常出现在一起的物品的集合，关联规则暗示两种物品之间存在很强的因果关系。经典的例子如“啤酒与尿布”。&lt;/li&gt;
&lt;li&gt;定义“频繁”和“关联”：一个项集的支持度被定义为数据集中包含该项集的记录所占的比例。可信度或置信度是针对一条例如{尿布}→{啤酒}的关联规则定义的，这条规则的可信度被定义为&lt;code&gt;支持度({尿布，啤酒})/支持度({尿布})&lt;/code&gt;。假设这条规则的置信度是75%，那么对于所有包含“尿布”的记录，这条规则对其中的75%都适用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Apriori原理&quot;&gt;&lt;a href=&quot;#Apriori原理&quot; class=&quot;headerlink&quot; title=&quot;Apriori原理&quot;&gt;&lt;/a&gt;Apriori原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Apriori算法易于编写，但在大数据集上效率不高。适用于数值型或者标称型数据。&lt;/li&gt;
&lt;li&gt;假设现在有n件商品，不考虑购买的数量重叠，消费者购买的可能组合就有2^n-1种。这2^N-1种项集组合无法全部遍历，因此通过Apriori原理过滤到不可能“频繁”出现的项集。&lt;strong&gt;Apriori原理指如果某个项集是频繁的，那么它的所有子集也是频繁的&lt;/strong&gt;。实际应用时，通常对原理取反：&lt;strong&gt;如果一个项集是非频繁集，那么它的所有超集也都是非频繁的&lt;/strong&gt;。Apriori意指“来自以前”，即定义问题时通常使用先验知识或者假设，例如在贝叶斯统计中使用先验知识作为条件进行推断，这些先验知识可能来自领域知识、先前的测量结果等。&lt;/li&gt;
&lt;li&gt;Apriori算法通过已经得到的支持度达标的项集来构造更复杂的项集，因此可以看作迭代的过程。初始状态每个项集仅包含一个物品，通过统计这些长度为1的项集的支持度，筛选掉不达标的项集，再用达标项集生成长度为2的项集。过程不断重复直到所有的项集筛选完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Apriori算法寻找频繁集&quot;&gt;&lt;a href=&quot;#Apriori算法寻找频繁集&quot; class=&quot;headerlink&quot; title=&quot;Apriori算法寻找频繁集&quot;&gt;&lt;/a&gt;Apriori算法寻找频繁集&lt;/h1&gt;&lt;h2 id=&quot;生成候选项集&quot;&gt;&lt;a href=&quot;#生成候选项集&quot; class=&quot;headerlink&quot; title=&quot;生成候选项集&quot;&gt;&lt;/a&gt;生成候选项集&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数createC1()用于构建集合C1。Ck是大小为k的所有候选项集集合，注意生成的C1通过map冰冻，意味着每个值都无法改变。scanD函数用于从Ck中筛选出支持度符合要求的项集，构成集合Lk。loadDataSet初始化一个数据集。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createC1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    C1 = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; transcation &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dataSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; transcation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; [item] &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                C1.append([item])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    C1.sort()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; map(frozenset, C1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;scanD&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(D, Ck, minSupport)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ssCnt = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; tid &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; D:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; can &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Ck:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; can.issubset(tid):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; ssCnt.has_key(can): ssCnt[can] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: ssCnt[can] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    numItems = float(len(D))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retList = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    supportData = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; ssCnt:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        support = ssCnt[key]/numItems&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; support &amp;gt;= minSupport:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retList.insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        supportData[key] = support&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retList, supportData&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对原始数据集初始化后的C1，L1如下。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; apriori&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;dataSet=  apriori.loadDataSet()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;C1 = apriori.createC1(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;])]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;D = map(set, dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[set([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]), set([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]), set([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]), set([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;])]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;L1, supportData0 = apriori.scanD(D, C1, &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;])]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;frozenset([&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;0.25&lt;/span&gt;, frozenset([&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;0.75&lt;/span&gt;, frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;0.75&lt;/span&gt;, frozenset([&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;0.75&lt;/span&gt;, frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]): &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;组织完整的Apriori算法&quot;&gt;&lt;a href=&quot;#组织完整的Apriori算法&quot; class=&quot;headerlink&quot; title=&quot;组织完整的Apriori算法&quot;&gt;&lt;/a&gt;组织完整的Apriori算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Apriori整个算法流程如下：当当前集合Lk中的筛选出的频繁项集数大于0，则生成Ck+1，直到所有可能的组合都筛选完成。函数aprioriGen取频繁项集列表Lk和k作为参数，生成Ck，具体实现是对Lk中的每个元素，比较这个元素和其他元素，如果两个元素有k-1个项相同，就可以将两个元素合并成Ck+1中的一个。apriori函数取数据集、支持度作为参数，首先用createC1创建C1，用scanD筛选出L1，之后迭代生成Lk。apriori函数返回所有的频繁项集和项集的支持度。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;aprioriGen&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Lk, k)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retList = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lenLk = len(Lk)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(lenLk):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, lenLk):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            L1 = list(Lk[i])[:k-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]; L2 = list(Lk[j])[:k-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            L1.sort(); L2.sort()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L1 == L2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                retList.append(Lk[i] | Lk[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retList&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;apriori&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, minSupport = &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    C1 = createC1(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    D = map(set, dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    L1, supportData = scanD(D, C1, minSupport)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    L = [L1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    k = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (len(L[k-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Ck = aprioriGen(L[k-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;], k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Lk, supK = scanD(D, Ck, minSupport)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        supportData.update(supK)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        L.append(Lk)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        k += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; L, supportData&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行效果。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;reload(apriori)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;L, suppData = apriori.apriori(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;])], [frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;])], [frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;])], []]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;apriori.aprioriGen(L[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]), frozenset([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;])]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;从频繁项集中挖掘关联规则&quot;&gt;&lt;a href=&quot;#从频繁项集中挖掘关联规则&quot; class=&quot;headerlink&quot; title=&quot;从频繁项集中挖掘关联规则&quot;&gt;&lt;/a&gt;从频繁项集中挖掘关联规则&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;关联规则不一定是可逆的，{尿布}→{啤酒}不意味着{啤酒}→{牛奶}。对于一个频繁项，可以将其中包含的元素划分为两部分，左端称为前件，如{尿布}→{啤酒}中的尿布，右端称为后件。对于一个固定的频繁项，前件与后件的元素个数之和固定，但前件后件数目可以调配。为了减少产生的规则数目，可以发现，如果某条规则并不满足最小可信度要求，那么这条规则的所有子集也不满足最小可信度要求。例如，{0，1，2}→{3}的规则不满足可信度，则所有前件是{0，1，2}子集的规则都不满足可信度。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造方法如下：首先从一个频繁项集开始，创建一个规则列表，其中规则右部只包含一个元素，然后对这些规则测试，接下来合并所有剩余规则来创建一个新的规则列表，此时右部包含两个元素，以此类推，称为分级法。函数generateRules取频繁项集列表L、项集支持度supportData和最小可信阈值minConf作为参数，遍历L中的每一个频繁项集并对每个频繁项集创建只包含单个元素集合的列表H1。注意因为无法从单个元素的项集中构建关联规则，所以从包含两个或者更多元素的项集开始。如果频繁项集的元素数目大于2，则考虑对其做进一步合并，产生其他规则，通过rulesFromConseq完成，否则直接calcConf计算可信值。rulesFromConseq中的&lt;code&gt;if (lne(freqSet)&amp;gt;(m+1))&lt;/code&gt;的判断目的在于确定当前的频繁项是否大到可以移除长为m的子集。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generateRules&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(L, supportData, minConf = &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bigRuleList = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, len(L)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; freqSet &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; L[i]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            H1 = [frozenset([item]) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; freqSet]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                calcConf(freqSet, H1, supportData, bigRuleList, minConf)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bigRuleList&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcConf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(freqSet, H, supportData, brl, minConf = &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    prunedH = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; conseq &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; H:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        conf = supportData[freqSet]/supportData[freqSet-conseq]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; conf &amp;gt;= minConf:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; freqSet-conseq, &lt;span class=&quot;string&quot;&gt;&#39;--&amp;gt;&#39;&lt;/span&gt;, conseq, &lt;span class=&quot;string&quot;&gt;&#39;conf:&#39;&lt;/span&gt;, conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            brl.append((freqSet-conseq, conseq, conf))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            prunedH.append(conseq)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prunedH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rulesFromConseq&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(freqSet, H, supportData, brl, minConf = &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = len(H[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (len(freqSet) &amp;gt; (m+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Hmp1 = aprioriGen(H, m+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (len(Hmp1) &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行结果&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; reload(apriori)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; L, suppData = apriori.apriori(dataSet, minSupport = 0.5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; rules = apriori.generateRules(L, suppData, minConf = 0.7)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([1]) --&amp;gt; frozenset([3]) conf: 1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([5]) --&amp;gt; frozenset([2]) conf: 1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([2]) --&amp;gt; frozenset([5]) conf: 1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; rules = apriori.generateRules(L, suppData, minConf = 0.5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([3]) --&amp;gt; frozenset([1]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([1]) --&amp;gt; frozenset([3]) conf: 1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([5]) --&amp;gt; frozenset([2]) conf: 1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([2]) --&amp;gt; frozenset([5]) conf: 1.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([3]) --&amp;gt; frozenset([2]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([2]) --&amp;gt; frozenset([3]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([5]) --&amp;gt; frozenset([3]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([3]) --&amp;gt; frozenset([5]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([5]) --&amp;gt; frozenset([2, 3]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([3]) --&amp;gt; frozenset([2, 5]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([2]) --&amp;gt; frozenset([3, 5]) conf: 0.666666666667&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;发现国会投票中的模式和毒蘑菇的相似特征&quot;&gt;&lt;a href=&quot;#发现国会投票中的模式和毒蘑菇的相似特征&quot; class=&quot;headerlink&quot; title=&quot;发现国会投票中的模式和毒蘑菇的相似特征&quot;&gt;&lt;/a&gt;发现国会投票中的模式和毒蘑菇的相似特征&lt;/h1&gt;&lt;h2 id=&quot;国会投票&quot;&gt;&lt;a href=&quot;#国会投票&quot; class=&quot;headerlink&quot; title=&quot;国会投票&quot;&gt;&lt;/a&gt;国会投票&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.votesmart.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;智能投票工程&lt;/a&gt;提供了公共API来访问国会投票记录，Sunlight实验室写了一个&lt;a href=&quot;https://github.com/sunlightlabs/python-votesmart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;python-votesmart&lt;/a&gt;用于访问该API。需要先&lt;a href=&quot;http://votesmart.org/share/api/register&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;注册&lt;/a&gt;一个API key。需要一个工作日左右来处理申请API请求，成功后的API授权代码会发送到注册邮箱。时差关系大概晚上注册会比较好。通过&lt;code&gt;votesmart.apikey&lt;/code&gt;来告知votesmart库你的api授权代码，通过&lt;code&gt;votesmart.votes.getBillsByStateRecent()&lt;/code&gt;来获取最近的100条议案，对于返回结果中的每条bill，可以查看&lt;code&gt;bill.title&lt;/code&gt;和&lt;code&gt;bill.billId&lt;/code&gt;。例如某条议案的ID是11820，可以通过&lt;code&gt;votesmart.votes.getBill(11820)&lt;/code&gt;来获取详细信息。对于某个议案bill的投票行为，可以通过&lt;code&gt;for action in bill.actions and action.stage==&amp;#39;Passage&amp;#39;&lt;/code&gt;来获得每个投票action。&lt;code&gt;action.actionId&lt;/code&gt;可以得到这个投票行为的ID，例如某个投票action是31670，可以通过&lt;code&gt;votesmart.votes.getBillActionVotes(31670)&lt;/code&gt;来获得详细信息。下面代码是Peter Harrington给出的，里面的api代码已经过期了。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; votesmart &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; votesmart&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;votesmart.apikey = &lt;span class=&quot;string&quot;&gt;&#39;a7fa40adec6f4a77178799fae4441030&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#votesmart.apikey = &#39;get your api key first&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getActionIds&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    actionIdList = []; billTitleList = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fr = open(&lt;span class=&quot;string&quot;&gt;&#39;recent20bills.txt&#39;&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        billNum = int(line.split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            billDetail = votesmart.votes.getBill(billNum) &lt;span class=&quot;comment&quot;&gt;#api call&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; action &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; billDetail.actions:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; action.level == &lt;span class=&quot;string&quot;&gt;&#39;House&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (action.stage == &lt;span class=&quot;string&quot;&gt;&#39;Passage&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; action.stage == &lt;span class=&quot;string&quot;&gt;&#39;Amendment Vote&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    actionId = int(action.actionId)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;bill: %d has actionId: %d&#39;&lt;/span&gt; % (billNum, actionId)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    actionIdList.append(actionId)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    billTitleList.append(line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;problem getting bill %d&quot;&lt;/span&gt; % billNum&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)                                      &lt;span class=&quot;comment&quot;&gt;#delay to be polite&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; actionIdList, billTitleList&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面的代码生成食物数据库，对每个actionId，抓取不同政客的投票。关系不大，不予讨论。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getTransList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(actionIdList, billTitleList)&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#this will return a list of lists containing ints&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    itemMeaning = [&lt;span class=&quot;string&quot;&gt;&#39;Republican&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Democratic&#39;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;#list of what each item stands for&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; billTitle &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; billTitleList:&lt;span class=&quot;comment&quot;&gt;#fill up itemMeaning list&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        itemMeaning.append(&lt;span class=&quot;string&quot;&gt;&#39;%s -- Nay&#39;&lt;/span&gt; % billTitle)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        itemMeaning.append(&lt;span class=&quot;string&quot;&gt;&#39;%s -- Yea&#39;&lt;/span&gt; % billTitle)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transDict = &amp;#123;&amp;#125;&lt;span class=&quot;comment&quot;&gt;#list of items in each transaction (politician) &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    voteCount = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; actionId &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; actionIdList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sleep(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;getting votes for actionId: %d&#39;&lt;/span&gt; % actionId&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            voteList = votesmart.votes.getBillActionVotes(actionId)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; vote &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; voteList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; transDict.has_key(vote.candidateName): &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    transDict[vote.candidateName] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; vote.officeParties == &lt;span class=&quot;string&quot;&gt;&#39;Democratic&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        transDict[vote.candidateName].append(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; vote.officeParties == &lt;span class=&quot;string&quot;&gt;&#39;Republican&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        transDict[vote.candidateName].append(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; vote.action == &lt;span class=&quot;string&quot;&gt;&#39;Nay&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    transDict[vote.candidateName].append(voteCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; vote.action == &lt;span class=&quot;string&quot;&gt;&#39;Yea&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    transDict[vote.candidateName].append(voteCount + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;problem getting actionId: %d&quot;&lt;/span&gt; % actionId&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        voteCount += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; transDict, itemMeaning&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;毒蘑菇相似特征&quot;&gt;&lt;a href=&quot;#毒蘑菇相似特征&quot; class=&quot;headerlink&quot; title=&quot;毒蘑菇相似特征&quot;&gt;&lt;/a&gt;毒蘑菇相似特征&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文件mushroom.dat的每一行第一个特征用1或者2表示可食用或有毒，其余列都是某种蘑菇的特征。通过apriori算法寻找包含特征值为2的频繁项集。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;mushDatSet = [line.split() &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&#39;mushroom.dat&#39;&lt;/span&gt;).readlines()]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;L, suppData = apriori.apriori(mushDatSet, minSupport = &lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; L[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item.intersection(&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;59&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;39&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;67&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;34&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;23&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; L[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item.intersection(&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;63&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;59&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;93&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;39&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;53&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;34&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;59&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;23&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;85&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;59&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;90&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;85&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frozenset([&lt;span class=&quot;string&quot;&gt;&#39;39&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;36&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;34&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Apriori算法总结&quot;&gt;&lt;a href=&quot;#Apriori算法总结&quot; class=&quot;headerlink&quot; title=&quot;Apriori算法总结&quot;&gt;&lt;/a&gt;Apriori算法总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;关联分析适用于发现大数据集中元素间关系的一个工具集，可以通过频繁项集给出经常在一起出现的元素项或者关联规则给出元素项之间的因果关系来量化。Apriori算法减少了在数据库上检查的集合的数目，如果一个元素项是不频繁的，那么它的超集也都是不频繁的。关联分析可以用在许多不同物品上，商店商品购买和网站访问历史都是常见的例子。每次增加频繁项集的大小，Apriori算法都要重新扫描整个数据集，当数据集很大，这会掀桌降低频繁项集发现的速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/22/machinelearning11/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/22/machinelearning11/&quot;&gt;http://forec.github.io/2016/02/22/machinelearning11/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;商店通过会员卡等忠诚度计划，可以获取顾客所购买商品的组合信息，从而更好地安排商品定价、市场促销等。从大规模数据集中寻找物品间的隐含关系被称作关联分析或者关联规则学习。Apriori算法可以解决计算代价极高的物品组合问题，从而在合理的时间范围内找到频繁项集和关联规则。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 10 - K-均值聚类算法）</title>
    <link href="http://forec.github.io/2016/02/21/machinelearning10/"/>
    <id>http://forec.github.io/2016/02/21/machinelearning10/</id>
    <published>2016-02-21T13:07:41.000Z</published>
    <updated>2016-02-22T13:33:53.240Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;聚类是一种无监督学习，将相似的对象归到同一个簇中，类似全自动分类，即类别体系也是自动构建的。聚类方法几乎可以应用于所有对性，簇内的对象越相似，聚类效果越好。K-均值聚类算法可以发现k个不同的簇，且每个簇的中心采用簇中所含值的均值构成。聚类与分类的区别在于，分类的目标事先已知，而聚类未知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;K-均值聚类&quot;&gt;&lt;a href=&quot;#K-均值聚类&quot; class=&quot;headerlink&quot; title=&quot;K-均值聚类&quot;&gt;&lt;/a&gt;K-均值聚类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;K-均值聚类算法的优点在于容易实现，缺点在于可能收敛到局部最小值，并且在大规模数据上收集较慢。适用于数值型数据。&lt;/li&gt;
&lt;li&gt;K-均值聚类算法发现给定数据集的k个簇，这里的k是用户指定的，其的工作流程如下：首先随机确定k个初始点作为质心（注意这里的k个初始点不一定是数据集中的点，但一定在数据集的range内），然后对数据集中的每个点，寻找距离这个点最近的质心，并将其分配给这个质心对应的簇，该步完成后将每个簇的质心修改为该簇所有点的平均值。伪代码表示如下：&lt;ul&gt;
&lt;li&gt;创建k个点作为起始质心（通常随机选择）&lt;/li&gt;
&lt;li&gt;当任意一个点的簇分配结果发生改变时：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对数据集中的每个点：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对每个质心：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;计算质心与数据点之间的距离&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将数据点分配到距离其最近的簇&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对每一个簇，计算簇中所有点的均值并将均值作为质心。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;K-均值算法要寻找最近的质心，因此需要进行某种距离计算，数据集上K-均值算法的性能会受到所选距离计算方法的影响。函数rendCent用于对数据集dataSet随机初始化k个簇质心，随机质心的大小在测试数据集的最小值和最大值之间。distEclud用于计算两个点之间的欧式距离，也可以切换成其他距离函数。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fileName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fr = open(fileName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curLine = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fltLine = map(float, curLine)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataMat.append(fltLine)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;distEclud&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vecA, vecB)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sqrt(sum(power(vecA - vecB, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;randCent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, k)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n = shape(dataSet)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    centroids = mat(zeros((k,n)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        minJ = min(dataSet[:,j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rangeJ = float(max(dataSet[:,j]) - minJ)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        centroids[:,j] = minJ + rangeJ * random.rand(k,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; centroids&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数kMeans接受四个输入参数，用户需要指定数据集和划分的簇数k。kMeans函数一开始确定数据中数据点总数，clusterAssment记录簇分配结果，第一列记录簇索引值，第二列存储误差（当前点到簇的质心的距离）。按照计算质心-&amp;gt;分配-&amp;gt;重新计算的过程反复迭代，直到所有数据点的簇分配结果不再改变为止。选项axis=0表示沿着矩阵的列方向计算均值。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;kMeans&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, k, distMeas = distEclud, createCent = randCent)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = shape(dataSet)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clusterAssment = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    centroids = createCend(dataSet, k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clusterChanged = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; clusterChanged:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clusterChanged = &lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minDist = inf; minIndex = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(k):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                distJI = distMeas(centroids[j,:], dataSet[i,:])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; distJI &amp;lt; minDist:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    minDist = distJI; minIndex = j&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; clusterAssment[i,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] != minIndex: clusterChanged = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clusterAssment[i,:] = minIndex, minDist**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#print centroids&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; cent &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(k):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ptsInClust = dataSet[nonzero(clusterAssment[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A == cent)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            centroids[cent,:] = mean(ptsInClust, axis=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; centroids, clusterAssment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kMeans&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;datMat = mat(kMeans.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;testSet.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myCentroids, clustAssing = kMeans.kMeans(datMat, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[-&lt;span class=&quot;number&quot;&gt;2.46154315&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2.78737555&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [-&lt;span class=&quot;number&quot;&gt;3.38237045&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;2.9473363&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ &lt;span class=&quot;number&quot;&gt;2.80293085&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;2.7315146&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [ &lt;span class=&quot;number&quot;&gt;2.6265299&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3.10868015&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;二分K-均值算法&quot;&gt;&lt;a href=&quot;#二分K-均值算法&quot; class=&quot;headerlink&quot; title=&quot;二分K-均值算法&quot;&gt;&lt;/a&gt;二分K-均值算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;后处理&lt;/strong&gt;：在K-均值聚类中簇的数目k是用户定义参数，可以利用clusterAssment中的误差值评价聚类分簇的正确性和质量。考虑下图的聚类结果，K-均值聚类算法收敛但聚类效果较差的原因是K-均值算法收敛到了局部最小值，而非全局最小值。可以使用SSE（误差平方和，clusterAssment[:,1]的和）评价聚类好坏，SSE值越小表示数据点越接近于它们的质心，聚类效果也越好。因为对误差取平方，因此更加重视远离质心的点。增加簇的个数必然降低SSE的值，但不符合聚类目标。一种方法是对聚类生成的簇进行后处理，将具有最大SSE值得簇划分为两个簇，具体实现只要将属于最大簇的数据点用K-均值聚类，设定簇数k=2即可。为了保证簇总数不变，可以合并最近的质心，或者合并两个使得SSE值增幅最小的质心。&lt;/li&gt;
&lt;li&gt;二分K-均值类似后处理的切分思想，初始状态所有数据点属于一个大簇，之后每次选择一个簇切分成两个簇，这个切分满足使SSE值最大程度降低，直到簇数目达到k。另一种思路是每次选择SSE值最大的一个簇进行切分。前者伪代码如下。&lt;ul&gt;
&lt;li&gt;将所有点看成一个簇&lt;/li&gt;
&lt;li&gt;当簇数目小于k时&lt;/li&gt;
&lt;li&gt;对于每一个簇：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;计算总误差&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在给定的簇上面进行K-均值聚类（k=2）&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;计算将该簇一分为二后的总误差&lt;/li&gt;
&lt;li&gt;选择使得误差最小的那个簇进行划分操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数biKmeans是上面二分K-均值聚类算法的实现，首先创建clusterAssment储存数据集中每个点的分类结果和平方误差，用centList保存所有已经划分的簇，初始状态为整个数据集。while循环不停对簇进行划分，寻找使得SSE值最大程度减小的簇并更新，添加新的簇到centList中。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;biKmeans&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, k, distMeas=distEclud)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = shape(dataSet)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clusterAssment = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    centroid0 = mean(dataSet, axis = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;).tolist()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    centList = [centroid0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clusterAssment[j,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = distMeas(mat(centroid0), dataSet[j,:])**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (len(centList) &amp;lt; k):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lowestSSE = inf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(centList)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ptsInCurrCluster = dataSet[nonzero(clusterAssment[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A==i)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            centroidMat, splitClustAss = kMeans(ptsInCurrCluster, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, distMeas)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sseSplit = sum(splitClustAss[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sseNotSplit = sum(clusterAssment[nonzero(clusterAssment[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A!=i)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;sseSplit, and notSplit: &quot;&lt;/span&gt;, sseSplit, sseNotSplit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sseSplit + sseNotSplit) &amp;lt; lowestSSE:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestCentToSplit = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestNewCents = centroidMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestClustAss = splitClustAss.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                lowestSSE = sseSplit + sseNotSplit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bestClustAss[nonzero(bestClustAss[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = len(centList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bestClustAss[nonzero(bestClustAss[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = bestCentToSplit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;The bestCentToSplit is: &quot;&lt;/span&gt;, bestCentToSplit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;The len of bestClustAss is: &quot;&lt;/span&gt;, len(bestClustAss)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        centList[bestCentToSplit] = bestNewCents[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,:].tolist()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        centList.append(bestNewCents[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,:].tolist()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clusterAssment[nonzero(clusterAssment[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A==bestCentToSplit)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],:] = bestClustAss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 按顺序更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mat(centList), clusterAssment&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行上述函数多次，聚类会收敛到全局最小值，而kMeans函数偶尔会陷入局部最小值。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;datMat3 = mat(kMeans.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;testSet2.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;centList, myNewAssments = kMeans.biKmeans(datMat3,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sseSplit, &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; notSplit:  &lt;span class=&quot;number&quot;&gt;453.033489581&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The bestCentToSplit &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt;:  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The len of bestClustAss &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt;:  &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sseSplit, &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; notSplit:  &lt;span class=&quot;number&quot;&gt;12.7532631369&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;423.876240137&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sseSplit, &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; notSplit:  &lt;span class=&quot;number&quot;&gt;77.5922493178&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;29.1572494441&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The bestCentToSplit &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt;:  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The len of bestClustAss &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt;:  &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;对地图上的点进行聚类&quot;&gt;&lt;a href=&quot;#对地图上的点进行聚类&quot; class=&quot;headerlink&quot; title=&quot;对地图上的点进行聚类&quot;&gt;&lt;/a&gt;对地图上的点进行聚类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用Yahho！PlaceFinder API收集数据，筛选出目标地点的经纬度，用matplotlib构建一个二位数据图，包含簇、位置和地图。将俄勒冈州的70个地点聚类，地址列表为portlandClubs,txt。可以在&lt;a href=&quot;http://developer.yahoo.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Yahoo开发者网络&lt;/a&gt;进行注册，创建一个桌面应用以获取appid。书上给出的yahooAPI的baseurl已经改变，并且yahoo目前的placefinder需要OAuth2验证，要使用该api，须在header里或者get方法中加入六个必须的参数。github上有oauth2供python使用，但是yahoo的BOOS GEO好像OAuth2验证出了问题，虽然写了新的placeFinder调用api的代码，仍然会有403错误，yahoo单方面的问题。几个链接，要vpn：&lt;a href=&quot;https://developer.yahoo.com/boss/geo/docs/oauth_model_geo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yahoo BOSS GEO的OAuth说明&lt;/a&gt;，&lt;a href=&quot;https://developer.yahoo.com/boss/geo/docs/requests-pf.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;yahoo placeFinder指南&lt;/a&gt;。上面的代码来自书上，下面的是适用于新的api的代码，但会返回403。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; urllib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;geoGrab&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(stAddress, city)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    apiStem = &lt;span class=&quot;string&quot;&gt;&#39;http://where.yahooapis.com/geocode?&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params[&lt;span class=&quot;string&quot;&gt;&#39;flags&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;J&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params[&lt;span class=&quot;string&quot;&gt;&#39;appid&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;ppp68N8t&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params[&lt;span class=&quot;string&quot;&gt;&#39;location&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;%s %s&#39;&lt;/span&gt; % (stAddress, city)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url_params = urllib.urlencode(params)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yahooApi = apiStem + url_params&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; yahooApi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c = urllib.urlopen(yahooApi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; c.read()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; json.loads(c.read())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;massPlaceFind&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fileName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fw = open(&lt;span class=&quot;string&quot;&gt;&#39;places.txt&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; open(fileName).readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        line = line.strip()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineArr = line.split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        retDict = geoGrab(lineArr[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], lineArr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; retDict[&lt;span class=&quot;string&quot;&gt;&#39;ResultSet&#39;&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;Error&#39;&lt;/span&gt;] == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lat = float(retDict[&lt;span class=&quot;string&quot;&gt;&#39;ResultSet&#39;&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;Results&#39;&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;latitude&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lng = float(retDict[&lt;span class=&quot;string&quot;&gt;&#39;ResultSet&#39;&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;Results&#39;&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;longitude&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;%s\t%f\t%f&quot;&lt;/span&gt; % (lineArr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], lat, lng)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fw.write(&lt;span class=&quot;string&quot;&gt;&#39;%s\t%f\t%f&#39;&lt;/span&gt; % (line, lat, lng))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;error fetching&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fw.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Upper codes are from the book.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# pst.py(codes for new apis)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; urllib2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; oauth2 &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; oauth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OAUTH_CONSUMER_KEY = &lt;span class=&quot;string&quot;&gt;&quot;dj0yJmk9OTRRNmJWaEQwSWhPJm********RHdzROekV5TjJFbWN\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HbzlNQS0tJnM9Y29uc3VtZXJzZWNyZXQmeD03OQ--&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OAUTH_CONSUMER_SECRET = &lt;span class=&quot;string&quot;&gt;&quot;8caf5cfb4e8****2c30418f26805f99aa8e49728&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;oauth_request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(url, params,method=&lt;span class=&quot;string&quot;&gt;&quot;GET&quot;&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params[&lt;span class=&quot;string&quot;&gt;&#39;oauth_version&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params[&lt;span class=&quot;string&quot;&gt;&#39;oauth_nonce&#39;&lt;/span&gt;] = oauth.generate_nonce() &lt;span class=&quot;comment&quot;&gt;#,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params[&lt;span class=&quot;string&quot;&gt;&#39;oauth_timestamp&#39;&lt;/span&gt;] = int(time.time())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    consumer = oauth.Consumer(key=OAUTH_CONSUMER_KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              secret=OAUTH_CONSUMER_SECRET)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    params[&lt;span class=&quot;string&quot;&gt;&#39;oauth_consumer_key&#39;&lt;/span&gt;] = consumer.key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    req = oauth.Request(method=method, url=url, parameters=params)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    req.sign_request(oauth.SignatureMethod_HMAC_SHA1(), consumer, &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; req&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url = &lt;span class=&quot;string&quot;&gt;&quot;http://yboss.yahooapis.com/geo/placefinder?&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    req = oauth_request(url, params=&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;q&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;lianyungang&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# This one is a bit nasty. Apparently the BOSS API does not like&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# &quot;+&quot; in its URLs so you have to replace &quot;%20&quot; manually.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Not sure if the API should be expected to accept either.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Not sure why to_url does not just return %20 instead...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Also, oauth2.Request seems to store parameters as unicode and forget&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# to encode to utf8 prior to percentage encoding them in its to_url&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# method. However, it&#39;s handled correctly for generating signatures.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# to_url fails when query parameters contain non-ASCII characters. To&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# work around, manually utf8 encode the request parameters.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    req[&lt;span class=&quot;string&quot;&gt;&#39;q&#39;&lt;/span&gt;] = req[&lt;span class=&quot;string&quot;&gt;&#39;q&#39;&lt;/span&gt;].encode(&lt;span class=&quot;string&quot;&gt;&#39;utf8&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    req_url = req.to_url().replace(&lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;%20&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; req_url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = urllib2.urlopen(req_url)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;github附书代码里有生成好的place.txt，直接拿来使用。下面代码中，distSLC用球面余弦定理计算地球表面两个点之间的距离，clusterClubs将文件中的地点进行聚类并画出结果。为了画出这些簇，首先创建一幅图和一个矩形，然后用该矩形决定绘制图的哪一部分。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;distSLC&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(vecA, vecB)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a = sin(vecA[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]*pi/&lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;) * sin(vecB[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]*pi/&lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b = cos(vecA[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]*pi/&lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;) * cos(vecB[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]*pi/&lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;) *\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     cos(pi*(vecB[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]-vecA[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])/&lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arccos(a+b)*&lt;span class=&quot;number&quot;&gt;6371.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clusterClubs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(numClust=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datList = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&#39;places.txt&#39;&lt;/span&gt;).readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineArr = line.split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        datList.append([float(lineArr[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]), float(lineArr[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;])])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datMat = mat(datList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myCentroids, clustAssing = biKmeans(datMat, numClust, distMeas = distSLC)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rect = [&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.8&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scatterMarkers = [&lt;span class=&quot;string&quot;&gt;&#39;s&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;o&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;^&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;8&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;p&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;v&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;h&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&amp;gt;&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    axprops = dict(xticks=[], yticks=[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax0 = fig.add_axes(rect, label = &lt;span class=&quot;string&quot;&gt;&#39;ax0&#39;&lt;/span&gt;, **axprops)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imgP = plt.imread(&lt;span class=&quot;string&quot;&gt;&#39;Portland.png&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax0.imshow(imgP)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax1 = fig.add_axes(rect, label = &lt;span class=&quot;string&quot;&gt;&#39;ax1&#39;&lt;/span&gt;, frameon = &lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numClust):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ptsInCurrCluster = datMat[nonzero(clustAssing[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A == i)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        markerSytle = scatterMarkers[i%len(scatterMarkers)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ax1.scatter(ptsInCurrCluster[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ptsInCurrCluster[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            marker = markerSytle, s=&lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax1.scatter(myCentroids[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], myCentroids[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        marker = &lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;, s=&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行结果如下，分别是划分为5个簇、7个簇的情况。多次运行可以找到最佳的分簇数目和方法。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch10-%E5%9C%B0%E5%9B%BE%E7%82%B9%E8%81%9A%E7%B1%BB.png&quot; width=&quot;400px&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch10-%E5%9C%B0%E5%9B%BE%E7%82%B9%E8%81%9A%E7%B1%BB-7.png&quot; width=&quot;400px&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch10-%E5%9C%B0%E5%9B%BE%E7%82%B9%E8%81%9A%E7%B1%BB-7-2.png&quot; width=&quot;400px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;K-均值聚类算法总结&quot;&gt;&lt;a href=&quot;#K-均值聚类算法总结&quot; class=&quot;headerlink&quot; title=&quot;K-均值聚类算法总结&quot;&gt;&lt;/a&gt;K-均值聚类算法总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;无监督学习指事先不知道要寻找的内容，没有目标变量。聚类将数据点归到多个簇中，可以使用多种方法计算相似度，实际使用时也应多次运行取较优结果。K-均值算法是一种广泛使用的聚类算法，k是用户指定的要创建的簇的数目，该算法非常有效但容易受到初始簇质心的影响。可以使用二分K-均值聚类算法获得更好的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/21/machinelearning10/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/21/machinelearning10/&quot;&gt;http://forec.github.io/2016/02/21/machinelearning10/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;聚类是一种无监督学习，将相似的对象归到同一个簇中，类似全自动分类，即类别体系也是自动构建的。聚类方法几乎可以应用于所有对性，簇内的对象越相似，聚类效果越好。K-均值聚类算法可以发现k个不同的簇，且每个簇的中心采用簇中所含值的均值构成。聚类与分类的区别在于，分类的目标事先已知，而聚类未知。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 09 - 树回归）</title>
    <link href="http://forec.github.io/2016/02/20/machinelearning9/"/>
    <id>http://forec.github.io/2016/02/20/machinelearning9/</id>
    <published>2016-02-20T03:44:31.000Z</published>
    <updated>2016-02-22T13:33:54.209Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;第8章的线性回归创建的模型需要拟合所有的样本点（除了局部加权线性回归）。当数据拥有众多特征并且特征之间关系十分复杂时，构建全局模型的想法就比较困难，并且生活中很多问题是非线性的，无法用全局线性模型来拟合所有数据。一种方法是将数据集递归地切分成很多份易建模的数据，并对可以拟合的小数据集用线性回归建模。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;复杂数据的局部性建模&quot;&gt;&lt;a href=&quot;#复杂数据的局部性建模&quot; class=&quot;headerlink&quot; title=&quot;复杂数据的局部性建模&quot;&gt;&lt;/a&gt;复杂数据的局部性建模&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在Chapter03中介绍了贪心算法的决策树，构建算法是ID3，每次选取当前最佳特征来分割数据，并且按照这个特征的所有可能取值来划分，一旦切分完成，这个特征在之后的执行过程中不会再有任何用处。这种方法切分过于迅速，并且需要将连续型数据离散化后才能处理，这样就破坏了连续变量的内在性质。&lt;/li&gt;
&lt;li&gt;二元切分法是另一种树构建算法，每次将数据集切分成两半，如果数据的某个特征满足这个切分的条件，就将这些数据放入左子树，否则右子树。二元切分法也节省了树的构建时间，但树一般都是离线构建，因此意义不大。CART（Classification And Regression Trees，分类回归树）使用二元切分来处理连续型变量，并用&lt;code&gt;R^2&lt;/code&gt;取代香农熵来分析模型的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;连续和离散型特征的树的构建&quot;&gt;&lt;a href=&quot;#连续和离散型特征的树的构建&quot; class=&quot;headerlink&quot; title=&quot;连续和离散型特征的树的构建&quot;&gt;&lt;/a&gt;连续和离散型特征的树的构建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用字典存储树的数据结构，每个节点包含以下四个元素：待切分的特征、待切分的特征值、左子树、右子树。Chapter03中的每个节点可能有多个孩子，因此使用字典存储，而CART可以固定数据结构，因为每个非叶节点固定包含两个子树。下面创建回归树（叶节点包含单个值）和模型树（叶节点存储一个线性方程），创建树的代码可以重用，伪代码大致如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到最佳的待切分特征：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果该节点不能再分，将该节点存为叶节点&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;执行二元切分&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在左右子树分别递归调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CART算法实现 - regTrees.py。binSplitDataSet通过数组过滤切分数据集，createTree递归建立树，输入参数决定树的类型，leafType给出建立叶节点的函数，因此该参数也决定了要建立的是模型树还是回归树，errType代表误差计算函数，ops是一个包含树构建所需的其他参数的元组。代码中的chooseBestSplit函数选取最佳分类方式，尚未实现。github上的附书源码有错误，binSplitDataSet的两行最后没有&lt;code&gt;[0]&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fileName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fr = open(fileName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curLine = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fltLine = map(float, curLine)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataMat.append(fltLine)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binSplitDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, feature, value)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat0 = dataSet[nonzero(dataSet[:,feature] &amp;gt; value)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], :]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat1 = dataSet[nonzero(dataSet[:,feature] &amp;lt;= value)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], :]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mat0, mat1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, leafType = regLeaf, errType = regErr, ops=&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    feat, val = chooseBestSplit(dataSet, leafType, errType, ops)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; feat == &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; val&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retTree = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retTree[&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;] = feat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retTree[&lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;] = val&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lSet, rSet = binSplitDataSet(dataSet, feat, val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retTree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;] = createTree(lSet, leafType, errType, ops)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retTree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;] = createTree(rSet, leafType, errType, ops)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retTree&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;将CART算法用于回归&quot;&gt;&lt;a href=&quot;#将CART算法用于回归&quot; class=&quot;headerlink&quot; title=&quot;将CART算法用于回归&quot;&gt;&lt;/a&gt;将CART算法用于回归&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;如何实现数据切分要取决于叶节点的建模方式，回归树假设叶节点是常数值，可以通过计算数据的总方差代替香农熵判断数据的混乱度。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数chooseBestSplit的目标是找到数据切分的最佳位置，它遍历所有的特征及其可能的取值来找到使误差最小化的划分阈值。伪代码大致如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对每个特征：对每个特征值：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将数据集划分为两份&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;计算切分的误差&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;若当前误差小于最小误差，则更新&lt;/li&gt;
&lt;li&gt;返回最佳切分特征和阈值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回归树切分函数 - regTrees.py，regLeaf负责生成叶节点，在回归树中，该模型是目标变量的均值。regErr是误差估计函数，计算目标变量总方差。chooseBestSplit的参数中为ops设定了tolS和tolN，tolS是容许的误差下降值，tolN是切分的最小样本数。在三种情况下chooseBestSplit会停止切分：误差下降不够大、切分子集数目小、剩余的特征值都相同。github的附书源码也有问题，chooseBestSplit函数中，&lt;code&gt;for splitVal in set(dataSet[:,featIndex]):&lt;/code&gt;要增加&lt;code&gt;.T.tolist()[0]&lt;/code&gt;否则会报无法hash的错误。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;regLeaf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mean(dataSet[:,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;regErr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; var(dataSet[:,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) * shape(dataSet)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;chooseBestSplit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet, leafType = regLeaf, errType = regErr, ops = &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tolS = ops[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]; tolN = ops[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(set(dataSet[:,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].T.tolist()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])) == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, leafType(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m, n = shape(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    S = errType(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bestS = inf; bestIndex = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; bestValue = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; featIndex &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; splitVal &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; set(dataSet[:,featIndex].T.tolist()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mat0, mat1 = binSplitDataSet(dataSet, featIndex, splitVal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (shape(mat0)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt; tolN) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; (shape(mat1)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt; tolN):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            newS = errType(mat0) + errType(mat1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; newS &amp;lt; bestS:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestIndex = featIndex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestValue = splitVal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestS = newS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (S - bestS) &amp;lt; tolS:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, leafType(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat0, mat1 = binSplitDataSet(dataSet, bestIndex, bestValue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (shape(mat0)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt; tolN) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; (shape(mat1)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &amp;lt; tolN):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, leafType(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bestIndex, bestValue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试代码效果，数据来自ex00.txt和ex0.txt，用matplotlib绘制的图像如下。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch09-ex00%E6%95%B0%E6%8D%AE%E7%82%B9%E5%88%86%E5%B8%83.png&quot; width=&quot;500px&quot;&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch09-ex0%E6%95%B0%E6%8D%AE%E7%82%B9%E5%88%86%E5%B8%83.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;reload(regTrees)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myDat = mat(regTrees.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;ex00.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regTrees.createTree(myMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.48813&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;: -&lt;span class=&quot;number&quot;&gt;0.044650285714285719&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1.0180967672413792&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myDat1 = mat(regTrees.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;ex0.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regTrees.createTree(myDat1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.39435&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.197834&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;: -&lt;span class=&quot;number&quot;&gt;0.023838155555555553&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1.0289583666666666&lt;/span&gt;&amp;#125;, &lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.582002&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1.980035071428571&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.797583&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2.9836209534883724&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3.9871631999999999&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;树剪枝&quot;&gt;&lt;a href=&quot;#树剪枝&quot; class=&quot;headerlink&quot; title=&quot;树剪枝&quot;&gt;&lt;/a&gt;树剪枝&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;如果树节点过多，则该模型可能对数据过拟合，通过降低决策树的复杂度来避免过拟合的过程称为剪枝。在函数chooseBestSplit中的三个提前终止条件是“预剪枝”操作，另一种形式的剪枝需要使用测试集和训练集，称作“后剪枝”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;预剪枝&quot;&gt;&lt;a href=&quot;#预剪枝&quot; class=&quot;headerlink&quot; title=&quot;预剪枝&quot;&gt;&lt;/a&gt;预剪枝&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;树构建算法对输入的tolS和tolN非常敏感，将ops换为(0,1)会发现生成的树非常臃肿，几乎为数据集中的每个样本都分配了一个叶节点。加载ex2.txt的数据，该数据集和前面ex00.txt的数据分布类似，但数量级是后者的100倍，在这种情况下，ex00构建出的树只有两个叶节点，而ex2构建出的树有非常多的叶节点。原因在于停止条件tolS对误差的数量级非常敏感。显然，通过不断修改停止条件并且比较哪个条件更好并不合理，多数情况下我们并不确定要寻找什么样的结果，计算机应该给出总体的概貌。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;后剪枝&quot;&gt;&lt;a href=&quot;#后剪枝&quot; class=&quot;headerlink&quot; title=&quot;后剪枝&quot;&gt;&lt;/a&gt;后剪枝&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用后剪枝方法需要将数据集交叉验证，首先给定参数，使得构建出的树足够复杂，之后从上而下找到叶节点，判断合并两个叶节点是否能够取得更好的测试误差，如果是就合并。下面是回归树剪枝函数。函数isTree测试输入变量是否为一棵树，getMean对树进行塌陷处理，计算整棵树的平均值。prune函数对树剪枝，参数tree为待剪枝的树，testData是测试集。需要注意的是，测试集合训练集样本的取值范围不一定相同。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(obj)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (type(obj).__name__ ==&lt;span class=&quot;string&quot;&gt;&#39;dict&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMean&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tree)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;]): tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;] = getMean(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;]): tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;] = getMean(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;] + tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;])/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;prune&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tree, testData)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; shape(testData)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; getMean(tree)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;])):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lSet, rSet = binSplitDataSet(testData, tree[&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;], tree[&lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;]): tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;] = prune(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;], lSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;]): tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;] = prune(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;], rSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lSet, rSet = binSplitDataSet(testData, tree[&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;], tree[&lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errNoMerge = sum(power(lSet[:,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)) +\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sum(power(rSet[:,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        treeMean = (tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;]+tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;])/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorMerge = sum(power(testData[:,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - treeMean, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; errorMerge &amp;lt; errNoMerge:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;merging&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; treeMean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tree&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tree&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;模型树&quot;&gt;&lt;a href=&quot;#模型树&quot; class=&quot;headerlink&quot; title=&quot;模型树&quot;&gt;&lt;/a&gt;模型树&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将叶节点设置为分段线性函数，分段线性指模型由多个线性片段组成。例如下图的数据，可以由0.0~0.3和0.3~1.0的两条直线组成。决策树相比其他机器学习算法易于理解，而模型树的可解释性是它优于回归树的特性之一。模型树同时具备更高的预测准确度。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch09-%E6%A8%A1%E5%9E%8B%E6%A0%91%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;前面的代码已经给出了构建树的代码，只要修改参数errType和leafType。对于给定的数据集，先用现行的模型对它进行拟合，然后计算真实目标值和模型预测值之间的差距。最后求这些差值的平方和作为误差。modelLeaf函数生成叶节点，linearSolve返回回归系数，modelErr在数据集上调用linearSove，返回yHat和y之间的平方误差。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;linearSolve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m, n = shape(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    X = mat(ones((m,n))); Y = mat(ones((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    X[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:n] = dataSet[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]; Y = dataSet[:,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xTx = X.T * X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; linalg.det(xTx) == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; NameError(&lt;span class=&quot;string&quot;&gt;&#39;This matrix is singular, cannot do inverses,\n\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            try increasing the second value of ops&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ws = xTx.I * (X.T * Y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ws, X, Y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;modelLeaf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ws, X, Y = linearSolve(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;modelErr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataSet)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ws, X, Y = linearSolve(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yHat = X * ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum(power(Y - yHat, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myMat2 = mat(regTrees.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;exp2.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regTrees.createTree(myMat2, regTrees.modelLeaf, regTrees.modelErr, (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.285477&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;: matrix([[ &lt;span class=&quot;number&quot;&gt;3.46877936&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [ &lt;span class=&quot;number&quot;&gt;1.18521743&lt;/span&gt;]]), &lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;: matrix([[  &lt;span class=&quot;number&quot;&gt;1.69855694e-03&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;1.19647739e+01&lt;/span&gt;]])&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;树回归和标准回归的比较&quot;&gt;&lt;a href=&quot;#树回归和标准回归的比较&quot; class=&quot;headerlink&quot; title=&quot;树回归和标准回归的比较&quot;&gt;&lt;/a&gt;树回归和标准回归的比较&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于输入的单个数据点，函数treeForeCast返回一个预测值。参数modelEval是对叶节点数据进行预测的函数的引用，函数treeForeCast自顶向下遍历整棵树，直到命中叶节点为止。一旦到达叶节点，它会在输入数据上调用modelEval，该参数默认值是regTreeEval。要对回归树叶节点预测，就调用regTreeEval，要对模型树节点预测，调用modelTreeEval。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;regTreeEval&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(model, inDat)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; float(model)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;modelTreeEval&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(model, inDat)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n = shape(inDat)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    X = mat(ones((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    X[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = inDat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; float(X*model)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;treeForeCast&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tree, inData, modelEval = regTreeEval)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; isTree(tree): &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; modelEval(tree, inData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; inData[tree[&lt;span class=&quot;string&quot;&gt;&#39;spInd&#39;&lt;/span&gt;]] &amp;gt; tree[&lt;span class=&quot;string&quot;&gt;&#39;spVal&#39;&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; treeForeCast(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;], inData, modelEval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; modelEval(tree[&lt;span class=&quot;string&quot;&gt;&#39;left&#39;&lt;/span&gt;], inData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; isTree(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; treeForeCast(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;], inData, modelEval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; modelEval(tree[&lt;span class=&quot;string&quot;&gt;&#39;right&#39;&lt;/span&gt;], inData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createForeCast&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tree, testData, modelEval = regTreeEval)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = len(testData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yHat = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        yHat[i,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = treeForeCast(tree, mat(testData[i]), modelEval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; yHat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较回归树、模型树和标准线性回归的&lt;code&gt;R^2&lt;/code&gt;数值。可以看出，模型树的结果比回归树好，而树回归方法在预测复杂数据时会比简单的线性模型更有效。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;trainMat = mat(regTrees.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;bikeSpeedVsIq_train.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;testMat = mat(regTrees.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;bikeSpeedVsIq_test.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myTree = regTrees.createTree(trainMat, ops=(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat = regTrees.createForeCast(myTree, testMat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;corrcoef(yHat, testMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], rowvar=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.96408523182221395&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;myTree = regTrees.createTree(trainMat, regTrees.modelLeaf, regTrees.modelErr, ops=(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat = regTrees.createForeCast(myTree, testMat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], regTrees.modelTreeEval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;corrcoef(yHat, testMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], rowvar=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.97604121913806363&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ws, X, Y = regTrees.linearSolve(trainMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix([[ &lt;span class=&quot;number&quot;&gt;37.58916794&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [  &lt;span class=&quot;number&quot;&gt;6.18978355&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(shape(testMat)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;... &lt;/span&gt;    yHat[i] = testMat[i,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]*ws[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+ws[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;corrcoef(yHat, testMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], rowvar=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.94346842356747584&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Tkinter库创建GUI&quot;&gt;&lt;a href=&quot;#Tkinter库创建GUI&quot; class=&quot;headerlink&quot; title=&quot;Tkinter库创建GUI&quot;&gt;&lt;/a&gt;Tkinter库创建GUI&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Tkinter模块的.grid()方法将widget安排在一个二维表格内，，默认widget会显示在0行0列，可以通过设定columnspan和rowspan来告诉布局管理器是否允许一个widget跨行或跨列。界面代码如下 - treeExplore.py。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; Tkinter &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; regTrees&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;redraw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tolS, tolN)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;drawNewTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root = Tk()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Label(root, text=&lt;span class=&quot;string&quot;&gt;&quot;Plot Place Holder&quot;&lt;/span&gt;).grid(row = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, columnspan = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Label(root, text=&lt;span class=&quot;string&quot;&gt;&quot;tolN&quot;&lt;/span&gt;).grid(row = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, column = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolNentry = Entry(root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolNentry.grid(row = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, column = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolNentry.insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;10&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Label(root, text=&lt;span class=&quot;string&quot;&gt;&quot;tolS&quot;&lt;/span&gt;).grid(row = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, column =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolSentry = Entry(root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolSentry.grid(row = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, column = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tolSentry.insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;1.0&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Label(root, text=&lt;span class=&quot;string&quot;&gt;&quot;path&quot;&lt;/span&gt;).grid(row = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, column = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;datPentry = Entry(root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;datPentry.grid(row = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, column = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;datPentry.insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;sine.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Button(root, text=&lt;span class=&quot;string&quot;&gt;&quot;ReDraw&quot;&lt;/span&gt;, command = drawNewTree).grid(row = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, column =&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, rowspan =&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chkBtnVar = IntVar()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chkBtn = Checkbutton(root, text=&lt;span class=&quot;string&quot;&gt;&quot;Model Tree&quot;&lt;/span&gt;, variable = chkBtnVar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chkBtn.grid(row = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, column = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, columnspan=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reDraw.rawDat = mat(regTrees.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;sine.txt&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reDraw.testDat = arange(min(reDraw.rawDat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), max(reDraw.rawDat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reDraw(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root.mainloop()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Matplotlib的构建程序包含一个前端面向用户，如plot和scatter方法等，同时创建一个后端，用于实现绘图和不同应用程序之间的接口。改变后端可以将图像绘制不同格式的文件上，将后端在设置为TkAgg，可以在所选GUI框架上调用Agg，呈现在画布上。下面的代码填补了上面的两个占位函数，另外将上面代码中加载文件的语句移入了按钮事件。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matplotlib.use(&lt;span class=&quot;string&quot;&gt;&#39;TkAgg&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; matplotlib.backends.backend_tkagg &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; FigureCanvasTkAgg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; matplotlib.figure &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Figure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reDraw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tolS, tolN)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reDraw.f.clf()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reDraw.a = reDraw.f.add_subplot(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; chkBtnVar.get():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; tolN &amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: tolN = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        myTree = regTrees.createTree(reDraw.rawDat, regTrees.modelLeaf, regTrees.modelErr, (tolS, tolN))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        yHat = regTrees.createForeCast(myTree, reDraw.testDat, regTrees.modelTreeEval)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        myTree = regTrees.createTree(reDraw.rawDat, ops=(tolS, tolN))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        yHat = regTrees.createForeCast(myTree, reDraw.testDat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reDraw.a.scatter(reDraw.rawDat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], reDraw.rawDat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], s=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reDraw.a.plot(reDraw.testDat, yHat, linewidth = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reDraw.canvas.show()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getInputs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;: tolN = int(tolNentry.get())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolN = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;enter Integer for tolN&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolNentry.delete(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, END)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolNentry.insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;10&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;: tolS = float(tolSentry.get())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolS = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;enter Integer for tolS&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolSentry.delete(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, END)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolSentry.insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;1.0&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;: datPath = str(datPentry.get())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        datPath = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;enter path for test data&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolSentry.delete(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, END)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tolSentry.insert(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; datPath, tolS, tolN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;drawNewTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datPath, tolS, tolN = getInputs()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reDraw.rawDat = mat(regTrees.loadDataSet(datPath))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reDraw.testDat = arange(min(reDraw.rawDat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), max(reDraw.rawDat[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reDraw(tolS, tolN)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Cannot find file %s&quot;&lt;/span&gt; % datPath&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绘制出的GUI界面如下。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch09-gui%E7%95%8C%E9%9D%A21.png&quot; width=&quot;400px&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch09-gui%E7%95%8C%E9%9D%A22.png&quot; width=&quot;400px&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch09-gui%E7%95%8C%E9%9D%A23.png&quot; width=&quot;400px&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch09-gui%E7%95%8C%E9%9D%A24.png&quot; width=&quot;400px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/20/machinelearning9/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/20/machinelearning9/&quot;&gt;http://forec.github.io/2016/02/20/machinelearning9/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;第8章的线性回归创建的模型需要拟合所有的样本点（除了局部加权线性回归）。当数据拥有众多特征并且特征之间关系十分复杂时，构建全局模型的想法就比较困难，并且生活中很多问题是非线性的，无法用全局线性模型来拟合所有数据。一种方法是将数据集递归地切分成很多份易建模的数据，并对可以拟合的小数据集用线性回归建模。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 08 - 回归）</title>
    <link href="http://forec.github.io/2016/02/18/machinelearning8/"/>
    <id>http://forec.github.io/2016/02/18/machinelearning8/</id>
    <published>2016-02-18T12:07:58.000Z</published>
    <updated>2016-02-22T13:33:54.855Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;回归是前面监督学习方法的延续，监督学习指的是有目标变量或者预测目标的机器学习方法。回归于分类的不同在于其目标变量是连续数值型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;线性回归找到最佳拟合曲线&quot;&gt;&lt;a href=&quot;#线性回归找到最佳拟合曲线&quot; class=&quot;headerlink&quot; title=&quot;线性回归找到最佳拟合曲线&quot;&gt;&lt;/a&gt;线性回归找到最佳拟合曲线&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;线性回归结果易于理解，计算上不复杂，但对非线性的数据拟合不好。适用于数值型和标称型数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回归的目的是预测数值型的目标值&lt;/strong&gt;。最直接的办法是根据输入写出一个目标值的计算公式，这个公式就是回归方程。求解回归系数的过程就是回归。回归一般指线性回归，本章中二者同义。线性回归意味着可以将输入项分别乘以一些常量，再将结果加起来得到输出，而非线性回归模型则认为输出可能是输入的乘积。&lt;/li&gt;
&lt;li&gt;回归的一般方法&lt;ul&gt;
&lt;li&gt;收集数据：任意方法&lt;/li&gt;
&lt;li&gt;准备数据：需要数值型数据，标称型数据将被转换成二值型数据。&lt;/li&gt;
&lt;li&gt;分析数据：绘出数据的可视化二维图有助于对数据做出理解和分析。在采用所见发求得新回归系数后，可以将新拟合线在图上作为对比。&lt;/li&gt;
&lt;li&gt;训练算法：找到回归系数。&lt;/li&gt;
&lt;li&gt;测试算法：使用R^2或者预测值和数据的拟合度来分析模型的效果。&lt;/li&gt;
&lt;li&gt;使用算法：使用回归可以在给定一个输入的时候预测一个数值，这是对分类方法的提升，可以预测连续性数据而不仅仅是离散的类别标签。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;求解回归系数：假定输入数据存放在矩阵X中，回归系数存放在向量W中，对于给定的数据X1，预测结果会通过Y1=X^T·W给出。要找到W，最常用的方法是找出使误差最小的W。误差指预测y值和真实y值之间的差值，使用该误差的简单累加会使正负误差相互抵消，因此采用平方误差。平方误差写作&lt;code&gt;∑(y&amp;#39;-x^T·W)^2&lt;/code&gt;，用矩阵表示写作&lt;code&gt;(y-Xw)^T·(y-Xw)&lt;/code&gt;，如果对w求导，就得到&lt;code&gt;X^T·(Y-Xw)&lt;/code&gt;，令其为零，解出&lt;code&gt;w=(X^T·X)^(-1)·X^T·y&lt;/code&gt;。注意公式中包含了&lt;code&gt;(X^T·X)^(-1)&lt;/code&gt;，因此要在代码中判断矩阵是否可逆。该方法称为&lt;strong&gt;OLS&lt;/strong&gt;（普通最小二乘法）。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是原始数据点的分布&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch08-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%82%B9.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标准回归函数和数据导入函数 - regression.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fileName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    numFeat = len(open(fileName).readline().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataMat = []; labelMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fr = open(fileName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineArr = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curLine = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numFeat):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lineArr.append(float(curLine[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataMat.append(lineArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        labelMat.append(float(curLine[-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat, labelMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;standRegres&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(xArr, yArr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = mat(xArr); yMat = mat(yArr).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xTx = xMat.T * xMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; linalg.det(xTx) == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;This matrix is singular, cannot do reverse&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ws = xTx.I * (xMat.T * yMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ws&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成的线性回归效果图如下&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/ch08-%E6%A0%87%E5%87%86%E5%9B%9E%E5%BD%92%E5%87%BD%E6%95%B0.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Numpy库提供了corrcoef(yEstimate, yActure)方法来计算预测值和真实值的相关性。下面的交互代码结果中，yMat和自己匹配是最完美的，而yHat和yMat的相关系数为0.98。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat = xMat * ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;corrcoef(yHat.T, yMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array([[&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;        , &lt;span class=&quot;number&quot;&gt;0.98647356&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [&lt;span class=&quot;number&quot;&gt;0.98647356&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;        ]])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;局部加权线性回归-LWLR&quot;&gt;&lt;a href=&quot;#局部加权线性回归-LWLR&quot; class=&quot;headerlink&quot; title=&quot;局部加权线性回归 LWLR&quot;&gt;&lt;/a&gt;局部加权线性回归 LWLR&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;最佳拟合直线方法将数据视为直线建模，但数据似乎有其他潜在模式。线性回归的一个问题是有可能出现欠拟合现象，因为他求的是具有最小均方误差的无偏估计。因此有些方法允许在估计中引入一些偏差，从而降低预测的均方误差。其中一个方法是局部加权线性回归（Locally Weighted Linear Regression）。在该算法中，为待测点附近的每个点赋予一定的权重，然后在这个子集上基于最小均方差来进行普通的回归。和kNN一样，这种算法每次预测都需要先选取出对应的数据子集。解出回归系数w的形式如下&lt;code&gt;w=(X^T·WX)^(-1)·X^T·W·y&lt;/code&gt;，其中W是一个矩阵，用来给每个数据点赋予权重。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LWLR使用“核”（和SVM类似）来为附近的点赋予更高的权重。类似kNN，&lt;strong&gt;LWLR认为样本点距离越近，越有可能符合同一个线性模型&lt;/strong&gt;。高斯核对应权重如下&lt;code&gt;w(i,i) = exp(|x&amp;#39;-x|/(-2k^2))&lt;/code&gt;。这样就构建了只含对角元素的权重矩阵W，并且点x和x(i)越近，w(i,i)就越大。参数k由用户指定，决定了对附近的点赋予多大的权重。当k较大时，更多的数据被用来训练回归模型，当k较小时，仅有很少的局部点被用来训练回归模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部加权线性回归函数 - regression.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lwlr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(testPoint, xArr, yArr, k = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = mat(xArr); yMat = mat(yArr).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = shape(xMat)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    weights = mat(eye(m))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        diffMat = testPoint - xMat[j,:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        weights[j,j] = exp(diffMat*diffMat.T/(-&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;*k**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xTx = xMat.T * (weights * xMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; linalg.det(xTx) == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;This matrix is singular, cannot do reverse&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ws = xTx.I * (xMat.T * (weights * yMat))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; testPoint * ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lwlrTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(testArr, xArr, yArr, k = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = shape(testArr)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yHat = zeros(m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        yHat[i] = lwlr(testArr[i], xArr, yArr, k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; yHat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加代码绘制在不同k的情况下局部加权线性回归结果的拟合情况。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;drawPlotAboutK&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xArr, yArr = loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;ex0.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = mat(xArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    srtInd = xMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].argsort(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xSrot = xMat[srtInd][:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;211&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yHat01 = lwlrTest(xArr, xArr, yArr, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax.plot(xSrot[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],yHat01[srtInd])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax.scatter(xMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], mat(yArr).T.flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], s =&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, c=&lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;212&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yHat001 = lwlrTest(xArr, xArr, yArr, &lt;span class=&quot;number&quot;&gt;0.003&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax.plot(xSrot[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],yHat001[srtInd])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ax.scatter(xMat[:,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], mat(yArr).T.flatten().A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], s =&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, c=&lt;span class=&quot;string&quot;&gt;&#39;green&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面代码绘制出结果如下，可以看出当k=0.003时纳入了太多的噪声点，k=1时的结果和使用最小二乘法的标准线性回归类似，k=0.01时的模型效果最好，平滑并且挖掘出数据内在规律。上图是k=0.01的情况，下图是k=0.003的情况。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/%E4%B8%8D%E5%90%8Ck%E5%8F%96%E5%80%BC%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%9B%9E%E5%BD%92%E7%BB%93%E6%9E%9C.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;局部加权线性回归也存在问题，即增加了计算量。因为其对每个点做预测时都要使用整个数据集，虽然k=0.01时得到了很好的估计，但大多数数据点的权重接近0，如果避免这些运算，可以减少程序运行时间，从而缓解因计算量增加带来的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;预测鲍鱼年龄&quot;&gt;&lt;a href=&quot;#预测鲍鱼年龄&quot; class=&quot;headerlink&quot; title=&quot;预测鲍鱼年龄&quot;&gt;&lt;/a&gt;预测鲍鱼年龄&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;向regression.py中加入下面代码，用于计算两个参数间误差的大小。可以看出，使用较小的核会得到较低的误差，但使用较小的核会造成过拟合，对新数据不一定能达到最好的预测效果。在新数据中，核大小等于10时误差最小，但核为10时的训练误差却是最大的。通过比较，简单线性回归达到了与局部加权线性回归相似的效果，因此必须&lt;strong&gt;在未知数据集上比较效果才能选取到最佳模型&lt;/strong&gt;。&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rssError&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(yArr, yHatArr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((yArr - yHatArr)**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).sum()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;abX, abY = regression.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;abalone.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat01 = regression.lwlrTest(abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat1 = regression.lwlrTest(abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat10 = regression.lwlrTest(abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.rssError(abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], yHat01.T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;56.782850757712595&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.rssError(abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], yHat1.T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;429.89056187011101&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.rssError(abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], yHat10.T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;549.11817088259465&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat01 = regression.lwlrTest(abX[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;], abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat1 = regression.lwlrTest(abX[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;], abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat10 = regression.lwlrTest(abX[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;], abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.rssError(abY[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;], yHat01.T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;14772.633501680577&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.rssError(abY[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;], yHat1.T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;573.5261441898798&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.rssError(abY[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;], yHat10.T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;517.57119053849158&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ws = regression.standRegres(abX[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;], abY[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yHat = mat(abX[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;]) * ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.rssError(abY[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;199&lt;/span&gt;], yHat.T.A)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;518.63631532464785&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;缩减系数来“理解”数据&quot;&gt;&lt;a href=&quot;#缩减系数来“理解”数据&quot; class=&quot;headerlink&quot; title=&quot;缩减系数来“理解”数据&quot;&gt;&lt;/a&gt;缩减系数来“理解”数据&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;当数据特征数大于样本点，此时输入数据的矩阵X不是满秩矩阵，因此计算&lt;code&gt;(X^T·X)^(-1)&lt;/code&gt;时会出错。为了解决该问题，引入“岭回归”（ridge regression）概念和lasso方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;岭回归&quot;&gt;&lt;a href=&quot;#岭回归&quot; class=&quot;headerlink&quot; title=&quot;岭回归&quot;&gt;&lt;/a&gt;岭回归&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单说岭回归就是在矩阵X^T·X上增加一个λI从而使矩阵非奇异，进而能对&lt;code&gt;X^T·X+λI&lt;/code&gt;求逆，其中矩阵I是一个m·m的单位矩阵。在这种情况下，回归系数的计算公式为&lt;code&gt;(X^T·X+λI)^(-1)·X^T·y)&lt;/code&gt;。岭回归最先用来处理特征数多于样本数的情况，现在也用于在估计中加入偏差，从而得到更好的估计。这里通过引入λ来限制了所有w的和，通过引入该惩罚项，能够减少不重要的参数，称为“缩减”，缩减方法可以去掉不重要的参数，因此能更好的理解数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面的代码包含计算回归系数的ridgeRegres函数和用于在一组λ上测试的ridgeTest函数。为了使用岭回归和缩减技术，首先要对数据标准化处理，使每维数据具有同样的重要性。具体的做法是所有特征都减去各自的均值并除以方差。代码中的λ以指数级变化，可以看出λ在去非常小的值和非常大的值时对结果造成的不同影响。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ridgeRegres&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(xMat, yMat, lam = &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xTx = xMat.T * xMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    denom = xTx + eye(shape(xMat)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) * lam&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; linalg.det(denom) == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;This matrix is singular, cannot do reverse&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ws = denom.I * (xMat.T * yMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ridgeTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(xArr, yArr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = mat(xArr); yMat = mat(yArr).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yMean = mean(yMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yMean1 = mean(yMat, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; yMean, yMean1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yMat = yMat - yMean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMeans = mean(xMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xVar = var(xMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = (xMat - xMeans) / xVar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    numTestPts = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wMat = zeros((numTestPts, shape(xMat)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numTestPts):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ws = ridgeRegres(xMat, yMat, exp(i-&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wMat[i,:] = ws.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; wMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;abX, abY = regression.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;abalone.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ridgeWeights = regression.ridgeTest(abX, abY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ax = fig.add_subplot(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;ax.plot(ridgeWeights)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面代码最后的cpython交互部分代码给出了岭回归的回归系数变化图，如下。在最左边即λ最小时，可以得到所有系数的原始值（和线性回归一致），在最右边，系数全部缩减为0。在中间的某个值可以取得最好的预测效果。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/%E5%B2%AD%E5%9B%9E%E5%BD%92%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0%E5%8F%98%E5%8C%96%E5%9B%BE.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;lasso&quot;&gt;&lt;a href=&quot;#lasso&quot; class=&quot;headerlink&quot; title=&quot;lasso&quot;&gt;&lt;/a&gt;lasso&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在增加约束&lt;code&gt;∑w^2&amp;lt;=λ&lt;/code&gt;的情况下，普通的最小二乘法会得到与岭回归同样的公式，这个限制条件限定了所有回归系数的平方和不能大于λ。使用普通的最小二乘法回归在当两个或更多的特征相关时，可能会得出一个很大的正系数和一个很大的负系数。正是因为上面限制条件的存在，岭回归可以避免这个问题。与岭回归类似，另一个缩减方法lasso也对回归系数做了限定，但约束为&lt;code&gt;∑|w|&amp;lt;=λ&lt;/code&gt;，这个约束条件用绝对值取代平方和。虽然形式变化不大，但结果差距明显。当λ足够小时，一些系数会因此被迫缩减到0，这个特性可以帮助我们更好地理解数据。在这个新的约束条件下求解回归系数极大的增加了计算复杂度，需要使用二次规划算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前向逐步回归&quot;&gt;&lt;a href=&quot;#前向逐步回归&quot; class=&quot;headerlink&quot; title=&quot;前向逐步回归&quot;&gt;&lt;/a&gt;前向逐步回归&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前向逐步回归算法可以得到与lasso差不多的效果，但更简单。它属于一种贪心算法，即每一步尽可能减少误差。一开始所有权重设为1，然后每一步的决策是对某个权重增加或减少一个很小的值。伪代码如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据标准化，使其满足0均值和单位方差&lt;/li&gt;
&lt;li&gt;在每轮迭代过程中：设置当前最小误差lowestError为正无穷。&lt;/li&gt;
&lt;li&gt;在每轮迭代过程中：对每个特征：增大或减小：改变一个系数得到新的W，计算新W的误差，如果误差Error小于当前最小误差lowestError，设置Wbest等于当前的W。&lt;/li&gt;
&lt;li&gt;返回Wbest&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前向逐步线性回归函数 - regression.py。stageWise是逐步线性回归算法的实现，输入包括输入数据xArr和预测变量yArr，每次迭代要调整的步长eps和迭代次数numIt。函数首先将输入数据转换并存入矩阵，然后把特征按照均值为0方差为1进行标准化处理。之后迭代numIt次，更新最佳W矩阵。从运行得出的数据看出，w1和w6都是0，队结果没有任何影响，因此这两个特征很可能是不需要的。另外，在eps=0.01的情况下，一段时间后系数就已经在特定值之间来回震荡，这是因为步长太大，如第一个特征在0.04和0.05之间震荡。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stageWise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(xArr, yArr, eps=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, numIt = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = mat(xArr); yMat = mat(yArr).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yMean = mean(yMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yMat = yMat - yMean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = regularize(xMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m, n = shape(xMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnMat = zeros((numIt, n))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ws = zeros((n,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)); wsTest = ws.copy(); wsMax = ws.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numIt):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; ws.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lowestError = inf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; sign &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wsTest = ws.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                wsTest[j] += eps*sign&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                yTest = xMat * wsTest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rssE = rssError(yMat.A, yTest.A)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; rssE &amp;lt; lowestError:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    lowestError = rssE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    wsMax = wsTest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ws = wsMax.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        returnMat[i,:] = ws.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.stageWise(xArr, yArr, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array([[ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  , ...,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  , ...,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  , ...,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ...,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.05&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.09&lt;/span&gt;, ..., -&lt;span class=&quot;number&quot;&gt;0.64&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.36&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.04&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.09&lt;/span&gt;, ..., -&lt;span class=&quot;number&quot;&gt;0.64&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.36&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.05&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.09&lt;/span&gt;, ..., -&lt;span class=&quot;number&quot;&gt;0.64&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;  ,  &lt;span class=&quot;number&quot;&gt;0.36&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;换用更小的步长，并和常规最小二乘法比较。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;regression.stageWise(xArr, yArr, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array([[ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   , ...,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   , ...,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   , ...,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ,  &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;   ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ...,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.043&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.011&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.12&lt;/span&gt; , ..., -&lt;span class=&quot;number&quot;&gt;0.963&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.105&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.187&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.044&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.011&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.12&lt;/span&gt; , ..., -&lt;span class=&quot;number&quot;&gt;0.963&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.105&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.187&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [ &lt;span class=&quot;number&quot;&gt;0.043&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.011&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.12&lt;/span&gt; , ..., -&lt;span class=&quot;number&quot;&gt;0.963&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.105&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.187&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;xMat = mat(xArr); yMat = mat(yArr).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;xMat = regression.regularize(xMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yM = mean(yMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;yMat = yMat - yM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;weights = regression.standRegres(xMat, yMat.T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;weights.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;matrix([[ &lt;span class=&quot;number&quot;&gt;0.0430442&lt;/span&gt; , -&lt;span class=&quot;number&quot;&gt;0.02274163&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.13214087&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.02075182&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;2.22403814&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         -&lt;span class=&quot;number&quot;&gt;0.99895312&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;0.11725427&lt;/span&gt;,  &lt;span class=&quot;number&quot;&gt;0.16622915&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从数据可以看出，5000次迭代后，逐步线性回归算法和组常规的最小二乘法效果类似，使用0.001的ε值并经过5000次迭代的效果如下图。逐步线性回归算法的好处在于它可以帮助人们理解现有的模型并做出改进。当构建了一个模型后，可以运行该算法找出重要的特征，这样有可能及时停止那些不重要特征的收集。如果用于测试，该算法每100次迭代后就可以构建出一个模型，可以使用类似10折交叉验证的方法比较这些模型，选择误差最小的模型。&lt;strong&gt;当应用缩减方法（如逐步线性回归或岭回归）时，模型也就增加了偏差，与此同时减小了模型的方差&lt;/strong&gt;。&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/%E9%80%90%E6%AD%A5%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0%E4%B8%8E%E8%BF%AD%E4%BB%A3%E6%AC%A1%E6%95%B0%E5%85%B3%E7%B3%BB.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;权衡偏差与方差&quot;&gt;&lt;a href=&quot;#权衡偏差与方差&quot; class=&quot;headerlink&quot; title=&quot;权衡偏差与方差&quot;&gt;&lt;/a&gt;权衡偏差与方差&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;当发现模型和测量值之间存在差异，说明出现了误差。当对复杂的过程进行简化时，会导致模型和测量值之间出现“噪声”或者误差，若无法理解数据的真是生成过程，也会导致差异发生。另外，测量过程本身也可能产生“噪声”。&lt;/li&gt;
&lt;li&gt;如果降低核的大小，训练误差将变小，而测试误差则不一定。以模型复杂度为横轴，预测误差为纵轴，则训练误差的图象类似&lt;code&gt;y = e^(-x)&lt;/code&gt;，而测试误差的图像类似&lt;code&gt;y=(x-1)^2&lt;/code&gt;。使用缩减法将一些系数缩减成很小的值或直接缩减为0，这就减少了模型的复杂度。例子里有8个特征，消除其中两个既使模型易于理解，又降低了预测误差。&lt;/li&gt;
&lt;li&gt;方差可以度量，取任意两个随机样本集，得出的回归系数都是不同的，这些回归系数间的差异大小就是模型方差大小的反应。偏差（预测值和真实值）和方差（不同回归系数间差异）折中的概念在机器学习十分流行且反复出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;预测乐高玩具套装价格&quot;&gt;&lt;a href=&quot;#预测乐高玩具套装价格&quot; class=&quot;headerlink&quot; title=&quot;预测乐高玩具套装价格&quot;&gt;&lt;/a&gt;预测乐高玩具套装价格&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用回归法预测乐高套装价格流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集数据：使用Google Shopping的API。&lt;/li&gt;
&lt;li&gt;准备数据：从返回的json数据中抽取价格。&lt;/li&gt;
&lt;li&gt;分析数据：可视化并观察数据。&lt;/li&gt;
&lt;li&gt;训练算法：构建不同的模型，采用逐步线性回归和直接的线性回归模型。&lt;/li&gt;
&lt;li&gt;测试算法：使用交叉验证来测试不同的模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取购物信息的函数searchForSet和setDataCollect，regression.py。searchForSet函数调用google购物api并保证数据抽取的正确性。初始休眠10秒防止短时间内过多的api调用。对得到的数据用简单的方法判断是否为二手套装（价格低于原始价格一半），并过滤掉这些信息。似乎现在这个URL已经404错误了，当然是挂了VPN的情况下。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;searchForSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(retX, retY, setNum, yr, numPce, origPrc)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sleep(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myAPIstr = &lt;span class=&quot;string&quot;&gt;&#39;AIzaSyD2cR2KFyx12hXu6PFU-wrWot3NXvko8vY&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchURL = &lt;span class=&quot;string&quot;&gt;&#39;https://www.googleapis.com/shopping/search/v1/public/products?key=%s&amp;amp;country=US&amp;amp;q=lego+%d&amp;amp;alt=json&#39;&lt;/span&gt; % (myAPIstr, setNum)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pg = urllib2.urlopen(searchURL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retDict = json.loads(pg.read())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(retDict[&lt;span class=&quot;string&quot;&gt;&#39;items&#39;&lt;/span&gt;])):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            currItem = retDict[&lt;span class=&quot;string&quot;&gt;&#39;items&#39;&lt;/span&gt;][i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; currItem[&lt;span class=&quot;string&quot;&gt;&#39;product&#39;&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;condition&#39;&lt;/span&gt;] == &lt;span class=&quot;string&quot;&gt;&#39;new&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                newFlag = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                newFlag = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            listOfInv = currItem[&lt;span class=&quot;string&quot;&gt;&#39;product&#39;&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;inventories&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; listOfInv:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                sellingPrice = item[&lt;span class=&quot;string&quot;&gt;&#39;price&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sellingPrice &amp;gt; origPrc * &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;%d\t%d\t%d\t%f\t%f&quot;&lt;/span&gt; % \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        (yr, numPce, newFlag, origPrc, newFlag, origPrc)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    retX.append([yr, numPce, newFlag, origPrc])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    retY.append(sellingPrice)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;problem with item %d&#39;&lt;/span&gt; % i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setDataCollect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(retX, retY)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchForSet(retX, retY, &lt;span class=&quot;number&quot;&gt;8288&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2006&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;800&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;49.99&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchForSet(retX, retY, &lt;span class=&quot;number&quot;&gt;10030&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2002&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3096&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;269.99&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchForSet(retX, retY, &lt;span class=&quot;number&quot;&gt;10179&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2007&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5195&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;499.99&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchForSet(retX, retY, &lt;span class=&quot;number&quot;&gt;10181&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2007&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3428&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;199.99&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchForSet(retX, retY, &lt;span class=&quot;number&quot;&gt;10189&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2008&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5922&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;299.99&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchForSet(retX, retY, &lt;span class=&quot;number&quot;&gt;10196&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2009&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3263&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;249.99&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据书上的结果，用常规最小二乘法得到的回归公式是&lt;code&gt;55319.97-27.59*Year-0.00268*NumPieces-11.22*NewOrUsed+2.57*OriginalPrice&lt;/code&gt;，即售价和套装里的零部件数目和崭新程度成反比，显然不合常理。下面交叉验证测试岭回归。随机生成10组交叉验证的数据集，并在每组数据上调用岭回归产生的30组回归系数，最后选取使10组数据集误差均值最小的回归系数。最终的结果和常规最小二乘法没有太大差异，显然我们要寻找一个更易于理解的模型的期望没有达到。但我们可以查看岭回归过程中，回归系数在迭代中缩减的情况，因为系数是经过不同程度的缩减得到的，因此在特征非常多时，它&lt;strong&gt;可以指出哪些特征是必须的而哪些是不必要的&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;crossValidation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(xArr, yArr, numVal = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = len(yArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    indexList = range(m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    errorMat = zeros((numVal, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numVal):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trainX = []; trainY = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        testX = []; testY = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        random.shuffle(indexList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; j &amp;lt; m * &lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                trainX.append(xArr[indexList[j]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                trainY.append(yArr[indexList[j]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                testX.append(xArr[indexList[j]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                testY.append(yArr[indexList[j]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wMat = ridgeTest(trainX, trainY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            matTestX = mat(testX); matTrainX = mat(trainX)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            meanTrain = mean(matTrainX, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            varTrain = var(matTrainX, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            matTestX = (matTestX - meanTrain) / varTrain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            yEst = matTestX * mat(wMat[k,:]).T + mean(trainY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            errorMat[i,k] = rssError(yEst.T.A, array(testY))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meanErrors = mean(errorMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    minMean = float(min(meanErrors))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bestWeights = wMat[nonzero(meanErrors==minMean)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xMat = mat(xArr); yMat = mat(yArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meanX = mean(xMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); varX = var(xMat, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unReg = bestWeights/varX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the best model from Ridge Regression is: \n&quot;&lt;/span&gt; , unReg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;with constant term: &quot;&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;*sum(multiply(meanX, unReg)) + mean(yMat)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;回归预测数值型数据-总结&quot;&gt;&lt;a href=&quot;#回归预测数值型数据-总结&quot; class=&quot;headerlink&quot; title=&quot;回归预测数值型数据 总结&quot;&gt;&lt;/a&gt;回归预测数值型数据 总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;回归也是预测目标值的过程，但预测的目标是连续性变量。在回归方程中，求得特征对应的最佳回归系数的方法是最小化误差平方和。给定输入矩阵X，如果&lt;code&gt;X^T·X&lt;/code&gt;的逆存在，则可使用标准回归法。标准回归法可能会出现欠拟合现象，如果在估计中引入一些偏差，就可以降低预测的均方误差，其中一个方法是局部加权线性回归。如果数据的样本数比特征数都要小，特征很可能高度相关，此时&lt;code&gt;X^T·X&lt;/code&gt;必然不是满秩矩阵，无法求逆。此时可以考虑使用岭回归，岭回归是缩减法的一种，相当于为回归系数的大小增加了限制。另一种缩减法是lasso，可以用计算简便的逐步线性回归方法求得近似结果。缩减法可以看成是对一个模型增加偏差的同时减小方差，偏差方差折中可以帮助我们理解现有模型并做出改进。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/18/machinelearning8/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/18/machinelearning8/&quot;&gt;http://forec.github.io/2016/02/18/machinelearning8/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;回归是前面监督学习方法的延续，监督学习指的是有目标变量或者预测目标的机器学习方法。回归于分类的不同在于其目标变量是连续数值型。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 07 - AdaBoost元算法）</title>
    <link href="http://forec.github.io/2016/02/14/machinelearning7/"/>
    <id>http://forec.github.io/2016/02/14/machinelearning7/</id>
    <published>2016-02-14T14:06:25.000Z</published>
    <updated>2016-02-22T13:33:55.392Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;元算法是对其他算法进行组合的一种方式。在做决定时，大家通常考虑吸取多个专家（分类算法）而不是一个专家的意见。当我们试图对样例数目不均衡的数据进行分类时，会遇到非均衡分类问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;基于数据集多重抽样的分类器&quot;&gt;&lt;a href=&quot;#基于数据集多重抽样的分类器&quot; class=&quot;headerlink&quot; title=&quot;基于数据集多重抽样的分类器&quot;&gt;&lt;/a&gt;基于数据集多重抽样的分类器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;前面已经介绍了五种不同的分类算法，各有优缺点。我们可以将不同的分类器组合起来，这种组合结果被称为集成方法或者元算法。使用集成方法时会有许多形式，可以是不同算法的集合，也可以是同一算法在不同设置下的集成，还可以是数据集不同部分分配给不同分类器之后的集成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自举汇聚法&lt;/strong&gt; （bootstrap aggregating，bagging）是从原始数据集选择S次后得到S个新数据集的技术。新数据集和原数据集大小相等，每个数据集都是通过在原始数据集中随机选择一个样本来进行替换得到的，因此有可能出现多次选择同一样本，所以这一行只允许新数据集中有重复的值，而原始数据集的某些值在新集合中则不再出现。当这S个数据集建好，将某个学习算法应用到每个数据集就得到了S个分类器，之后用这S个分类器分类，投票选择最终类别。其它先进的bagging方法有&lt;strong&gt;随机森林&lt;/strong&gt;等，讨论材料见&lt;a href=&quot;http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;boosting是一种与bagging类似的技术，无论在bo哦sting还是bagging中，分类器的类型都是一致的。但在前者中，不同的分类器是通过串行训练获得的，每个新分类器都根据已训练出的分类器的性能来训练。 &lt;strong&gt;boosting是通过集中关注被已有分类器错分的数据来获得新的分类器&lt;/strong&gt; 。bagging中各个分类器的权重相等，而boosting中的分类器权重不等，代表其对应分类器在上一轮迭代中的成功度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AdaBoost流程&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;准备数据：依赖于使用的弱分类器类型，本章使用单层决策树，也可以使用任意分类器充当弱分类器。简单分类器作为弱分类器效果更好。&lt;/li&gt;
&lt;li&gt;分析数据：任意方法。&lt;/li&gt;
&lt;li&gt;训练算法：占据大部分时间，分类器将多次在同一数据集上训练弱分类器。&lt;/li&gt;
&lt;li&gt;测试算法：计算分类错误率。&lt;/li&gt;
&lt;li&gt;使用算法：二类分类器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基于错误提升分类器性能&quot;&gt;&lt;a href=&quot;#基于错误提升分类器性能&quot; class=&quot;headerlink&quot; title=&quot;基于错误提升分类器性能&quot;&gt;&lt;/a&gt;基于错误提升分类器性能&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可以通过弱分类器和多个实例来构造一个强分类器，这里的“弱”意味着分类器的性能比随即猜测要略好，但不会好太多。AdaBoost是adaptive boosting（自适应boosting），过程如下。&lt;/li&gt;
&lt;li&gt;训练数据集中的每个样本，并赋予其一个权重，这些权重构成了向量D。一开始这些权重都初始化为相等值。首先在训练数据上训练出一个弱分类器并计算该分类器的错误率，然后在同一数据集上再一次训练弱分类器。在分类器的第二次训练中，会重新调整每个样本的权重，其中上一次训练中分对的样本所占权重会降低，分错的样本所占样本权重升高。&lt;/li&gt;
&lt;li&gt;AdaBoost为每个弱分类器设置一个权重α，这些α值根据每个弱分类器的错误率计算，错误率ε=未正确分类的样本数/所有的样本数目。α计算公式为&lt;code&gt;α=0.5*ln((1-ε)/ε)&lt;/code&gt;。可见错误率下降，α上升。计算出α后，对权重向量D更新，如果某个样本被正确地分类，那么&lt;code&gt;D&amp;#39; = D*e^(-α)/sum(D)&lt;/code&gt;，如果某个样本被错分，那么&lt;code&gt;D&amp;#39; = D*e^α/sum(D)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;更新D后，AdaBoost进入下一轮迭代。其会不断重复训练和调整权重的过程，直到某次训练错误率为0，或者弱分类器达到用户指定的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;基于单层决策树构建弱分类器&quot;&gt;&lt;a href=&quot;#基于单层决策树构建弱分类器&quot; class=&quot;headerlink&quot; title=&quot;基于单层决策树构建弱分类器&quot;&gt;&lt;/a&gt;基于单层决策树构建弱分类器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单层决策树（决策树桩）是一种简单的决策树，仅基于单个特征来做决策，只有一次分裂过程，因此是一个树桩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简单数据集加载 - adaboost.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadSimpData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	datMat = matrix([[ &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;2.1&lt;/span&gt; ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt; ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;1.3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;  ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					 [ &lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; , &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;  ]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	classLabels = [&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; datMat, classLabels&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建立最佳单层决策树&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将最小错误率minError设为+∞&lt;/li&gt;
&lt;li&gt;对数据集中的每一个特征（一层循环）：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对每个步长（二层循环）：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对每个不等号（三层循环）：&lt;/li&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;建立一棵单层决策树并利用加权数据集对他测试，如果错误率低于minError，就将当前的单层决策树设为最佳单层决策树&lt;/li&gt;
&lt;li&gt;返回最佳单层决策树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最佳单层决策树生成函数 - adaboost.py。下面包含两个函数，stumpClassify是通过阈值threshVal来确定类别，在阈值一边的数据分到类别-1，另一边分到类别+1。第二个函数buildStump遍历stumpClassify所有可能输入值，第一层循环遍历数据集所有特征，第二层遍历所有阈值，第三层遍历不等号。并找到数据集上最佳的单层决策树。之后返回一个bestStump字典，存乎了最优单层决策树的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stumpClassify&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatrix, dimen, threshVal, threshIneq)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retArray = ones((shape(dataMatrix)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; threshIneq == &lt;span class=&quot;string&quot;&gt;&#39;lt&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		retArray[dataMatrix[:,dimen] &amp;lt;= threshVal] = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		retArray[dataMatrix[:,dimen] &amp;gt; threshVal] = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retArray&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;buildStump&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataArr, classLabels, D)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMatrix = mat(dataArr); labelMat = mat(classLabels).T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numSteps = &lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;; bestStump = &amp;#123;&amp;#125;; bestClasEst = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	minError = inf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rangeMin = dataMatrix[:,i].min(); rangeMax = dataMatrix[:,i].max();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stepSize = (rangeMax - rangeMin)/numSteps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,int(numSteps)+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; inequal &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;&#39;lt&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;gt&#39;&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				threshVal = (rangeMin + float(j) * stepSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				errArr = mat(ones((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				errArr[predictedVals == labelMat] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				weightedError = D.T * errArr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#print &quot;split: dim %d, thresh %.2f, thresh inequal: %s, the weighted error is %.3f&quot; %\&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;#	(i, threshVal, inequal, weightedError)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; weightedError &amp;lt; minError:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					minError = weightedError&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestClasEst = predictedVals.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestStump[&lt;span class=&quot;string&quot;&gt;&#39;dim&#39;&lt;/span&gt;] = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestStump[&lt;span class=&quot;string&quot;&gt;&#39;thresh&#39;&lt;/span&gt;] = threshVal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					bestStump[&lt;span class=&quot;string&quot;&gt;&#39;ineq&#39;&lt;/span&gt;] = inequal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bestStump, minError, bestClasEst&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;完整AdaBoost算法&quot;&gt;&lt;a href=&quot;#完整AdaBoost算法&quot; class=&quot;headerlink&quot; title=&quot;完整AdaBoost算法&quot;&gt;&lt;/a&gt;完整AdaBoost算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;伪代码：对每次迭代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用buildStump找到最佳的单层决策树&lt;/li&gt;
&lt;li&gt;将最佳单层决策树加入单层决策树数组&lt;/li&gt;
&lt;li&gt;计算α&lt;/li&gt;
&lt;li&gt;计算新的权重向量D&lt;/li&gt;
&lt;li&gt;更新累计类别估计值&lt;/li&gt;
&lt;li&gt;如果错误率为0.0则退出循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是训练过程代码，输入参数为数据集、类别标签和迭代次数。D是概率分布向量，因此所有元素之和为1，因此初始全部为1/m。同时程序建立列向量aggClassEst记录每个数据点的类别估计累计值。程序中&lt;code&gt;max(error, 1e-16)&lt;/code&gt;防止出现除零溢出。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;adaBoostTrainDS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataArr, classLabels, numIt = &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	weakClassArr = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m = shape(dataArr)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	D = mat(ones((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))/m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	aggClassEst = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numIt):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bestStump, error, classEst = buildStump(dataArr, classLabels, D)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;D:&quot;&lt;/span&gt;, D.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		alpha = float(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;*log((&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;-error)/max(error,&lt;span class=&quot;number&quot;&gt;1e-16&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bestStump[&lt;span class=&quot;string&quot;&gt;&#39;alpha&#39;&lt;/span&gt;] = alpha&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		weakClassArr.append(bestStump)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;classEst &quot;&lt;/span&gt;, classEst.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		expon = multiply(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;*alpha*mat(classLabels).T, classEst)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		D = multiply(D, exp(expon))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		D = D/D.sum()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aggClassEst += alpha*classEst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;aggClassEst: &quot;&lt;/span&gt;, aggClassEst.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T, ones((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		errorRate = aggErrors.sum() / m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;total error: &quot;&lt;/span&gt;, errorRate, &lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; errorRate == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; weakClassArr, aggClassEst&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分类：输入参数是待分类数据和分类器。遍历强分类器中的每个弱分类器，并通过stumpClassify得到每个分类器对某个类别的估计值。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;adaClassify&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(datToClass, classifierArr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMatrix = mat(datToClass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m = shape(dataMatrix)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	aggClassEst = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(classifierArr)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		classEst = stumpClassify(dataMatrix, classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;dim&#39;&lt;/span&gt;],\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;thresh&#39;&lt;/span&gt;], classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;ineq&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aggClassEst += classifierArr[i][&lt;span class=&quot;string&quot;&gt;&#39;alpha&#39;&lt;/span&gt;] * classEst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; aggClassEst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sign(aggClassEst)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在疝气病马数据集上应用AdaBoost算法，通过loadDataSet读入数据，并进行分类。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numFeat = len(open(filename).readline().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMat = []; labelMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineArr = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		curLine = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(numFeat - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			lineArr.append(float(curLine[i]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		dataMat.append(lineArr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		labelMat.append(float(curLine[-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat, labelMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;datArr, labelArr = adaboost.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTraining2.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;classifierArray = adaboost.adaBoostTrainDS(datArr, labelArr, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;testArr, testLabelArr = adaboost.loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;horseColicTest2.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;prediction10 = adaboost.adaClassify(testArr, classifierArray)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;errArr = mat(ones((&lt;span class=&quot;number&quot;&gt;67&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;errArr[prediction10!=mat(testLabelArr).T].sum()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误率分析：当分类器数目从1到10000变化时，总测试错误率先达到一个 最小值，之后又上升。该现象称为过拟合。有文献表明，对于表现好的数据集（horseColicTest有30%数据缺失），AdaBoost的测试错误率会达到一个稳定之，并不会随着分类器增加而上升。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;非均衡类问题和其他分类性能度量指标&quot;&gt;&lt;a href=&quot;#非均衡类问题和其他分类性能度量指标&quot; class=&quot;headerlink&quot; title=&quot;非均衡类问题和其他分类性能度量指标&quot;&gt;&lt;/a&gt;非均衡类问题和其他分类性能度量指标&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;之前的分类都假设所有分类代价一样，但实际上将马归类为死或者活的代价不同，假如分类器只有80%正确率，将一匹本能存活的马判定为安乐死，损失会更大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;混淆矩阵&lt;/strong&gt;：列方向为预测结果，行方向为实际结果，如果除了对角线，其他元素都是0，那么将是一个完美的分类器。&lt;/li&gt;
&lt;li&gt;对于二类问题：如果将正例判为正例则产生真阳例（TP），将反例正确判为反例则产生真阴例（TN），将正例错判为反例，则产生假阴例（FN），将反例错判为正例称为假阳例（FP）。正确率=TP/(TP+FP)，召回率=TP/(TP+FN)。在高召回率的分类器重，真正判错的正例数目并不多。我们可以很容易构造一个高准确率或者高召回率的分类器，但很难保证两者同时成立。&lt;/li&gt;
&lt;li&gt;ROC曲线：横轴为假阳率=FP/(FP+TN)，纵轴是真阳率=TP/(TP+FN)。ROC曲线给出的是当阈值变化时假阳率和真阳率变化的情况。左下角点对应所有样例判为反例，右上角对应所有样例判为正例。理想情况下，最佳分类器应尽可能处于左上角。另一个指标是ROC曲线下的面积AUC，代表了分类器的平均性能值。完美分类器的AUC=1.0，随即猜测的AUC=0.5。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建ROC曲线。首先将分类样例按照预测强度排序，强度高的分为正例，低的判为反例。下面为创建ROC曲线的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;plotROC&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(predStrengths, classLabels)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cur = (&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ySum = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numPosClas = sum(array(classLabels) == &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	yStep = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/float(numPosClas)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	xStep = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/float(len(classLabels) - numPosClas)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sortedIndicies = predStrengths.argsort()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fig = plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fig.clf()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax = plt.subplot(&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; sortedIndicies.tolist()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; classLabels[index] == &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			delX = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; delY = yStep;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			delX = xStep; delY = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			ySum += cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ax.plot([cur[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], cur[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]-delX], [cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - delY], c= &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		cur = (cur[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] - delX, cur[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] - delY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax.plot([&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;span class=&quot;string&quot;&gt;&#39;b--&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.xlabel(&lt;span class=&quot;string&quot;&gt;&#39;False Positive Rate&#39;&lt;/span&gt;); plt.ylabel(&lt;span class=&quot;string&quot;&gt;&#39;True Positive Rate&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.title(&lt;span class=&quot;string&quot;&gt;&#39;ROC curve for AdaBoost Horse Colic Detection System&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ax.axis([&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	plt.show()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the Area Under the Curve is: &quot;&lt;/span&gt;, ySum * xStep&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成图像如下&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/adaboost.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代价敏感&lt;/strong&gt;的学习：选择具有最小期望代价而不是最大概率的类别作为最后的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;数据抽样方法：欠抽样和过抽样。欠抽样指删除部分样例，过抽样指复制部分样例。对于罕见类别，要尽量保留更多信息，通常选择离决策边界较远的样例删除。另一种策略是使用反例类别的欠抽样和正例类别的过抽样结合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;AdaBoost元算法总结&quot;&gt;&lt;a href=&quot;#AdaBoost元算法总结&quot; class=&quot;headerlink&quot; title=&quot;AdaBoost元算法总结&quot;&gt;&lt;/a&gt;AdaBoost元算法总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;元算法过多个分类器组合，可以减轻单分类器的不足。AdaBoost函数可以应用于任何分类器，只要该分类器可以处理加权数据。非均衡分类问题指在分类器训练时正例数目和反例数目不等或者相差很大，或者错分正例和反例代价不同时产生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/14/machinelearning7/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/14/machinelearning7/&quot;&gt;http://forec.github.io/2016/02/14/machinelearning7/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;元算法是对其他算法进行组合的一种方式。在做决定时，大家通常考虑吸取多个专家（分类算法）而不是一个专家的意见。当我们试图对样例数目不均衡的数据进行分类时，会遇到非均衡分类问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《函数式编程思维》笔记</title>
    <link href="http://forec.github.io/2016/02/13/functional-thinking/"/>
    <id>http://forec.github.io/2016/02/13/functional-thinking/</id>
    <published>2016-02-13T01:36:15.000Z</published>
    <updated>2016-02-14T07:34:24.022Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;函数式编程中粒度最小的重用单元是函数（一等公民），并具备值不可变性，带给我的感受是通过一系列基本数据结构方法的复用，配合高阶函数，用最基本的方法叠加出复杂的解法。在用Haskell解决问题总能体会到逆向思维，从目标出发，一步步推到初始条件。函数式的模式匹配、柯里化和部分施用都很有特色，在这种思维下思考是一个很享受的过程。下面是阅读《函数式编程思维》时做摘录的整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;思维转变&quot;&gt;&lt;a href=&quot;#思维转变&quot; class=&quot;headerlink&quot; title=&quot;思维转变&quot;&gt;&lt;/a&gt;思维转变&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令式编程风格通常 &lt;strong&gt;迫使我们出于性能考虑，把不同的任务交织起来，以便能够用一次循环来完成多个任务&lt;/strong&gt; 。而函数式编程用map、filter这些高阶函数把我们解放出来，让我们 &lt;strong&gt;站在更高的抽象层次上去考虑问题&lt;/strong&gt; ，把问题看得更清楚。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把控制权让渡给语言（运行时）。“人生苦短，远离malloc”。函数式编程语言让我们用高阶抽象从容取代基本的控制结构，将琐碎的细节（如垃圾处理）交托给运行时。 &lt;em&gt;面向对象编程通过封装不确定因素来使代码能被人理解；函数式编程通过尽量减少不确定因素来使代码能被人理解。——Michael Feathers&lt;/em&gt; 。与其建立种种机制来控制可变的状态，不如尽可能消灭可变的状态这个不确定因素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;函数式语言提倡 &lt;strong&gt;在有限的几种关键数据结构（list、set、map）上运用针对这些数据结构高度优化过的操作&lt;/strong&gt; ，以此形成基本的运转架构；面向对象程序员喜欢不断的创建新的数据结构和附属的操作，因为OOP范式就是建立新的类和类间的消息。比起一味创建新的类结构体系，把封装的单元降低到函数级别，更有利于达到细颗粒度的、基础层面的重用。&lt;/li&gt;
&lt;li&gt;换用函数式语言不是关键，转变看待问题的角度才是必不可少的。命令式编程是按照“程序是一系列改变状态的命令”来建模的一种编程风格，鼓励程序员将操作安排在循环内部执行。 &lt;strong&gt;函数式语言希望尽可能减少可变的状态&lt;/strong&gt; ，因此更多发展了通用性的计算设施。&lt;/li&gt;
&lt;li&gt;高阶函数消除了摩擦。语法上的便利是非常重要的方面， &lt;strong&gt;在语法处处掣肘下塑造出的抽象，很难配合我们的思维过程而不产生所谓的摩擦&lt;/strong&gt; 。迭代需要让位于高阶函数，如果能用高阶函数把希望执行的操作表达出来，语言将会把操作安排的更高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;权责让渡&quot;&gt;&lt;a href=&quot;#权责让渡&quot; class=&quot;headerlink&quot; title=&quot;权责让渡&quot;&gt;&lt;/a&gt;权责让渡&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;理解掌握的抽象层次永远要比日常使用的抽象层次更深一层&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt; （closure）实际上是一种特殊的函数，在暗地里绑定了函数内部引用的所有变量，换句话说，这种函数把它所引用的所有东西都放在一个上下文里包了起来。下面的代码先定义了一个Employee类，其中带有name和salary字段，接着定义带有amount参数的paidMore函数，其返回值是一个以Employee实例为参数的 &lt;strong&gt;代码块&lt;/strong&gt; ，或者叫闭包。数值100000随着&lt;code&gt;isHighPaid = paidMore(100000)&lt;/code&gt;这一步操作永久的和代码块绑定在一起。第二部分代码执行闭包。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Employee&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; name, salary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; paidMore(amount) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;Employee e -&amp;gt; e.salary &amp;gt; amount &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isHighPaid = paidMore(&lt;span class=&quot;number&quot;&gt;100000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; Smithers = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Employee(&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Fred&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;salary:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;120000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; Homer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Employee(&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Homer&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;salary:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;80000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println isHighPaid(Smithers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println isHighPaid(Homer)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;闭包经常被函数式语言和框架当作一种 &lt;strong&gt;异地执行的机制&lt;/strong&gt; ，用来传递待执行的变换代码，如map之类的高阶函数。注意闭包是代码块，而不是一个值，各个闭包内部状态都是独立的，尽管局部变量不在代码块内定义，但只要代码块引用了该变量，两者就被绑定在一起，这种联系在代码块实例的全部生命期内一直保持着。从实现的角度说， &lt;strong&gt;代码块实例从它被创建的一刻起，就持有其作用域内一切事物的封闭副本&lt;/strong&gt; 。下面的代码展示了闭包的异地执行。闭包所表现出来的函数式思维就是，“让运行时去管理状态”。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; Closure makeCounter()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; local_variable = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; local_variable += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1 = makeCounter()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c1()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c2 = makeCounter()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println &lt;span class=&quot;string&quot;&gt;&quot;C1 = $&amp;#123;c1()&amp;#125;, C2 = $&amp;#123;c2()&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// output: C1 = 4, C2 = 1 //&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;柯里化&lt;/strong&gt; 指的是从一个多参数函数变成 &lt;strong&gt;一连串单参数函数&lt;/strong&gt; 的变换。它描述的是 &lt;strong&gt;变换的过程&lt;/strong&gt; ，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生成一个参数数目较少的新函数。举例来说，函数process(x, y, z)完全柯里化之后变成process(x)(y)(z)的性质，其中process(x)和process(x)(y)都是单参数的函数。如果只对第一个参数柯里化，那么process(x)的返回值将是一个单参数的函数，而这个唯一的参数又接受另一个参数的输入。 &lt;strong&gt;函数柯里化的结果是返回链条中的下一个函数&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;部分施用&lt;/strong&gt; 指提前代入一部分参数值，使一个多参数得以省略部分参数，从而转化为一个参数数目较少的函数。 &lt;strong&gt;部分施用是把参数的取值绑定到用户在操作中提供的具体值上&lt;/strong&gt; 。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;递归&lt;/strong&gt; 的核心在于对一个不断变短的列表反复做同一件事，利用递归，将状态的管理责任推给运行时。递归没有成为一种平常的操作，一个主要原因是栈的增长。使用尾调用优化的写法来帮助运行时科夫栈的增长问题。当递归调用是函数执行的最后一个调用时，运行时往往可以在栈里就地更新，而不需要增加新的栈空间。因此 &lt;strong&gt;尽可能多的使用尾递归的写法&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;记忆和缓求值&quot;&gt;&lt;a href=&quot;#记忆和缓求值&quot; class=&quot;headerlink&quot; title=&quot;记忆和缓求值&quot;&gt;&lt;/a&gt;记忆和缓求值&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只有对纯函数才能放心地使用函数缓存的结果，这刚好符合函数式特性。对于Groovy，可以先将记忆的函数定义为闭包，再对闭包使用memoize()方法获得一个新函数，这个新函数调用的时候结果就会被缓存起来。在Haskell中好像下面的链接可以实现。我们写出来的缓存决不可能比语言开发者设计的更高效，因为语言设计者可以无视他们给语言设定的规定。 &lt;strong&gt;语言设计者实现出来的机制总是比开发者自己做的效率高&lt;/strong&gt; 。&lt;a href=&quot;https://wiki.haskell.org/Memoization&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Haskell-Wiki上的Memoization&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓求值的好处：昂贵的运算只有到了绝对必要的时候才执行；可以建立无限大的集合，只要一接到请求就一直送出元素；按缓求值的方式使用map、filter等，可以产生更高效的代码。特别适合于资源生产成本较高的情况。Haskell的惰性求值就是这样的特性，是非严格求值的。在严格求值的语言运行下面代码会报错，而非严格求值的语言会得出4。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; length([&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;语言演化&quot;&gt;&lt;a href=&quot;#语言演化&quot; class=&quot;headerlink&quot; title=&quot;语言演化&quot;&gt;&lt;/a&gt;语言演化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;少量的数据结构搭配大量的操作。函数式语言有很多操作，但对应的数据结构很少。面向对象语言鼓励建立专门针对某个类的方法，我们从类的关系中发现重复出现的模式并加以重用。 &lt;strong&gt;函数式语言的重用表现在函数的通用性上，他们鼓励在数据结构上使用各种共通的变换，并通过高阶函数来调整操作以满足具体事项的要求&lt;/strong&gt; 。 &lt;em&gt;100个函数操作一种数据结构的组合，要好过10个函数操作10种数据结构的组合。——Alan Perlis&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;让语言去迎合问题&lt;/strong&gt; ，不要拿问题硬套语言，而是想法揉捏手中的语言来迎合问题。Lisp家族的语言传承了无可比拟的灵活性，对DSL的支持比主流语言要强得多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;函数式偏好没有副作用的纯函数，“异常”违背了这个条件。因此函数式语言通过Either类这种不相交联合体，返回左值表示错误信息，右值表示正常结果。函数式语言关注 &lt;strong&gt;引用的透明性&lt;/strong&gt; ，发出调用的例程不必关心他的访问对象真的是一个值，还是一个返回值的函数。&lt;/li&gt;
&lt;li&gt;现代语言大多数是多范式的，支持多种多样的编程范式，如OOP，元编程、函数式、过程式等等。这些范式在语言中相互正交（没有任何影响），不会相互干扰。&lt;/li&gt;
&lt;li&gt;设计模式的变化，模式已被函数式语言吸收成为了语言的一部分，语言特性简化了实现细节。OOP模式和FP模式已经具备了不同的意义。面向对象倾向于封装对象的重用，在不同的结构之间 &lt;strong&gt;耦合&lt;/strong&gt; 。而函数式编程则依靠零件之间的 &lt;strong&gt;复合&lt;/strong&gt; 来组织抽象，以达到减少不确定因素的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《函数式编程思维 - 美 Neal Ford》&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/13/functional-thinking/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/13/functional-thinking/&quot;&gt;http://forec.github.io/2016/02/13/functional-thinking/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数式编程中粒度最小的重用单元是函数（一等公民），并具备值不可变性，带给我的感受是通过一系列基本数据结构方法的复用，配合高阶函数，用最基本的方法叠加出复杂的解法。在用Haskell解决问题总能体会到逆向思维，从目标出发，一步步推到初始条件。函数式的模式匹配、柯里化和部分施用都很有特色，在这种思维下思考是一个很享受的过程。下面是阅读《函数式编程思维》时做摘录的整理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="函数式编程" scheme="http://forec.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习笔记（Chapter 06 - 支持向量机）</title>
    <link href="http://forec.github.io/2016/02/11/machinelearning6/"/>
    <id>http://forec.github.io/2016/02/11/machinelearning6/</id>
    <published>2016-02-11T10:05:05.000Z</published>
    <updated>2016-02-22T13:33:55.881Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;支持向量机（Support Vector Machineds，SVM）是一个二类问题的分类器，实现方法多样，这里采用了序列最小优化（SMO）实现方法，并通过核函数拓展到非线性可分的SVM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;SVM和最大边缘超平面&quot;&gt;&lt;a href=&quot;#SVM和最大边缘超平面&quot; class=&quot;headerlink&quot; title=&quot;SVM和最大边缘超平面&quot;&gt;&lt;/a&gt;SVM和最大边缘超平面&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;SVM的优缺点&lt;ul&gt;
&lt;li&gt;优点：泛化错误率低，计算开销不大撒，结果易解释&lt;/li&gt;
&lt;li&gt;缺点：&lt;strong&gt;对参数调节和核函数的选择敏感&lt;/strong&gt;，原始分类器不加修改情况下仅适用于处理二类问题&lt;/li&gt;
&lt;li&gt;适用数值类型：数值型和标称型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最大边缘超平面：在二维平面上分布的二类数值点，如果可以通过一条直线将两组不同类的数据分开，则这组数据&lt;strong&gt;线性可分&lt;/strong&gt;。在假设数据线性可分的前提下，将数据集分开的直线被称为分隔超平面，如果数据分布在三位平面，那么分隔超平面就是二维的。如果数据集分布在N维空间，则分隔超平面是N-1维。如果&lt;strong&gt;数据点离分隔超平面越远，则最后的预测结果就越好&lt;/strong&gt;。因为&lt;strong&gt;决策边界边缘较小的分类器对模型的过分拟合更加敏感，从而在未知的样本上的泛化能力很差&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;支持向量：离分隔超平面最近的那些点，支持向量机决策只依赖支持向量。&lt;/li&gt;
&lt;li&gt;寻找最大间隔：用向量的形式&lt;code&gt;W·X+b&lt;/code&gt;书写分隔超平面不需要考虑空间维度，其中向量W和常量b描述了所给数据的分隔超平面。因此SVM需要寻找使分隔超平面成为最大边缘超平面的W和b。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;分隔超平面目标函数的优化&quot;&gt;&lt;a href=&quot;#分隔超平面目标函数的优化&quot; class=&quot;headerlink&quot; title=&quot;分隔超平面目标函数的优化&quot;&gt;&lt;/a&gt;分隔超平面目标函数的优化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;SVM工作原理：与Logistic回归类似，使用一个类似海维赛德阶跃函数的函数对所给数据的W·X+b的结果判定分类，如果结果大于0则输出+1，否则输出-1。使用+1和-1而不使用1和0的作用在于，可以通过一个统一公式来表示间隔或者数据点到分隔超平面的距离。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数间隔和几何间隔：点到分隔超平面的函数间隔为&lt;code&gt;y*(wx+b)&lt;/code&gt;，其中y是函数的类别标签（+1或-1）；点到超平面的几何间隔为&lt;code&gt;y*(wx+b)/||w||&lt;/code&gt;。SVM使用几何间隔定义数据点和超平面的距离，因为如果使用函数间隔，则随着w的放大，（wx+b）的值也随之不断增大，此时最优化（最大化）距离无法确定w。《机器学习实战》对SVM的原理介绍很粗略，并且直接给出了最终的可以解决线性不可分情况的公式。《机器学习实战》中SMO之前的部分在&lt;a href=&quot;http://www.cnblogs.com/v-July-v/archive/2012/06/01/2539022.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;July的支持向量机通俗导论&lt;/a&gt;的第一层有比较清楚的介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面部分《机器学习实战》没有讲，在《数据挖掘导论》的5.5节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;边缘公式的优化&lt;/strong&gt;：要最大化最小间隔几何距离，考虑离决策边界最近的数据，如果数据在决策边界上方，则wx+b的结果是正值，在下方为负值，我们可以&lt;strong&gt;固定一个因子，调整另一个因子来优化最大值&lt;/strong&gt;。因此我们设置一个约束条件&lt;code&gt;y*(wx+b)&amp;gt;=1&lt;/code&gt;，这意味着所有的数据都在&lt;code&gt;wx+b&amp;gt;=1&lt;/code&gt;和&lt;code&gt;wx+b&amp;lt;=-1&lt;/code&gt;的范围内，距离超平面越远的店，其wx+b的绝对值就越大，只有支持向量才满足&lt;code&gt;y(wx+b)=1&lt;/code&gt;的。我们选取两个数据点，一个在wx+b=1直线上，一个在wx+b=-1直线上，相减得到&lt;code&gt;w(x1-x2)=2&lt;/code&gt;，注意w、x1和x2都是向量，所以d=x1-x2就代表着两点之间平行于超平面法线方向的距离。因此&lt;code&gt;d=2/||w||&lt;/code&gt;。要让d最大，等价于让&lt;code&gt;f(w)=||w||^2/2&lt;/code&gt;最小。因此，&lt;strong&gt;调整后的目标函数是f(w)，并且受到&lt;code&gt;y(wx+b)&amp;gt;=1&lt;/code&gt;的约束&lt;/strong&gt;。目标函数是二次的，w和b是线性的，因此该问题是凸优化问题（凸函数一阶可微，二阶导衡非负），此时可以引入拉格朗日算子，并且根据KKT条件将不等式约束改为等式约束&lt;code&gt;y(wx+b)-1=0&lt;/code&gt; ，变为最小化&lt;code&gt;Lp = ||w||^2/2 - ∑(λ(y(wx+b)-1)&lt;/code&gt;，观察这个式子，我们限定λ&amp;gt;=0。其一阶导数为0，得到w=∑λyx，∑λy=0。将这两个条件代入拉格朗日算子的公式中，就得到书中的最后的目标函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;不可分情况的处理：如果有少数数据噪声，需要引入正值的松弛变量ε，修改约束条件为&lt;code&gt;y(wx+b)-(1-ε)&amp;gt;=0&lt;/code&gt;，假设直线wx+b=-1+ε经过数据点P，并且平行于决策边界，那么P到wx+b=-1的距离是ε/||w||。因此，ε提供了决策边界在训练样本P上的误差估计。同样，因为我们在决策边界上允许了一定的错误，可能导致误分许多的实例，所以&lt;strong&gt;对松弛变量很大的边界进行惩罚&lt;/strong&gt;，修改后的目标函数为&lt;code&gt;f(w) = ||w||^2 /2 +C(∑ε)^k&lt;/code&gt;，其中C和k是用户指定的参数，用于对误分的数据进行惩罚。假定k=1。这样修改后问题的拉格朗日函数多了一项&lt;code&gt;-∑με&lt;/code&gt;，利用KKT条件约束，一阶导数为0，得到额外条件&lt;code&gt;μ+λ =C&lt;/code&gt;，因此0&amp;lt;=λ&amp;lt;=C，配合&lt;code&gt;∑λy = 0&lt;/code&gt;，这就是书中最终给出的约束公式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SMO求解最优化问题&quot;&gt;&lt;a href=&quot;#SMO求解最优化问题&quot; class=&quot;headerlink&quot; title=&quot;SMO求解最优化问题&quot;&gt;&lt;/a&gt;SMO求解最优化问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;推荐&lt;a href=&quot;http://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JerryLead博客中的支持向量机（五）SMO算法&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SMO算法的目标是求出一系列α和b，这里的α就是上面约束条件中的λ（拉格朗日乘子），因为参考的博客和书中都用α，下面也都用α。只要求出了α，根据&lt;code&gt;w=∑αyx&lt;/code&gt;，就能够求出w。工作原理是每次循环选择两个alpha进行优化处理，一旦找到一对可以优化的α，就增大其中一个，同时减少另外一个。这两个α的选择方法决定了SMO的效率和正确率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SMO算法里的辅助函数&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadDataSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(fileName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataMat = []; labelMat = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fr = open(fileName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; fr.readlines():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lineArr = line.strip().split(&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		dataMat.append([float(lineArr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), float(lineArr[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		labelMat.append(float(lineArr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataMat, labelMat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectJrand&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i, m)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	j = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j == i):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		j = int(random.uniform(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,m))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; j&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clipAlpha&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(aj, H, L)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; aj &amp;gt; H:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aj = H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L &amp;gt; aj:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		aj = L&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; aj&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;《机器学习实战》书中先给了简化版的SMO算法，每次先选定一个α，然后随机选取另一个α。如果所有向量都没有被优化，就增加迭代次数，直到达到要求的迭代次数。书中给出平均速度14.5s。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;smoSimple&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatIn, classLabels, C, toler, maxIter)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; m,n = shape(dataMatrix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alphas = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    iter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (iter &amp;lt; maxIter):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alphaPairsChanged = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fXi = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[i,:].T)) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Ei = fXi - float(labelMat[i])&lt;span class=&quot;comment&quot;&gt;#if checks if an example violates KKT conditions&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((labelMat[i]*Ei &amp;lt; -toler) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (alphas[i] &amp;lt; C)) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; ((labelMat[i]*Ei &amp;gt; toler) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (alphas[i] &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j = selectJrand(i,m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fXj = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[j,:].T)) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Ej = fXj - float(labelMat[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaIold = alphas[i].copy(); alphaJold = alphas[j].copy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (labelMat[i] != labelMat[j]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, alphas[j] - alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    H = min(C, C + alphas[j] - alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, alphas[j] + alphas[i] - C)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    H = min(C, alphas[j] + alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L==H: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;L==H&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                eta = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * dataMatrix[i,:]*dataMatrix[j,:].T - dataMatrix[i,:]*dataMatrix[i,:].T - dataMatrix[j,:]*dataMatrix[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; eta &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;eta&amp;gt;=0&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphas[j] -= labelMat[j]*(Ei - Ej)/eta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphas[j] = clipAlpha(alphas[j],H,L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (abs(alphas[j] - alphaJold) &amp;lt; &lt;span class=&quot;number&quot;&gt;0.00001&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;j not moving enough&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])&lt;span class=&quot;comment&quot;&gt;#update i by the same amount as j&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                        &lt;span class=&quot;comment&quot;&gt;#the update is in the oppostie direction&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[i,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i,:]*dataMatrix[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[j,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j,:]*dataMatrix[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; alphas[i]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (C &amp;gt; alphas[i]): b = b1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; alphas[j]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (C &amp;gt; alphas[j]): b = b2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: b = (b1 + b2)/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaPairsChanged += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;iter: %d i:%d, pairs changed %d&quot;&lt;/span&gt; % (iter,i,alphaPairsChanged)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (alphaPairsChanged == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;): iter += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: iter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;iteration number: %d&quot;&lt;/span&gt; % iter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b,alphas&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启发式选择方法：每次选择α时，优先选择样本前面系数0&amp;lt;α&amp;lt;C的α作优化，因为在界上（α为0或C）的样例对应的α一般不会更改。这种启发式搜索方法是选择第一个α用的，只要选择出来的两个α中有一个违背了KKT条件，那么目标函数在一步迭代后值会减小。违背KKT条件不代表0&amp;lt;α&amp;lt;C，在界上也有可能会违背。因此&lt;strong&gt;在给定初始值α1=0后，先对所有样例进行循环，循环中碰到违背KKT条件的（不管界上还是界内）都进行迭代更新。等这轮过后，如果没有收敛，第二轮就只针对的样例进行迭代更新&lt;/strong&gt;。在第一个α选择后，第二个α也使用启发式方法选择，&lt;strong&gt;第二个α的迭代步长大致正比于|E1-E2|，选择第二个α能够最大化|E1-E2|&lt;/strong&gt;。即当E1为正时选择负的绝对值最大的E2，反之，选择正值最大的E2。最后的收敛条件是在界内（0&amp;lt;α&amp;lt;C）的样例都能够遵循KKT条件，且其对应的α只在极小的范围内变动。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完整的Platt SMO算法，书上数据平均时间0.78秒，下面是用到的辅助函数和结构。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;optStruct&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,dataMatIn, classLabels, C, toler)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# Initialize the structure with the parameters &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.X = dataMatIn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.labelMat = classLabels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.C = C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tol = toler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.m = shape(dataMatIn)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.alphas = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.eCache = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))) &lt;span class=&quot;comment&quot;&gt;#first column is valid flag&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcEk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(oS, k)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fXk = float(multiply(oS.alphas,oS.labelMat).T*(oS.X*oS.X[k,:].T)) + oS.b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ek = fXk - float(oS.labelMat[k])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Ek&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectJK&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i, oS, Ei)&lt;/span&gt;:&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;#this is the second choice -heurstic, and calcs Ej&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    maxK = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; maxDeltaE = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; Ej = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oS.eCache[i] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,Ei]  &lt;span class=&quot;comment&quot;&gt;#set valid #choose the alpha that gives the maximum delta E&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    validEcacheList = nonzero(oS.eCache[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].A)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (len(validEcacheList)) &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; validEcacheList:   &lt;span class=&quot;comment&quot;&gt;#loop through valid Ecache values and find the one that maximizes delta E&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; k == i: &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#don&#39;t calc for i, waste of time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Ek = calcEk(oS, k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            deltaE = abs(Ei - Ek)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (deltaE &amp;gt; maxDeltaE):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                maxK = k; maxDeltaE = deltaE; Ej = Ek&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxK, Ej&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:   &lt;span class=&quot;comment&quot;&gt;#in this case (first time around) we don&#39;t have any valid eCache values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j = selectJrand(i, oS.m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Ej = calcEk(oS, j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; j, Ej&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;updateEkK&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(oS, k)&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;#after any alpha has changed update the new value in the cache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ek = calcEk(oS, k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oS.eCache[k] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,Ek]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完整SMO的内循环&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;innerL&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(i, oS)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ei = calcEk(oS, i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((oS.labelMat[i]*Ei &amp;lt; -oS.tol) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.alphas[i] &amp;lt; oS.C)) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; ((oS.labelMat[i]*Ei &amp;gt; oS.tol) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.alphas[i] &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j,Ej = selectJ(i, oS, Ei) &lt;span class=&quot;comment&quot;&gt;#this has been changed from selectJrand&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oS.labelMat[i] != oS.labelMat[j]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, oS.alphas[j] - oS.alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            L = max(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, oS.alphas[j] + oS.alphas[i] - oS.C)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            H = min(oS.C, oS.alphas[j] + oS.alphas[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L==H: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;L==H&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        eta = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * oS.X[i,:]*oS.X[j,:].T - oS.X[i,:]*oS.X[i,:].T - oS.X[j,:]*oS.X[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; eta &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;eta&amp;gt;=0&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        updateEk(oS, j) &lt;span class=&quot;comment&quot;&gt;#added this for the Ecache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (abs(oS.alphas[j] - alphaJold) &amp;lt; &lt;span class=&quot;number&quot;&gt;0.00001&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;j not moving enough&quot;&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])&lt;span class=&quot;comment&quot;&gt;#update i by the same amount as j&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        updateEk(oS, i) &lt;span class=&quot;comment&quot;&gt;#added this for the Ecache                    #the update is in the oppostie direction&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[i,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[i,:]*oS.X[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[j,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[j,:]*oS.X[j,:].T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; oS.alphas[i]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.C &amp;gt; oS.alphas[i]): oS.b = b1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; oS.alphas[j]) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (oS.C &amp;gt; oS.alphas[j]): oS.b = b2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: oS.b = (b1 + b2)/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是外循环代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;smoP&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dataMatIn, classLabels, C, toler, maxIter)&lt;/span&gt;:&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#full Platt SMO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oS = optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    iter = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    entireSet = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;; alphaPairsChanged = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (iter &amp;lt; maxIter) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; ((alphaPairsChanged &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; (entireSet)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alphaPairsChanged = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; entireSet:   &lt;span class=&quot;comment&quot;&gt;#go over all&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(oS.m):        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaPairsChanged += innerL(i,oS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fullSet, iter: %d i:%d, pairs changed %d&quot;&lt;/span&gt; % (iter,i,alphaPairsChanged)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            iter += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;span class=&quot;comment&quot;&gt;#go over non-bound (railed) alphas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nonBoundIs = nonzero((oS.alphas.A &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) * (oS.alphas.A &amp;lt; C))[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nonBoundIs:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alphaPairsChanged += innerL(i,oS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;non-bound, iter: %d i:%d, pairs changed %d&quot;&lt;/span&gt; % (iter,i,alphaPairsChanged)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            iter += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; entireSet: entireSet = &lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#toggle entire set loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; (alphaPairsChanged == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;): entireSet = &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;iteration number: %d&quot;&lt;/span&gt; % iter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; oS.b,oS.alphas&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是求W和分类函数&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcWs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(alphas, dataArr, classLabels)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	X = mat(dataArr); labelMat = mat(classLabels).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(X)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	w = zeros((n,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))	&lt;span class=&quot;comment&quot;&gt;# n*1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		w += multiply(alphas[i] * labelMat[i], X[i,:].T)	&lt;span class=&quot;comment&quot;&gt;# n*1*1 (1*n)^T&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; w&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classified&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dat, ws, b)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; dat * mat(ws) + b &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;核函数&quot;&gt;&lt;a href=&quot;#核函数&quot; class=&quot;headerlink&quot; title=&quot;核函数&quot;&gt;&lt;/a&gt;核函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;来自《数据挖掘导论》，并参考&lt;a href=&quot;https://www.zhihu.com/question/24627666&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎上关于机器学习中核函数的讨论&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;径向基函数（RBF）：是一个采用向量作为自变量的函数，能够基于向量距离运算输出一个标量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;核函数和SVM是两个正交的概念，通过核函数可以将当前维度无法线性划分的数据转移到高维（无穷维度）。SVM核的变换后空间也称为&lt;strong&gt;再生核希尔伯特空间（RKHS）&lt;/strong&gt;，使用核函数计算点积开销更小，并且计算在原空间进行，无须担心维灾难问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Mercer定理：对非线性SVM使用的核函数的主要要求是，必须存在一个相应的变换，使得计算一对向量的核函数等价于在变换后的空间中计算这对向量的点积。核函数K可以表示为&lt;code&gt;K(u, v) = Φ(u)Φ(v)&lt;/code&gt;，当且仅当对于任意满足&lt;code&gt;∫g(x)^2dx&lt;/code&gt;为有限值得函数g(x)，则&lt;code&gt;∫K(x,y)g(x)g(y)dxdy &amp;gt;= 0&lt;/code&gt;。满足这个定理的核函数称为正定核函数。例如&lt;code&gt;K(x,y) = (x·y+1)^p&lt;/code&gt;，&lt;code&gt;K(x,y) = e^(-(|x-y|^2)/2σ^2))&lt;/code&gt;，&lt;code&gt;K(x,y) = tanh(ky·y - δ)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;核函数转换&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;kernelTrans&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(X, A, kTup)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(X)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	K = mat(zeros((m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; kTup[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;string&quot;&gt;&#39;lin&#39;&lt;/span&gt;: K = X*A.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; kTup[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			deltaRow = X[j,:] - A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			K[j] = deltaRow * deltaRow.T&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		K = exp(K / (-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;*kTup[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; NameError(&lt;span class=&quot;string&quot;&gt;&quot;Houston We Have a Problem -- \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		That kernel is not recognized&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; K&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面是测试函数，需要对函数innerL和calcEk和类optStruct做一定修改。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testRbf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(k1=&lt;span class=&quot;number&quot;&gt;1.3&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataArr, labelArr = loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;testSetRBF.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	b, alphas = smoP(dataArr, labelArr, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;, (&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;,k1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	datMat = mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	svInd = nonzero(alphas.A &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sVs = datMat[svInd]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	labelSV = labelMat[svInd]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;there are %d Support Vectors&quot;&lt;/span&gt; % shape(sVs)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		kernelEval = kernelTrans(sVs, datMat[i,:], (&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;,k1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict) != sign(labelArr[i]) : errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the training error rate is %f&quot;&lt;/span&gt; % (float(errorCount)/m) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dataArr, labelArr = loadDataSet(&lt;span class=&quot;string&quot;&gt;&#39;testSetRBF2.txt&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	datMat = mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	m, n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		kernelEval = kernelTrans(sVs, datMat[i,:], (&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;,k1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict) != sign(labelArr[i]) : errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the test error rate is %f&quot;&lt;/span&gt; % (float(errorCount)/m)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原代码需要修改的地方&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;innerL&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        eta = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * oS.K[i,j] - oS.K[i,i] - oS.K[j,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i,i] -\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    			oS.labelMat[j] * (oS.alphas[j] - alphaJold) * oS.K[i,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i,j] - \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    			oS.labelMat[j] * (oS.alphas[j] - alphaJold) * oS.K[j,j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	···&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calcEk&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(oS, k)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	fXk = float(multiply(oS.alphas, oS.labelMat).T * oS.K[:,k] + oS.b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Ek = fXk - float(oS.labelMat[k])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Ek&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;optStruct&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, dataMatIn, classLabels, C, toler, kTup)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.X = dataMatIn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.labelMat = classLabels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.C = C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.tol = toler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.m = shape(dataMatIn)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.alphas = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.eCache = mat(zeros((self.m,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		self.K = mat(zeros((self.m, self.m)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(self.m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			self.K[:,i] = kernelTrans(self.X, self.X[i,:], kTup)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;kNN手写问题回顾&quot;&gt;&lt;a href=&quot;#kNN手写问题回顾&quot; class=&quot;headerlink&quot; title=&quot;kNN手写问题回顾&quot;&gt;&lt;/a&gt;kNN手写问题回顾&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SVM是二类分类器，将非9的数字判为-1，否则判为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code - testDigits - svmMLiA.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;img2vector&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    returnVect = zeros((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fr = open(filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineStr = fr.readline()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            returnVect[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;*i+j] = int(lineStr[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnVect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadImages&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dirName)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; os &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; listdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hwLabels = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trainingFileList = listdir(dirName)           &lt;span class=&quot;comment&quot;&gt;#load the training set&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = len(trainingFileList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trainingMat = zeros((m,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fileNameStr = trainingFileList[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fileStr = fileNameStr.split(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]     &lt;span class=&quot;comment&quot;&gt;#take off .txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classNumStr = int(fileStr.split(&lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; classNumStr == &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;: hwLabels.append(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;: hwLabels.append(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        trainingMat[i,:] = img2vector(&lt;span class=&quot;string&quot;&gt;&#39;%s/%s&#39;&lt;/span&gt; % (dirName, fileNameStr))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; trainingMat, hwLabels&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testDigits&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(kTup=&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&#39;rbf&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataArr,labelArr = loadImages(&lt;span class=&quot;string&quot;&gt;&#39;trainingDigits&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b,alphas = smoP(dataArr, labelArr, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;, kTup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    svInd=nonzero(alphas.A&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sVs=datMat[svInd] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    labelSV = labelMat[svInd];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;there are %d Support Vectors&quot;&lt;/span&gt; % shape(sVs)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m,n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict)!=sign(labelArr[i]): errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the training error rate is: %f&quot;&lt;/span&gt; % (float(errorCount)/m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataArr,labelArr = loadImages(&lt;span class=&quot;string&quot;&gt;&#39;testDigits&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    errorCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m,n = shape(datMat)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sign(predict)!=sign(labelArr[i]): errorCount += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the test error rate is: %f&quot;&lt;/span&gt; % (float(errorCount)/m)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改径向基核函数的参数σ，观察错误率。σ下降，则训练错误率降低，测试错误率上升。最小的训练错误率并不对应于最小的向量支持数目。另外线性和函数的效果并不很糟糕，可以牺牲线性核函数的错误率来换取分类速度的提高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;多类分类问题&quot;&gt;&lt;a href=&quot;#多类分类问题&quot; class=&quot;headerlink&quot; title=&quot;多类分类问题&quot;&gt;&lt;/a&gt;多类分类问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;第一种方法将多类问题分解为K个二类问题，对于类别yi，属于类别yi的为一类，不属于yi的为另一类。此方法称为一对其他（1-r）方法。&lt;/li&gt;
&lt;li&gt;第二种方法为一对一（1-1）方法，构建K(K-1)/2个分类器，没一个分类器用来区分一对类(yi,yj)，此时忽略其他类的样本。&lt;/li&gt;
&lt;li&gt;以上两种方法都使用二类分类器的组合预测，并投票表决，票数多的分类为最终分类。这种方法可能导致不同类的平局。&lt;/li&gt;
&lt;li&gt;纠错输出编码：1-r和1-1方法都对二元分类的错误太敏感。可以参考海明编码，为每个类别分配一个码字，码字的每个二进制位训练一个二元分类器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;支持向量机总结&quot;&gt;&lt;a href=&quot;#支持向量机总结&quot; class=&quot;headerlink&quot; title=&quot;支持向量机总结&quot;&gt;&lt;/a&gt;支持向量机总结&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;支持向量机是一种二类分类器，通过求解一个二次优化问题来最大化分类间隔。通过SMO算法每次优化两个α可以提升SVM的训练速度。核函数可以从一个低维空间的非线性数据映射到一个高维空间的线性数据i，此部分可以参考知乎。&lt;/p&gt;
&lt;p&gt;SVM问题可以表示为凸优化问题，利用已知的有效算法发现目标函数的全局最小值。通过最大化决策边界的边缘来控制模型的能力，用户必须提供其他参数，如核函数类型、松弛变量带来的惩罚C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;参考文献： 《机器学习实战 - 美Peter Harrington》、《数据挖掘导论 - 美Pang-Ning Tan等》&lt;/p&gt;
&lt;p&gt;参考的文章等：&lt;a href=&quot;http://www.cnblogs.com/v-July-v/archive/2012/06/01/2539022.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;July的文章&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JerryLead的文章&lt;/a&gt;，&lt;a href=&quot;https://www.zhihu.com/question/24627666&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;王赟 Maigo等在知乎上的答案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://forec.github.io/2016/02/11/machinelearning6/&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://forec.github.io/2016/02/11/machinelearning6/&quot;&gt;http://forec.github.io/2016/02/11/machinelearning6/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.github.io/&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;支持向量机（Support Vector Machineds，SVM）是一个二类问题的分类器，实现方法多样，这里采用了序列最小优化（SMO）实现方法，并通过核函数拓展到非线性可分的SVM。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://forec.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Algorithms" scheme="http://forec.github.io/tags/Algorithms/"/>
    
      <category term="机器学习" scheme="http://forec.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
