<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Forec&#39;s Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://forec.github.io/"/>
  <updated>2016-12-23T17:28:14.844Z</updated>
  <id>http://forec.github.io/</id>
  
  <author>
    <name>Forec</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>顶点云（应用）用户代理</title>
    <link href="http://forec.github.io/2016/12/03/zenith-cloud-7/"/>
    <id>http://forec.github.io/2016/12/03/zenith-cloud-7/</id>
    <published>2016-12-03T13:44:07.000Z</published>
    <updated>2016-12-23T17:28:14.844Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;设计用户代理，实现 &lt;code&gt;DealWithRequests()&lt;/code&gt; 中的几种简单逻辑指令，如文件列表获取、文件拷贝、Fork操作等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/zenith-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）设计与实现&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/23/zenith-cloud-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）服务器逻辑实现&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：TODO  &lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;设计用户代理，实现 &lt;code&gt;DealWithRequests()&lt;/code&gt; 中的几种简单逻辑指令，如文件列表获取、文件拷贝、Fork操作等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="Golang" scheme="http://forec.github.io/tags/Golang/"/>
    
      <category term="云存储" scheme="http://forec.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
      <category term="线程" scheme="http://forec.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 中的高效 I/O</title>
    <link href="http://forec.github.io/2016/11/30/efficient-haskell-io/"/>
    <id>http://forec.github.io/2016/11/30/efficient-haskell-io/</id>
    <published>2016-11-30T14:54:30.000Z</published>
    <updated>2016-11-30T15:39:16.182Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Haskell 提高 I/O 效率的技巧及资源控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;二进制-I-O&quot;&gt;&lt;a href=&quot;#二进制-I-O&quot; class=&quot;headerlink&quot; title=&quot;二进制 I/O&quot;&gt;&lt;/a&gt;二进制 I/O&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Data.ByteString&lt;/code&gt; ：定义严格求值的 ByteString 类型，将一串二进制数据或文本数据用一个数组表示。适合不在意内存限制并要求随机存取的情况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data.ByteString.Lazy&lt;/code&gt;：提供了 &lt;code&gt;ByteString&lt;/code&gt; 的惰性类型，将一串数据分块组成列表，每块大小 64KB 。该方式惰性执行，对于体积较大的数据，惰性的 ByteString 类型会更好，其块大小针对现代 CPU L1缓存调整过，已处理过的、不会再被使用的流数据会被垃圾处理器快速回收。&lt;/li&gt;
&lt;li&gt;以上两种类型均提供了和 &lt;code&gt;String&lt;/code&gt; 类型兼容的接口函数，但元素类型为字节 &lt;code&gt;Word8&lt;/code&gt;，该类型在 &lt;code&gt;Data.Word&lt;/code&gt; 模块中声明。&lt;/li&gt;
&lt;li&gt;可使用 &lt;code&gt;pack&lt;/code&gt; 函数将字节数组装载为 &lt;code&gt;ByteString&lt;/code&gt;：&lt;code&gt;L.pack :: [Word.Word8] -&amp;gt; L.ByteString&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ByteString&lt;/code&gt; 库提供了两个功能有限的 I/O 功能模块：&lt;code&gt;Data.ByteString.Char8&lt;/code&gt; 和 &lt;code&gt;Data.ByteString.Lazy.Char8&lt;/code&gt;，其中的函数仅适用于单字节大小的 Char 值（ASCII和某些欧洲字符集，大于 255 会被截断）。这两个模块提供了较多方便的函数，如 &lt;code&gt;readInt&lt;/code&gt;、&lt;code&gt;split&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Haskell 的正则通过 &lt;code&gt;Text.Regex.Posix&lt;/code&gt; 模块提供，其中 &lt;code&gt;=~&lt;/code&gt; 操作符是正则表达式匹配函数。其参数和返回值都使用了类型类，第一个参数是要被匹配的文本，第二个参数是正则表达式，每个参数都可以用为 &lt;code&gt;String&lt;/code&gt; 或者 &lt;code&gt;ByteString&lt;/code&gt; 类型。其返回值是多态的，但文本匹配的结果必须和被匹配的字符串一致，我们可以将 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;ByteString&lt;/code&gt; 组合，但结果类型必须和被匹配字符串一样。正则表达式可以使 &lt;code&gt;String&lt;/code&gt; 或者 &lt;code&gt;ByteString&lt;/code&gt;，没有限制。根据返回类型签名不同，返回结果也有区别：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bool&lt;/code&gt;：字符串和正则式是否匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Int&lt;/code&gt;：正则式在字符串中成功匹配的次数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(Int, Int)&lt;/code&gt;：格式为（首次匹配在字符串中的偏移量，首次匹配结果的长度），偏移量为 -1 时表示字符串和正则式不匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[(Int, Int)]&lt;/code&gt;：得到所有匹配子串的（偏移量，匹配长度），列表为空代表无匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;：得到第一个匹配的子串，或者无匹配的空字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[String]]&lt;/code&gt;：返回由所有匹配的字符串组成的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(String, String, String)&lt;/code&gt;：匹配成功时为（首次匹配之前的部分，首次匹配的子串，首次匹配之后的部分），匹配失败时为（整个字符串，””,””）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(String, String, String, [String])&lt;/code&gt;：前三个元素和三元组相同，第四个元素是包含了模式中所有分组的列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则函数可配合其他函数如 &lt;code&gt;getAllTextMatchs&lt;/code&gt; 来获取更多结果：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;ghci&lt;/span&gt;&amp;gt; (&lt;span class=&quot;string&quot;&gt;&quot;foo buot&quot;&lt;/span&gt; =~ &lt;span class=&quot;string&quot;&gt;&quot;(oo|uo)&quot;&lt;/span&gt;) :: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;oo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;uo&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;文件系统路径&quot;&gt;&lt;a href=&quot;#文件系统路径&quot; class=&quot;headerlink&quot; title=&quot;文件系统路径&quot;&gt;&lt;/a&gt;文件系统路径&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Haskell 的文件系统处理函数主要由 &lt;code&gt;System.Directory&lt;/code&gt; 提供，如 &lt;code&gt;doesDirectoryExist&lt;/code&gt;、&lt;code&gt;doesFileExist&lt;/code&gt;、&lt;code&gt;getCurrentDirectory&lt;/code&gt;、&lt;code&gt;getDirectoryContents&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.FilePath&lt;/code&gt; 主要处理文件路径，由两个模块构成：&lt;code&gt;System.FilePath.Posix&lt;/code&gt; 和 &lt;code&gt;System.FilePath.Windows&lt;/code&gt;，二者接口完全相同，适配平台不同。包含函数如：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getSearchPath&lt;/code&gt;：获得 $PATH 环境变量内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;/&amp;gt;&lt;/code&gt;：将两个字符串用 &lt;code&gt;/&lt;/code&gt; 合为一个路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;.&amp;gt;&lt;/code&gt;：将后缀名结合，等价于 &lt;code&gt;addExtension&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&amp;lt;.&amp;gt;&lt;/code&gt;：去掉后缀名并添加一个新的后缀名，等价于 &lt;code&gt;replaceExtension&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dropTrailingPathSeparator&lt;/code&gt;：去掉文件路径后的分隔符，如 &lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splitFileName&lt;/code&gt;：返回将路径切割为父级目录和文件名的二元组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;常见-I-O-异常处理&quot;&gt;&lt;a href=&quot;#常见-I-O-异常处理&quot; class=&quot;headerlink&quot; title=&quot;常见 I/O 异常处理&quot;&gt;&lt;/a&gt;常见 I/O 异常处理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;异常处理的几个常用函数包含在 &lt;code&gt;Control.Exception&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle :: (Exception -&amp;gt; IO a) -&amp;gt; IO a -&amp;gt; IO a&lt;/code&gt; 接收的第一个参数是一个函数，该函数接受一个异常值并且返回 IO Monad，第二个参数是可能抛出异常的 IO Monad。当第二个 IO Monad 执行出现异常时，作为 &lt;code&gt;handle&lt;/code&gt; 第一个参数的函数会接收产生的异常值，并返回自己的 IO Monad；当第二个参数执行无异常时， &lt;code&gt;handle&lt;/code&gt; 返回值与第二个参数相同。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;handle&lt;/code&gt; 的使用中可使用 &lt;code&gt;const&lt;/code&gt; 忽略传入的异常。const 接收两个参数，无论第二个参数是什么都返回第一个参数：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;handle (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [])) (code_may_cause_exception)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []) :: Monad &lt;span class=&quot;keyword&quot;&gt;m&lt;/span&gt; =&amp;gt; b -&amp;gt; &lt;span class=&quot;keyword&quot;&gt;m&lt;/span&gt; [t]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;也可以使用 &lt;code&gt;finally&lt;/code&gt; 捕获异常，其类型签名为 &lt;code&gt;finally:: IO a-&amp;gt; IO b -&amp;gt; IO a&lt;/code&gt;，无论第一个 IO Monad 成功或失败，第二个 IO Monad 都会执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bracket&lt;/code&gt; 可以看作 Haskell 中的 &lt;code&gt;defer&lt;/code&gt;：如果你试图获取一个资源，对该资源做一些操作，并想在操作结束后释放这个资源，则可以使用 &lt;code&gt;bracket&lt;/code&gt; 来保证最终资源的释放。&lt;br&gt;&lt;code&gt;bracket&lt;/code&gt; 接收三个参数，第一个参数用于资源的获取，它的返回值会传给第二、三个参数，而第二个参数对应资源的释放，第三个参数为对资源的操作，它的返回值也是整个 &lt;code&gt;bracket&lt;/code&gt; 函数的返回值。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bracket :: IO a&lt;span class=&quot;function&quot;&gt; -&amp;gt;&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(a -&amp;gt; IO b)&lt;/span&gt; -&amp;gt;&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(a -&amp;gt; IO c)&lt;/span&gt; -&amp;gt;&lt;/span&gt; IO c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bracket&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (openFile &lt;span class=&quot;string&quot;&gt;&quot;filename&quot;&lt;/span&gt; ReadMode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (hClose)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;string&quot;&gt;\fileHandle&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123; ... &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;当不需要获取第一个参数的返回值时，或这几个操作之间并无关系，使用 &lt;code&gt;bracket_ :: IO a -&amp;gt; IO b -&amp;gt; IO c -&amp;gt; IO c&lt;/code&gt; 替代 &lt;code&gt;bracket&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果仅希望释放操作在执行操作出现异常时调用，则使用 &lt;code&gt;bracketOnError:: IO a -&amp;gt; (a -&amp;gt; IO b) -&amp;gt; (a -&amp;gt; IO c) -&amp;gt; IO c&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/30/efficient-haskell-io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/30/efficient-haskell-io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/30/efficient-haskell-io/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Haskell 提高 I/O 效率的技巧及资源控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Language" scheme="http://forec.github.io/categories/Language/"/>
    
    
      <category term="Haskell" scheme="http://forec.github.io/tags/Haskell/"/>
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
      <category term="函数式编程" scheme="http://forec.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（七）：死锁</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-7/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-7/</id>
    <published>2016-11-24T14:16:22.000Z</published>
    <updated>2016-11-25T07:00:33.638Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版死锁部分，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;死锁模型&quot;&gt;&lt;a href=&quot;#死锁模型&quot; class=&quot;headerlink&quot; title=&quot;死锁模型&quot;&gt;&lt;/a&gt;死锁模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;多道程序环境下，多个进程竞争有限资源。如果某个进程需求的资源被其他进程占用，则该进程可能被永久阻塞，这种情况称为 &lt;strong&gt;死锁（deadlock）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;进程按照如下顺序使用资源：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;申请（Request）&lt;/strong&gt; ：如果申请不能被允许（如资源正在被其他进程占用），则申请进程必须等待直到获得资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用（Use）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放（Release）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源的申请和释放都是系统调用，如设备的 &lt;code&gt;request()/release()&lt;/code&gt;，文件的 &lt;code&gt;open()/close()&lt;/code&gt;，内存的 &lt;code&gt;allocate()/free()&lt;/code&gt; 等。对于进程或线程的每次执行，操作系统会检查并确保它们以获得所需资源。系统维护一张记录表，说明某个资源是否空闲，被分配给哪个进程。&lt;/li&gt;
&lt;li&gt;永久性资源可分为：&lt;ul&gt;
&lt;li&gt;可剥夺资源（可重用资源）：当进程所占有的并使用的资源被剥夺时，对进程不产生破坏性影响（如内存、CPU）&lt;/li&gt;
&lt;li&gt;不可剥夺资源：如打印机等，一旦剥夺则任务执行失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;死锁特征&quot;&gt;&lt;a href=&quot;#死锁特征&quot; class=&quot;headerlink&quot; title=&quot;死锁特征&quot;&gt;&lt;/a&gt;死锁特征&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;以下四个条件（四个条件并不完全独立）同时成立时，死锁产生：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥（mutual exclusion）&lt;/strong&gt; ：至少有一个资源处于互斥模式，即该资源同时只能由一个进程使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;占有并等待（hold and wait）&lt;/strong&gt; ：进程必须占有至少一个资源，并且等待另一资源，且等待的资源已被其他进程占有。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非抢占（no preemptive）&lt;/strong&gt; ：资源不能被抢占。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环等待（circular wait）&lt;/strong&gt; ：一组等待进程 &lt;code&gt;{P0, p1, ..., pn}&lt;/code&gt;，其中 Pi 等待的资源被 Pi+1 占有，Pn 等待的资源被 P0 占有。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁问题可用 &lt;strong&gt;系统资源分配图（system resource-allocation  graph）&lt;/strong&gt; 描述：&lt;ul&gt;
&lt;li&gt;该图的节点集合 V 分为系统活动进程集合 &lt;code&gt;P = {P1, P2, ..., Pn}&lt;/code&gt; 和系统资源类型集合 &lt;code&gt;R = {R1, R2, ..., Rm}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从进程 Pi 到资源类型 Rj 的有向边记为 &lt;code&gt;Pi → Rj&lt;/code&gt;，称为 &lt;strong&gt;申请边（request edge）&lt;/strong&gt; ，表示进程 Pi 已经申请并正在等待资源类型 Rj 的一个实例。&lt;/li&gt;
&lt;li&gt;从资源类型 Rj 到进程 Pi 的有向边记为 &lt;code&gt;Rj → Pi&lt;/code&gt;，称为 &lt;strong&gt;分配边（assignment edge）&lt;/strong&gt; ，表示资源类型 Rj 的一个实例已经分配给进程 Pi。&lt;/li&gt;
&lt;li&gt;在图上用圆形表示进程 Pi，用矩形表示资源类型 Rj，资源类型的多个实例在矩形中用圆点表示。&lt;/li&gt;
&lt;li&gt;申请边只需指向矩形 Rj，分配边的源点需要指定矩形内部的某个圆点。&lt;/li&gt;
&lt;li&gt;当进程 Pi 申请资源类型 Rj 的一个实例时，在资源分配图中加入一条申请边，当该申请可以满足时将该申请边 &lt;strong&gt;立即&lt;/strong&gt; 转换为分配边。当进程释放资源时，该分配边从图中删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可证明：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果分配图中不存在环，则系统未发生进程死锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果分配图中存在环且每个资源类型仅有一个实例，则系统已处于进程死锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果分配图中存在环，且存在某个资源类型有多个实例，则系统可能处于进程死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;死锁处理&quot;&gt;&lt;a href=&quot;#死锁处理&quot; class=&quot;headerlink&quot; title=&quot;死锁处理&quot;&gt;&lt;/a&gt;死锁处理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;三种方法可以处理死锁：&lt;ul&gt;
&lt;li&gt;使用某种协议预防或避免死锁，确保系统不进入死锁状态&lt;/li&gt;
&lt;li&gt;允许系统进入死锁状态，且系统可以检测到死锁并恢复&lt;/li&gt;
&lt;li&gt;忽视死锁问题，认为系统中不可能发生死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数操作系统采用第三种（包括 UNIX 和 Windows），因此死锁由应用程序员处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁预防&quot;&gt;&lt;a href=&quot;#死锁预防&quot; class=&quot;headerlink&quot; title=&quot;死锁预防&quot;&gt;&lt;/a&gt;死锁预防&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据死锁特征，只要破坏四个条件中的一个使之不同时成立即可实现 &lt;strong&gt;死锁预防（prevention）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;破坏互斥：非共享资源必须满足互斥条件，因此此条件无法破坏&lt;/li&gt;
&lt;li&gt;破坏占有并等待：必须保证一个进程不能在已经占有其他资源的情况下再申请一个资源，两种方法可选（两种方法 &lt;strong&gt;&lt;em&gt;资源利用率均较低&lt;/em&gt;&lt;/strong&gt; ，且 &lt;strong&gt;&lt;em&gt;可能导致饥饿&lt;/em&gt;&lt;/strong&gt; ，需要多个常用资源的进程可能会永久等待）：&lt;ul&gt;
&lt;li&gt;每个进程在执行前申请并获得执行期间所需的全部资源；&lt;/li&gt;
&lt;li&gt;仅允许进程在没有资源时才可申请资源，在它申请更多资源前必须释放全部已持有资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;破坏非抢占：如果一个进程在占有一些资源的同时申请了另一个不能立刻被分配的资源（等待列表中的其他进程也没有持有该资源），则该进程目前已获得的所有资源都可被其它正在等待的进程抢占。也就是说，该进程持有的资源被隐式释放了。该进程要想重新执行，必须分配到要申请的资源，同时还要恢复自己在等待时被抢占的资源。此协议通常用于状态可以保存和恢复的资源，如 CPU 寄存器和内存，对于不可剥夺资源无效。&lt;/li&gt;
&lt;li&gt;破坏循环等待：系统定义一个函数 &lt;code&gt;F: R → N&lt;/code&gt; 为资源类型集合编号，不同资源类型的编号不同。每个 &lt;strong&gt;进程只能按照递增顺序申请资源&lt;/strong&gt; ，进程开始执行时可以申请任意数量的资源类型 Ri 的实例，之后若想申请资源类型 Rj 的实例，则必须满足 &lt;code&gt;F(Rj) &amp;gt; F(Ri)&lt;/code&gt; 才可申请，否则它必须释放所有编号小于 F(Rj) 的资源后才能再申请。&lt;ul&gt;
&lt;li&gt;证明：若存在循环等待，设循环等待的进程集合为 &lt;code&gt;{P0, P1, ..., Pn}&lt;/code&gt; ，其中 Pi 等待资源 Ri，且 Ri 被进程 Pi+1 占有，因为 Pi+1 占有资源 Ri 且申请资源 Ri+1，所以对所有 i 有 &lt;code&gt;F(Ri) &amp;lt; F(Ri+1)&lt;/code&gt;，即 &lt;code&gt;F(R0) &amp;lt; F(R1) &amp;lt; ... &amp;lt; F(Rn) &amp;lt; F(R0)&lt;/code&gt;，假设不成立。&lt;/li&gt;
&lt;li&gt;按照此协议，程序员必须按系统为资源定义的顺序来编写程序才可防止死锁。有些软件（如 Witness）可以验证资源锁是否按顺序获取，并对不按顺序获取的代码做出警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以上通过限制资源申请来预防死锁的方法可行，但会降低设备使用率和系统吞吐率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁避免&quot;&gt;&lt;a href=&quot;#死锁避免&quot; class=&quot;headerlink&quot; title=&quot;死锁避免&quot;&gt;&lt;/a&gt;死锁避免&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;死锁避免（deadlock-avoidance）&lt;/strong&gt; 算法动态监测资源分配状态以保证循环等待条件无法成立，同时它要求进程提供一定的 &lt;strong&gt;先验信息&lt;/strong&gt; ，例如进程执行期间可能需要使用的每种资源类型实例的最大数量。&lt;/li&gt;
&lt;li&gt;若系统中的进程按照某个特定顺序执行不会产生死锁，则此时系统处于安全状态，这个进程执行的顺序称为 &lt;strong&gt;安全序列（safe sequence）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;安全状态必然不会导致死锁，不安全状态可能会导致死锁状态，死锁状态必然是不安全状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源分配图算法&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;适用于每个资源只有一个实例的系统；&lt;/li&gt;
&lt;li&gt;向系统资源分配图中加入一种新类型的边，称为 &lt;strong&gt;需求边（claim edge）&lt;/strong&gt; 。需求边 &lt;code&gt;Pi-&amp;gt;Rj&lt;/code&gt; 表示进程 Pi 可能在将来某时刻申请资源 Rj，需求边用虚线表示。当 Pi 申请资源 Rj 时，需求边 &lt;code&gt;Pi-&amp;gt;Rj&lt;/code&gt;变为申请边，当进程 Pi 释放资源 Rj 时，分配边 &lt;code&gt;Rj-&amp;gt;Pi&lt;/code&gt; 变成需求边；&lt;/li&gt;
&lt;li&gt;若进程 Pi 试图申请资源 Rj，则系统需要检查：如果需求边 &lt;code&gt;Pi-&amp;gt;Rj&lt;/code&gt; 变成分配边 &lt;code&gt;Rj-&amp;gt;Pi&lt;/code&gt; 后，资源分配图中不存在环（虚实线无所谓），则允许申请，否则进程 Pi 必须等待。&lt;/li&gt;
&lt;li&gt;系统检查是否存在环可使用 Tarjan 等求联通子图的 n² 级算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;银行家（Banker’s）算法&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;适用于每种资源类型有多个实例的情形，效率低于资源分配图&lt;/li&gt;
&lt;li&gt;银行家算法需要在进程请求资源时检查分配后的状态是否保持安全。使用下面的安全性算法可确定系统是否处于安全状态，算法的时间复杂度为 mn²。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;银行家算法使用的数据结构：&lt;ul&gt;
&lt;li&gt;Available：长度为 m 的向量，表示每种资源当前可用的（未被分配给进程的）实例数量&lt;/li&gt;
&lt;li&gt;Max：n × m 的矩阵，&lt;code&gt;Max[i][j]&lt;/code&gt; 表示进程 Pi 在整个生命周期中需要申请资源类型 Rj 实例的最大数量&lt;/li&gt;
&lt;li&gt;Allocation：n × m 矩阵，&lt;code&gt;Allocation[i][j]&lt;/code&gt; 表示进程 Pi 当前已经持有（已被分配）的资源类型 Rj 的实例数量；Allocation 的第 i 行记作 &lt;code&gt;Allocation[i,]&lt;/code&gt;，表示进程 Pi 当前持有的不同资源类型的数量。&lt;/li&gt;
&lt;li&gt;Need：n × m 矩阵，&lt;code&gt;Need[i][j] = Max[i][j] - Allocation[i][j]&lt;/code&gt;，表示进程 Pi 还可能申请多少个 Rj 类型的资源实例；Need 的第 i 行记作 &lt;code&gt;Need[i,]&lt;/code&gt;，表示进程 Pi 结束前可能仍要申请的不同资源数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性算法&lt;/strong&gt; ：&lt;ol&gt;
&lt;li&gt;令 &lt;code&gt;Work = Available&lt;/code&gt; 为长度为 m 的行向量，表示每种资源当前剩余可用的实例数量；令 &lt;code&gt;Finish=[False for i = 0 to n-1]&lt;/code&gt; 为长度为 n 的行向量，初始化全部为 False，表示进程当前是否已结束执行。&lt;/li&gt;
&lt;li&gt;寻找一个正在执行的进程 Pi，并且 &lt;code&gt;Need[i,] ≤ Work&lt;/code&gt;，即：&lt;code&gt;Finish[i] == False &amp;amp;&amp;amp; Need[i,] ≤ Work&lt;/code&gt;，这意味着当前系统剩余资源能够满足 Pi 的全部需求。若不存在这样的进程，则调到第 4 步。&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;Work = Work + Allocation[i,]&lt;/code&gt; ，令 &lt;code&gt;Finish[i] = True&lt;/code&gt; 并跳回第 2 步。这意味着进程 Pi 已经执行结束，并且它所持有的资源全部释放，因此系统可用资源数量 &lt;code&gt;Work&lt;/code&gt; 增加。注意这一步实际 &lt;strong&gt;等价于对资源分配图的化简&lt;/strong&gt; ，它将一个可消去的进程（即该进程可以得到资源并执行完）和所有该进程与相关资源连接的边从资源分配图中删去。&lt;/li&gt;
&lt;li&gt;检查所有的 i，是否都有 &lt;code&gt;Finish[i] == True&lt;/code&gt;，若是则系统处于安全状态，否则系统处于不安全状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;安全性算法的 C 语言大致表述：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; NUM_PROCESS &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; NUM_RESOURCE &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; TRUE &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; FALSE &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; Boolean &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Available[NUM_PROCESS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Max[NUM_PROCESS][NUM_RESOURCE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Allocation[NUM_PROCESS][NUM_RESOURCE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Need[NUM_PROCESS][NUM_RESOURCE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Boolean &lt;span class=&quot;title&quot;&gt;safe&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean Finish[NUM_PROCESS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Work[NUM_PROCESS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, j, k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(Finish, FALSE, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(Boolean) * NUM_PROCESS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;memcpy&lt;/span&gt;(Work, Available, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) * NUM_PROCESS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; NUM_PROCESS; k++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NUM_PROCESS; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 寻找满足条件的 Pi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Finish[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Boolean flag = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Need[i][j] &amp;gt; Work[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    flag = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (flag)&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 寻找到进程 Pi 满足条件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Work[j] += Allocation[i][j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Finish[i] = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 进程 Pi 结束执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; k &amp;lt; NUM_PROCESS; k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!Finish[k])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源请求算法&lt;/strong&gt; ：判断进程对资源的申请是否可以维持安全性。设申请资源的进程为 Pi，&lt;code&gt;Request[i,]&lt;/code&gt; 为一个长度为 m 的行向量，表示进程 Pi 要申请的不同资源实例数量。&lt;ol&gt;
&lt;li&gt;若 &lt;code&gt;Request[i,] ≤ Need[i,]&lt;/code&gt; 则转到第 2 步，否则产生出错条件（进程 Pi 要申请的资源数量超过了它此前声明的可能使用的最大资源数量）&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;Request[i,] ≤ Available&lt;/code&gt; 则转第 3 步，否则 Pi 等待（剩余资源不满足 Pi 的请求）&lt;/li&gt;
&lt;li&gt;假设系统剩余资源足够 Pi 使用，则系统计算修改后的状态是否安全，若安全则允许修改，不安全则 Pi 必须等待。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;资源请求算法的 C 语言大致表述为：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Boolean &lt;span class=&quot;title&quot;&gt;allocate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *Request)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Request[j] &amp;gt; Need[i][j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; False;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Request[j] &amp;gt; Allocation[i][j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            wait();    &lt;span class=&quot;comment&quot;&gt;// 进程 Pi 必须等待资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Available[j] -= Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Allocation[i][j] += Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Need[i][j] -= Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 假设可以分配&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!safe())&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// 分配后不安全，恢复状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; NUM_RESOURCE; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Available[j] += Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Allocation[i][j] -= Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Need[i][j] += Request[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;死锁检测&quot;&gt;&lt;a href=&quot;#死锁检测&quot; class=&quot;headerlink&quot; title=&quot;死锁检测&quot;&gt;&lt;/a&gt;死锁检测&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果一个系统既不采用死锁预防算法，也不采用死锁避免算法，则该系统可能出现死锁。此时，系统应当提供：&lt;ul&gt;
&lt;li&gt;检查系统是否出现死锁的算法&lt;/li&gt;
&lt;li&gt;从死锁状态中恢复的算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个资源类型仅存在一个实例：可以使用资源分配图的变种 &lt;strong&gt;等待（wait-for）图&lt;/strong&gt; ，该图删去了资源分配图中的资源节点，而将原图中所有 &lt;code&gt;Pi-&amp;gt;Rj-&amp;gt;Pk&lt;/code&gt;　的边转化为 &lt;code&gt;Pi-&amp;gt;Pk&lt;/code&gt;，即进程 Pi 正在等待进程 Pk 掌握的资源。如果等待图中有环存在，则系统存在死锁。为了检测死锁，系统要维护这个等待图，并且周期性的在图中调用检测算法，该算法时间复杂度为 n²，n 为系统中进程数。&lt;/li&gt;
&lt;li&gt;每种资源类型存在多个实例：算法与银行家算法类似，仍采用 &lt;code&gt;Available&lt;/code&gt;，&lt;code&gt;Allocation&lt;/code&gt; 和 &lt;code&gt;Request&lt;/code&gt; 三个变量保存系统状态，其中此处的 &lt;code&gt;Request&lt;/code&gt; 是一个 n × m 的矩阵，&lt;code&gt;Request[i][j]&lt;/code&gt; 表示进程 Pi 当前正在申请的资源类型 Rj 的数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死锁检测算法&lt;/strong&gt; ，时间复杂度为 mn²：&lt;ol&gt;
&lt;li&gt;令 &lt;code&gt;Work = Available&lt;/code&gt; 为长度为 m 的行向量，表示每种资源当前剩余可用的实例数量；令 &lt;code&gt;Finish&lt;/code&gt; 为长度为 n 的行向量，若进程 Pi 当前未持有任何资源（Allocation[i,] == 0）则 &lt;code&gt;Finish[i] = True&lt;/code&gt;，否则 &lt;code&gt;Finish[i] = False&lt;/code&gt;。这里将不持有资源的进程设置 Finish 为 True 是因为，不持有资源的进程不会对死锁产生影响，不会有其它进程在等待该进程，这实际 &lt;strong&gt;等价于等待图中的孤立点&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;寻找一个正在执行的进程 Pi，并且 &lt;code&gt;Request[i,] ≤ Work&lt;/code&gt;，即：&lt;code&gt;Finish[i] == False &amp;amp;&amp;amp; Request[i,] ≤ Work&lt;/code&gt;，这意味着当前系统剩余资源能够满足 Pi 此刻的需求。若不存在这样的进程，则调到第 4 步。&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;Work = Work + Allocation[i,]&lt;/code&gt; 且令 &lt;code&gt;Finish[i] = True&lt;/code&gt;；跳回第 2 步。&lt;/li&gt;
&lt;li&gt;检查是否存在某个 i 有 &lt;code&gt;Finish[i] == False&lt;/code&gt;，若存在则系统处于死锁状态，且进程 Pi 死锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;注意上面的死锁检测算法的第 2 步：如果 &lt;code&gt;Request[i,] ≤ Work&lt;/code&gt; 就回收进程 Pi 的资源。这是基于如下假定，如果 Pi 不会参与到死锁中（因为 &lt;code&gt;Request[i,] ≤ Work&lt;/code&gt;，Pi的需求可以被满足所以此时一定不会被死锁），则 &lt;strong&gt;乐观地认为 Pi 直到执行结束都不会再申请更多的资源&lt;/strong&gt; 。这里的假定可能不正确，如果假定不正确，Pi 在之后又申请了更多的资源，则在系统下次运行死锁检测算法时仍然会发现，所以这里的假定不影响算法正确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用检测算法的频率&lt;/strong&gt; 受如下两个因素影响：&lt;ul&gt;
&lt;li&gt;死锁可能发生的概率多少：如果经常发生死锁则应该经常调用检测算法&lt;/li&gt;
&lt;li&gt;死锁发生时有多少进程会受影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;考虑极端情况：每当出现进程请求资源不能被立刻允许的情况时就调用死锁检测算法，则系统不仅能确定哪些进程处于死锁，还能确定导致死锁的特定进程（实际上是死锁环上的每个节点共同导致了死锁）。此种方式会导致巨大的计算开销。但如果使用较低的频率调用检测算法，或当 CPU 使用率低于某个阈值时，则调用检测算法无法确定涉及死锁的进程中是哪些导致了死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁恢复&quot;&gt;&lt;a href=&quot;#死锁恢复&quot; class=&quot;headerlink&quot; title=&quot;死锁恢复&quot;&gt;&lt;/a&gt;死锁恢复&lt;/h2&gt;&lt;h3 id=&quot;进程终止&quot;&gt;&lt;a href=&quot;#进程终止&quot; class=&quot;headerlink&quot; title=&quot;进程终止&quot;&gt;&lt;/a&gt;进程终止&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;两种方法通过终止进程来取消死锁，被终止的进程所持有的所有资源都会被系统回收：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;终止所有死锁进程&lt;/strong&gt; ：代价较大，有些进程可能已经运行很长时间而不得不放弃&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每次终止一个进程，直到死锁状态取消&lt;/strong&gt; ：开销较大，每终止一个进程都需要重新调用死锁检测算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当采用部分终止时，确定终止哪个进程/哪个进程可以打破死锁的因素涉及：&lt;ul&gt;
&lt;li&gt;进程优先级&lt;/li&gt;
&lt;li&gt;进程已运行的时间和完成任务所需要的剩余时间&lt;/li&gt;
&lt;li&gt;进程使用了哪些、多少资源，以及资源是否可抢占&lt;/li&gt;
&lt;li&gt;进程仍需多少资源&lt;/li&gt;
&lt;li&gt;有多少进程需要被终止&lt;/li&gt;
&lt;li&gt;交互进程还是批处理进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;资源抢占&quot;&gt;&lt;a href=&quot;#资源抢占&quot; class=&quot;headerlink&quot; title=&quot;资源抢占&quot;&gt;&lt;/a&gt;资源抢占&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;死锁的恢复也可以通过抢占资源来逐步取消死锁状态，需要处理三个问题：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择被抢占对象（victim）&lt;/strong&gt; ：抢占哪些进程和资源，这和死锁恢复中部分终止要考虑的因素类似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回滚（rollback）&lt;/strong&gt; ：如果从某个进程抢占资源，则被抢占的进程需要回滚到某个安全状态以便之后重新执行。完全回滚（终止被抢占的进程并重启该进程）比较容易，更有效的方式是将进程回滚到足够打破死锁的状态，但这需要系统维护更多关于进程状态的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;饥饿&lt;/strong&gt; ：如何确保不会总从同一个进程抢占资源。通常会考虑回滚次数，确保一个进程只能被抢占有限次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（六）：管程（Monitor）&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：TODO&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-7/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版死锁部分，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（六）：管程（Monitor）</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-6/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-6/</id>
    <published>2016-11-24T12:47:03.000Z</published>
    <updated>2016-11-27T02:25:24.498Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章 Monitor 部分的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;信号量提供了方便的机制处理进程同步，但不正确的使用信号量仍会导致时序错误，且难以检测。如：&lt;ul&gt;
&lt;li&gt;先对信号量 &lt;code&gt;signal()&lt;/code&gt; 再 &lt;code&gt;wait()&lt;/code&gt; 违反了互斥请求&lt;/li&gt;
&lt;li&gt;对信号量始终调用 &lt;code&gt;wait()&lt;/code&gt; 将导致死锁&lt;/li&gt;
&lt;li&gt;一个进程遗漏了 &lt;code&gt;wait()&lt;/code&gt; 或 &lt;code&gt;signal()&lt;/code&gt; 将导致死锁且可能破坏互斥&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管程（monitor）&lt;/strong&gt; 类型提供了一组由程序员定义的、在管程内互斥的操作。管程内定义的子程序只能访问位于管程内的局部变量和形式参数，管程内的局部变量也只能被管程内部的局部子程序访问。 &lt;strong&gt;管程结构确保了同时只能有一个进程在管程内活动&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;管程内部可定义 &lt;code&gt;condition&lt;/code&gt; 类型的变量以提供同步机制，称其为条件变量。条件变量可执行操作 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;我个人对条件变量的理解和信号量类似：&lt;ul&gt;
&lt;li&gt;条件变量存在于管程内部，对同一个条件变量调用操作的进程将和条件变量建立一定的联系，或者称之为绑定。对于管程内的条件变量 x，进程 P 调用 &lt;code&gt;x.wait()&lt;/code&gt; 将时自身挂起到条件变量 x 上；当另一个进程调用 &lt;code&gt;x.signal()&lt;/code&gt;时，在 x 上悬挂的进程会被重启，如果此时没有进程悬挂在 x 上，则 &lt;code&gt;x.signal()&lt;/code&gt; 操作将被忽略。&lt;/li&gt;
&lt;li&gt;管程模式下的 &lt;code&gt;x.signal()&lt;/code&gt; 和信号量的 &lt;code&gt;signal()&lt;/code&gt; 区别在于： &lt;strong&gt;信号量操作 &lt;code&gt;signal()&lt;/code&gt; 会影响信号量的状态&lt;/strong&gt; ，而管程下的 &lt;code&gt;x.signal()&lt;/code&gt; 在 x 不存在挂起进程的情况下没有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;举例：进程 P 调用 &lt;code&gt;x.signal()&lt;/code&gt;，且存在悬挂进程 Q 与条件变量 x 关联。根据管程的性质，若进程 Q 开始执行，则进程 P 必须等待。此时可能存在两种可能性，且两种可能性均有合理解释：&lt;ul&gt;
&lt;li&gt;进程 Q 重启且进程 P 等待：进程 P 将等待，直到进程 Q 离开管程或者等待另一个进程调用 &lt;code&gt;x.signal()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进程 P 唤醒进程 Q 且进程 P 继续执行：进程 Q 被唤醒，但仍然会等待，直到进程 P 离开管程，或者另一个触发条件。因为 P 已经在管程中执行，看起来此种方案更合理，但这破坏了进程 Q 正在等待的逻辑条件，进程 Q 已被触发但又未执行，因此状态难以描述&lt;/li&gt;
&lt;li&gt;Pascal 语言采用折中方式，当进程 P 执行 &lt;code&gt;x.signal()&lt;/code&gt; 时，它会立刻离开管程，且进程 Q 会立刻重新执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;哲学家进餐问题的管程解法&quot;&gt;&lt;a href=&quot;#哲学家进餐问题的管程解法&quot; class=&quot;headerlink&quot; title=&quot;哲学家进餐问题的管程解法&quot;&gt;&lt;/a&gt;哲学家进餐问题的管程解法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;strong&gt;&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程同步&lt;/a&gt;&lt;/strong&gt; 中的一种策略：当哲学家在两只筷子均可用的情况下才拿起筷子，且拿起两只筷子的动作是非抢占的。&lt;/li&gt;
&lt;li&gt;为哲学家设置三种状态：&lt;code&gt;enum {THINKING, HUNGRY, EATING} state[5]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;哲学家 i 只有在两个邻居都不进餐时才能将变量 &lt;code&gt;state[i]&lt;/code&gt; 设置为 &lt;code&gt;EATING&lt;/code&gt;，当他处在饥饿状态又无法进餐时可以使自己忍耐一段时间：&lt;code&gt;(state[(i-1)%5] != EATING) &amp;amp;&amp;amp; (state[(i+1)%5] != EATING)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下面给出用管程解决的哲学家进餐问题，只解决了互斥问题，不会导致死锁，但可能导致某个哲学家过度饥饿而死。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor dp&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &amp;#123;THINKING, HUNGRY, EATING&amp;#125; state[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition self[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[i] = HUNGRY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (state[i] != EATING)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[i].wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[i] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test((i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test((i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state[(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] != EATING) &amp;amp;&amp;amp; (state[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] != EATING))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = EATING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[i].signal();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initialization_code()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;一个改进版的 Monitor 解决方案如下。筷子本身并不属于 monitor 的一部分，否则同时只能有一个哲学家在进餐。代码中 &lt;code&gt;NUM_PHILS&lt;/code&gt; 是哲学家数目。此代码解决了哲学家饥饿问题，来自&lt;a href=&quot;http://www.csee.wvu.edu/~jdm/classes/cs550/notes/tech/mutex/dp-mon.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西弗吉尼亚大学&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;monitor dp&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    condition self[NUM_PHILS];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; states &amp;#123;THINKING, HUNGRY, EATING&amp;#125; state[NUM_PHILS-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initialization_code()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (index=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; index&amp;lt;NUM_PHILS; index++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flags[index] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[mynum] = HUNGRY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state[(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] != EATING) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (state[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] != EATING))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = EATING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 挂起，等待相邻哲学家改变状态时唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[i].wait;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state[i] = EATING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[i] = THINKING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 唤醒左侧哲学家&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state [(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] == HUNGRY) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (state [(i-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)%NUM_PHILS] != EATING))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[(i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS].signal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 唤醒右侧哲学家&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((state [(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS] == HUNGRY) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            (state [(i+&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)%NUM_PHILS] != EATING))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%NUM_PHILS].signal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;使用信号量实现管程&quot;&gt;&lt;a href=&quot;#使用信号量实现管程&quot; class=&quot;headerlink&quot; title=&quot;使用信号量实现管程&quot;&gt;&lt;/a&gt;使用信号量实现管程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;要实现的管程对于重启进程采用的策略是： &lt;strong&gt;调用 &lt;code&gt;x.signal()&lt;/code&gt; 的进程挂起自己，直到重新启动的进程离开或者等待&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;每个管程都有一个信号量 &lt;code&gt;mutex&lt;/code&gt; 初始化为 1，进程进入管程之前必须通过 &lt;code&gt;wait()&lt;/code&gt; 获得允许，离开时需要调用 &lt;code&gt;signal()&lt;/code&gt; 释放权限。&lt;/li&gt;
&lt;li&gt;信号量 &lt;code&gt;next&lt;/code&gt; 初始化为 0，供线程在唤醒重启进程时挂起自己，整数变量 &lt;code&gt;next_count&lt;/code&gt; 用于对挂起在 &lt;code&gt;next&lt;/code&gt; 上的进程数量计数。&lt;/li&gt;
&lt;li&gt;进入管程的外部子程序结构 F 如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// body&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (next_count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(next);    &lt;span class=&quot;comment&quot;&gt;//     此前有进程挂起，重启该进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(mutex);   &lt;span class=&quot;comment&quot;&gt;//     管程内无进程挂起，释放控制权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;对每个管程内的条件变量 &lt;code&gt;x&lt;/code&gt;，引入信号量 &lt;code&gt;x_sem&lt;/code&gt; 和整数变量 &lt;code&gt;x_count&lt;/code&gt; 记录信号量 x 上挂起的进程数量，均初始化为 0。&lt;code&gt;x.wait()&lt;/code&gt; 和 &lt;code&gt;x.signal()&lt;/code&gt; 实现如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; x.wait()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x_count++;            &lt;span class=&quot;comment&quot;&gt;// 将进程挂起到 x 上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (next_count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;// 当前仍有进程挂起在管程中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(mutex);    &lt;span class=&quot;comment&quot;&gt;// 无进程在等待，释放管程控制权&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(x_sem);          &lt;span class=&quot;comment&quot;&gt;// 等待信号量 x_sem，由信号量决定唤醒哪个挂起进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x_count--; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; x.signal()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x_count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;     &lt;span class=&quot;comment&quot;&gt;// 当前有程序挂起在条件变量 x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_count ++;    &lt;span class=&quot;comment&quot;&gt;// 管程挂起数增加&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(x_sem);    &lt;span class=&quot;comment&quot;&gt;// 释放信号量，唤醒一个挂起进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(next);       &lt;span class=&quot;comment&quot;&gt;// 将自身阻塞到管程中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_count--;     &lt;span class=&quot;comment&quot;&gt;// 继续执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（五）：进程同步&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（七）：死锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-6/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章 Monitor 部分的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（五）：进程同步</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-5/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-5/</id>
    <published>2016-11-24T10:41:33.000Z</published>
    <updated>2016-11-27T02:26:27.438Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程同步部分的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;信号量&quot;&gt;&lt;a href=&quot;#信号量&quot; class=&quot;headerlink&quot; title=&quot;信号量&quot;&gt;&lt;/a&gt;信号量&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基于硬件的 &lt;code&gt;TestAndSet()&lt;/code&gt; 和 &lt;code&gt;Swap()&lt;/code&gt; 对应用程序员而言相对复杂，可使用 &lt;strong&gt;信号量（semaphore）&lt;/strong&gt; 作为同步工具。信号量 S 是整数变量，除初始化外只能通过两个原子操作访问：&lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt;，在有些地方使用 &lt;code&gt;P&lt;/code&gt;（测试） 和 &lt;code&gt;V&lt;/code&gt;（增加）表示。所有关于信号量的讨论均已具备以下前提：在这两个原子访问操作中，对信号量整型值的测试和修改都是不可分的，也就是说，当一个进程修改某个信号量时，其他进程都不能同时操作该信号量。&lt;/li&gt;
&lt;li&gt;信号量按值域可分为&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;计数信号量（counting semaphore）&lt;/strong&gt; ：信号量值域不受限制。此类信号量用于控制访问具有若干个实例的某类资源，初始化信号量为可用资源的数量，进程通过调用 &lt;code&gt;wait()&lt;/code&gt; 操作获取资源（此时信号量计数也随之减少），进程使用资源后通过 &lt;code&gt;signal()&lt;/code&gt; 操作释放资源（信号量计数随之增加）。当信号量的值小于等于 0 时，所有调用 &lt;code&gt;wait()&lt;/code&gt; 操作的进程会被阻塞，直到某个进程调用了 &lt;code&gt;signal()&lt;/code&gt; 释放了可用资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二进制信号量（binary semaphore）&lt;/strong&gt; ：信号量的值只能为 0 或者 1，该类信号量也称为 &lt;strong&gt;互斥锁（mutex locks）&lt;/strong&gt; ，可提供互斥操作。对于多进程的临界区问题，可以使所有进程共享一个二进制信号量 mutex，每个进程进入临界区之前调用 &lt;code&gt;waiting(mutex)&lt;/code&gt; ，离开临界区之前调用 &lt;code&gt;signal(mutex)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号量按功能可分：&lt;ul&gt;
&lt;li&gt;公有（互斥）信号量：多个进程均需要同一个信号量所代表的资源，信号量起到了互斥的作用&lt;/li&gt;
&lt;li&gt;私有（同步）信号量：部分进程向信号量释放资源，其他进程向信号量请求资源，信号量起到了同步的作用，保证了进程之间执行的先后顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;信号量的主要缺点是 &lt;strong&gt;忙等待（busy waiting）&lt;/strong&gt; ，当一个进程位于临界区内时，其它试图进入临界区的进程都陷入循环检查的状态。这样的信号量也称为 &lt;strong&gt;旋转锁（spinlock）&lt;/strong&gt; ，它也具有优点：进程在等待锁时不会进行上下文切换（上下文切换可能会花费很长的时间），因此如果等待锁的时间较短则旋转锁更有效。旋转锁通常用于多处理器系统，一个线程在某个处理器旋转时，另一个线程在另一个处理器的临界区内执行。&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;进程执行 &lt;code&gt;wait()&lt;/code&gt; 时若信号量值不为正则调用 &lt;code&gt;block()&lt;/code&gt; 操作将其阻塞，阻塞操作包括：将该进程状态切换为等待，将该进程放到信号量内部的一个等待队列中。之后 CPU 调度程序选择另一个进程执行。&lt;/li&gt;
&lt;li&gt;进程执行 &lt;code&gt;signal()&lt;/code&gt; 操作后，信号量值会增加。同时若存在进程阻塞在信号量上，则操作系统从信号量内部等待队列中选取一个进程，调用 &lt;code&gt;wakeup()&lt;/code&gt; 操作将其唤醒，唤醒操作包括：将该进程从等待状态切换到就绪状态、放入就绪队列中（根据 CPU 调度算法，CPU 不一定会选择这个线程立刻执行）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信号量的 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt; 操作可定义如下，每个信号量包括一个整型值和一个 PCB 链表指针，使用 FIFO 队列可确保有限等待，但一般来说链表可以使用任何排队策略，信号量的使用方式和链表排队策略无关：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; process *&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// PCB 块链表指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; semaphore;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(semaphore *S)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    S-&amp;gt;value--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (S-&amp;gt;value &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 无可用资源，将进程加入信号量等待列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(semaphore *S)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    S-&amp;gt;value++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (S-&amp;gt;value &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 从信号量等待列表中选取一个进程唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wakeup(P);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;信号量的 &lt;em&gt;关键在于它们的执行具有原子性&lt;/em&gt; 。在单处理器上，可在调用 &lt;code&gt;wait()&lt;/code&gt; 和 &lt;code&gt;signal()&lt;/code&gt; 时禁止中断，而在多处理器系统上，仍需要使用其它加锁计数（如旋转锁）来确保信号量的原子性，因此信号量本身的实现还是没有完全取消忙等，仅仅是 &lt;em&gt;把忙等的状态从等待进入临界区转移到了临界区执行时&lt;/em&gt; ，因为经过合理设计的临界区通常比较短，因此比简单的忙等效率高一些。但在临界区很长的情况下，因为采用了忙等，导致信号量极为低效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;死锁和饥饿&quot;&gt;&lt;a href=&quot;#死锁和饥饿&quot; class=&quot;headerlink&quot; title=&quot;死锁和饥饿&quot;&gt;&lt;/a&gt;死锁和饥饿&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当两个或多个进程无限等待一个事件，而该事件只能由等待该事件的某个进程来触发（执行 signal 操作），这种情况下，这些进程称为 &lt;strong&gt;死锁（deadlocked）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;链表的出入顺序对信号量有影响，如果采用 LIFO 顺序增加、取出进程，则可能导致 &lt;strong&gt;无穷阻塞（indefinite blocking）&lt;/strong&gt; 或 &lt;strong&gt;饥饿（starvation）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;经典同步问题&quot;&gt;&lt;a href=&quot;#经典同步问题&quot; class=&quot;headerlink&quot; title=&quot;经典同步问题&quot;&gt;&lt;/a&gt;经典同步问题&lt;/h1&gt;&lt;h2 id=&quot;有限缓冲问题&quot;&gt;&lt;a href=&quot;#有限缓冲问题&quot; class=&quot;headerlink&quot; title=&quot;有限缓冲问题&quot;&gt;&lt;/a&gt;有限缓冲问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;进程互斥&lt;/a&gt;&lt;/strong&gt; 中的生产者-消费者问题可以通过三个信号量解决：&lt;ul&gt;
&lt;li&gt;二进制信号量 &lt;code&gt;mutex&lt;/code&gt; 保证了对缓冲池访问的互斥&lt;/li&gt;
&lt;li&gt;计数信号量 &lt;code&gt;empty&lt;/code&gt; 和 &lt;code&gt;full&lt;/code&gt; 表示缓冲区中空余数量和已有数据数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生产者和消费者进程使用如下架构保证互斥和同步：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// producer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// produce an item&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(empty);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// put item into buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(full);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// consumer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(full);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// remove an item from buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(empty);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;读者-写者问题&quot;&gt;&lt;a href=&quot;#读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;读者-写者问题&quot;&gt;&lt;/a&gt;读者-写者问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个数据库可以被多个并发进程共享，有的进程只需要读数据库，而有的进程需要读或写数据库。将只需要读权限的进程称为 &lt;strong&gt;读者（Reader）&lt;/strong&gt; ，需要写权限的进程称为 &lt;strong&gt;写者（Writer）&lt;/strong&gt; 。如果一个写者和其它进程（无论读写）同时访问共享对象，则可能导致混乱。&lt;/li&gt;
&lt;li&gt;有多种优先级方案：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一读者-写者问题&lt;/strong&gt; ：读者优先，如果当前获得数据库权限的是读者进程，则其它读者进程无需等待，读者进程只有在当前操作数据库的进程是写者的情况下才需要阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二读者-写者问题&lt;/strong&gt; ：写者优先，任何在等待获取数据库权限的写者进程都将比其它正在等待的读者进程先获得权限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三读者-写者问题&lt;/strong&gt; ：前两种策略都会导致写者或者读者的饥饿，此策略将保证没有任何进程会被无限阻塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读者-写者问题在以下情况非常有效：&lt;ul&gt;
&lt;li&gt;当进程可以按照对共享对象所需的读写权限划分时&lt;/li&gt;
&lt;li&gt;当读者进程数比写者进程数多时：因为读写锁的建立开销比信号量或互斥锁要大，此开销可通过允许多个读者并发来弥补&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第一读者-写者问题&quot;&gt;&lt;a href=&quot;#第一读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;第一读者-写者问题&quot;&gt;&lt;/a&gt;第一读者-写者问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;读优先，只要当前有读者在操作对象，所有读者都可以加入操作而不必等待。&lt;/li&gt;
&lt;li&gt;进程共享如下数据：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;semaphore mutex, wrt&lt;/code&gt;：二者均初始化为 1，信号量 &lt;code&gt;wrt&lt;/code&gt; 用作读写进程的互斥锁，信号量 &lt;code&gt;mutex&lt;/code&gt; 则用于确保更新变量 &lt;code&gt;readcount&lt;/code&gt; 时互斥。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int readcount&lt;/code&gt;：跟踪当前有多少个进程正在读对象，初始化为 0。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写者-读者进程结构如下，代码来自原书（英文版）第 206 页。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行写操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 若此读进程为等待的第一个读者，则需要先获取对象的权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行读操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 若此读进程为最后一个离开的读者，则需要释放对象权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(wrt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;第二读者-写者问题&quot;&gt;&lt;a href=&quot;#第二读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;第二读者-写者问题&quot;&gt;&lt;/a&gt;第二读者-写者问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;写优先，只要当前有写者在操作对象，所有写者都将排队等待，中间不允许读者插入。只有所有写者完成处理后，读者才有机会访问。&lt;/li&gt;
&lt;li&gt;进程之间共享如下数据：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int readcount, writecount&lt;/code&gt;：&lt;code&gt;readcount&lt;/code&gt; 记录当前正在等待读对象的读者数量，&lt;code&gt;writecount&lt;/code&gt; 记录当前正在等待写对象的写者数量，均初始化为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore rmutex, wmutex&lt;/code&gt;：确保更新变量 &lt;code&gt;readcount&lt;/code&gt; 和 &lt;code&gt;writecount&lt;/code&gt; 时的互斥，均初始化为 1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore readTry&lt;/code&gt;：&lt;code&gt;readTry&lt;/code&gt; 信号量用于声明有读者加入等待队列，确保读者和写者之间的互斥，初始化为 1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;semaphore resource&lt;/code&gt;：&lt;code&gt;resource&lt;/code&gt; 信号量用于确保写者和写者之间的互斥，初始化为 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读者-写者结构如下，基本算法来自维基百科。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 读者必须在当前没有写者在操作对象时才可进入等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保证了写优先&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个读者需要获取资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readcount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readcount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最后一个离开的读者需要释放资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(rmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writecount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (writecount == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个写者需要禁止其他读者进入等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 进入临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 写操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 离开临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    writecount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (writecount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最后一个离开的写者需要释放资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(readTry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(wmutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;第三读者-写者问题&quot;&gt;&lt;a href=&quot;#第三读者-写者问题&quot; class=&quot;headerlink&quot; title=&quot;第三读者-写者问题&quot;&gt;&lt;/a&gt;第三读者-写者问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;保证读者和写者均不会出现饥饿现象。&lt;/li&gt;
&lt;li&gt;进程之间共享的信号量有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int readCount&lt;/code&gt;：当前正在访问对象的读者数量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore resourceAccess&lt;/code&gt;：资源的控制权限，使读者、写者互斥，初始化为 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore readCountAccess&lt;/code&gt;：保证对 &lt;code&gt;readCount&lt;/code&gt; 操作的互斥，初始化为 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore serviceQueue&lt;/code&gt;：保持请求的顺序，维护先进先出特性，初始化为 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读者-写者结构如下，基本算法来自维基百科。可能有多个进程在服务队列中等待，当前进入临界区的进程离开后，等待的进程就会接替离开的进程。当 &lt;code&gt;serviceQueue&lt;/code&gt; 中阻塞了多个进程时，选择进程唤醒的顺序取决于信号量的链表，因此 &lt;strong&gt;&lt;code&gt;serviceQueue&lt;/code&gt; 的链表必须维持 FIFO 特性才能保证不会导致饥饿&lt;/strong&gt; 。因此，解决饥饿问题实际是由链表的 FIFO 带来的。另一个值得注意的地方是，无论写者还是读者，获得了服务队列的权限后，在获取资源控制权前都将禁止其他任何进程接受服务，而因为只有紧随写者进程的读者才需要获取资源权限，所以在此算法中读者可以同时并发访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 读者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在服务队列中等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readCount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 第一个读者要从写者手中接管资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 允许下一个进程进入服务队列等待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    readCount--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (readCount == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 最后一个离开的读者要释放资源权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(readCountAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(serviceQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(resourceAccess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;哲学家进餐问题&quot;&gt;&lt;a href=&quot;#哲学家进餐问题&quot; class=&quot;headerlink&quot; title=&quot;哲学家进餐问题&quot;&gt;&lt;/a&gt;哲学家进餐问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题描述：假设有 5 个哲学家共用一个圆桌，每人左右两边各有一根筷子，哲学家之间不互相交流。当哲学家感到饥饿时会依次拿起自己身边的筷子（一次只能拿起一根筷子、不能从其它哲学家手中拿筷子），当哲学家同时拥有两根筷子时可以开始进餐，否则将等待空闲的筷子（且并不放下已握在手中的筷子），吃完后他将放下两只筷子。&lt;/li&gt;
&lt;li&gt;一种简单方法是每根筷子使用一个信号量，哲学家通过 &lt;code&gt;wait()&lt;/code&gt; 请求相应的筷子，通过 &lt;code&gt;signal()&lt;/code&gt; 释放相应的筷子。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(chopstick[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wait(chopstick[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 进餐&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(chopstick[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    signal(chopstick[(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)%&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上面的算法解决了筷子的互斥问题，但可能导致死锁。若五个哲学家同时拿起同一边的筷子，则所有人都将永远等待。可行的解决方法有：&lt;ul&gt;
&lt;li&gt;最多只允许四个哲学家同时坐在桌上&lt;/li&gt;
&lt;li&gt;只有两只筷子都可用时才允许一个哲学家拿起筷子，且拿起两只筷子的操作在临界区内进行&lt;/li&gt;
&lt;li&gt;编号为奇数的哲学家先拿起左边的筷子再拿起右边的筷子，编号为偶数的哲学家先拿起右边的筷子再拿起左边的筷子&lt;/li&gt;
&lt;li&gt;Dijkstra解法：每个哲学家都先拿起身边编号较小的筷子，再拿起编号较高的筷子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 Dijkstra 解法的哲学家就餐问题解法如下，伪代码根据维基百科的算法描述编写。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;philosopher&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    leftChopstickIndex = index;    &lt;span class=&quot;comment&quot;&gt;// 左侧筷子编号为哲学家编号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rightChopstickIndex = (index + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % Philosophers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    firstIndex = min(leftChopstickIndex, rightChopstickIndex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondIndex = max(leftChopstickIndex, rightChopstickIndex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(chopstick[firstIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(chopstick[secondIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 进餐&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(chopstick[firstIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        signal(chopstick[secondIndex]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 释放资源的顺序可随意&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（四）：进程互斥&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（六）：管程（Monitor）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-5/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程同步部分的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（四）：进程互斥</title>
    <link href="http://forec.github.io/2016/11/24/os-concepts-4/"/>
    <id>http://forec.github.io/2016/11/24/os-concepts-4/</id>
    <published>2016-11-24T07:29:44.000Z</published>
    <updated>2016-11-27T02:22:58.803Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程互斥部分的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;生产者-消费者冲突模型&quot;&gt;&lt;a href=&quot;#生产者-消费者冲突模型&quot; class=&quot;headerlink&quot; title=&quot;生产者-消费者冲突模型&quot;&gt;&lt;/a&gt;生产者-消费者冲突模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;生产者-消费者（producer-consumer）&lt;/strong&gt; 问题：生产者进程产生用来被消费者进程消耗的数据，例如一个编译器产生汇编代码，此代码交由汇编器生成对象。生产者、消费者进程之间可通过共享内存来传递数据，可分为：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无限缓冲（unbounded buffer）&lt;/strong&gt; ：共享内存大小没有限制，当缓冲区为空时，消费者进程需要等待；生产者进程在任何时候都可以直接向缓冲区中投放数据而无需等待&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限缓冲（bounded buffer）&lt;/strong&gt; ：内存共享的缓冲区域大小固定，若缓冲区为空则消费者进程需要等待；若缓冲区已满则生产者进程需要等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;雏形&quot;&gt;&lt;a href=&quot;#雏形&quot; class=&quot;headerlink&quot; title=&quot;雏形&quot;&gt;&lt;/a&gt;雏形&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;采用共享内存、有限缓冲的生产者消费者代码如下（原书 99 页第三章初次介绍共享内存模型时的代码）。共享缓冲通过循环数组和两个逻辑指针 &lt;code&gt;in&lt;/code&gt;、&lt;code&gt;out&lt;/code&gt; 实现，变量 &lt;code&gt;in&lt;/code&gt; 指向缓冲中下一个空位，&lt;code&gt;out&lt;/code&gt; 指向缓冲中的下一个待取走的数据位，&lt;code&gt;(in+1)%BUFFER_SIZE == out&lt;/code&gt; 时缓冲区满。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;define&lt;/span&gt; BUFFER_SIZE &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item buffer[BUFFER_SIZE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; in = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; out = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// producer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item nextProduced;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (((in + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE) == out) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buffer[in] = nextProduced;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    in = (in + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// consumer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item nextConsumed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (in == out) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nextConsumed = buffer[out];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    out = (out+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上面的代码存在缺陷，生产者、消费者进程能够使用的最大缓冲区为 BUFFER_SIZE - 1，并且代码也没有解决生产者、消费者进程同时访问共享内存的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;改进&quot;&gt;&lt;a href=&quot;#改进&quot; class=&quot;headerlink&quot; title=&quot;改进&quot;&gt;&lt;/a&gt;改进&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为使进程能够使用全部缓冲区，使用一个初始化为 0 的整数变量 &lt;code&gt;counter&lt;/code&gt; 记录当前缓冲区中的元素数量；每当生产者向缓冲区投放数据，&lt;code&gt;counter&lt;/code&gt; 递增；当消费者从缓冲区取走数据，&lt;code&gt;counter&lt;/code&gt; 递减。可修改上面代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// producer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (counter == BUFFER_SIZE) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buffer[in] = nextProduced;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    in = (in+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// consumer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (counter == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nextConsumed = buffuer[out];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    out = (out+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % BUFFER_SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter --;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;以上代码可使用全部缓冲区资源，但当消费者进程和生产者进程并发执行时，涉及修改 &lt;code&gt;counter&lt;/code&gt; 的语句执行顺序将由操作系统设定。由于 C 语言中 &lt;code&gt;counter++&lt;/code&gt; 将被拆分为 &lt;code&gt;mov register, counter&lt;/code&gt;、&lt;code&gt;inc register&lt;/code&gt; 和 &lt;code&gt;mov counter, register&lt;/code&gt; 三句汇编指令，假设由于操作系统的调度，当前消费者进程和生产者进程分别执行到 &lt;code&gt;counter++&lt;/code&gt; 和 &lt;code&gt;counter--&lt;/code&gt; 的最后一条汇编指令处，则 &lt;code&gt;counter&lt;/code&gt; 的值将不正确。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;竞争条件（race condition）&lt;/strong&gt; ：多个进程同时访问和操作一个相同的数据，且执行结果和访问的特定顺序有关&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程同步（process synchronization）&lt;/strong&gt; 和 &lt;strong&gt;协调（coordination）&lt;/strong&gt; ：确保系统不同部分操作资源不会互相影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;临界区&quot;&gt;&lt;a href=&quot;#临界区&quot; class=&quot;headerlink&quot; title=&quot;临界区&quot;&gt;&lt;/a&gt;临界区&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;系统中有 n 个进程&lt;code&gt;{P0, P1, ..., Pn-1}&lt;/code&gt;，每个进程有一个代码段称为 &lt;strong&gt;临界区（critical section）&lt;/strong&gt; ，在该区域中，不同的进程可能会改变相同的数据。临界区中应当最多同时存在一个进程。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;临界区问题&lt;/em&gt; 指设计一个使进程协作的协议：&lt;ul&gt;
&lt;li&gt;每个进程需先请求进入临界区（请求的代码称为 &lt;strong&gt;进入区，entry section&lt;/strong&gt; ）；&lt;/li&gt;
&lt;li&gt;获得允许，进入临界区执行&lt;/li&gt;
&lt;li&gt;退出临界区（ &lt;strong&gt;退出区，exit section&lt;/strong&gt; ）&lt;/li&gt;
&lt;li&gt;执行剩余代码（ &lt;strong&gt;剩余区，remainder section&lt;/strong&gt; ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;临界区问题的解决必须满足如下三个要求：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥（mutual exclusion）&lt;/strong&gt; ：若进程 Pi 正在其临界区内，则其他进程都不能在临界区中执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发展（前进，progress）&lt;/strong&gt; ：如果当前没有进程在临界区内，并且有一些进程在请求进入临界区，则只有不处在剩余区的进程可以参与到选择（选择哪个进程进入临界区）中。这个选择不能被无限期推迟，即必须立刻作出决定。简单的说， &lt;strong&gt;进入临界区请求的选择不应当受当前在剩余区执行进程的影响&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限等待（bounded waiting）&lt;/strong&gt; ：从一个进程发出进入临界区请求，到该请求被允许，这期间只能有有限的其它进程进入临界区。即保证了每个进程都有机会进入临界区而不会饥饿。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;假定每个进程的执行速度都不为 0，但是不能对 n 个进程的 &lt;strong&gt;相对速度（relative speed）&lt;/strong&gt; 做任何假设。&lt;/li&gt;
&lt;li&gt;操作系统内部的临界区问题：操作系统内同一时刻可能有多个处于内核模式的活动进程，有两种方法解决。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抢占内核（preemptive kernel）&lt;/strong&gt; ：允许处于内核模式的进程被抢占。此模式可能导致竞争条件，在对称多处理器体系中，此模式更难设计。但此模式适合实时编程，响应更快（Linux 2.6之后内核和 Solaris、IRIX 均为抢占内核）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非抢占内核（nonpreemptive kernel）&lt;/strong&gt; ：不允许处于内核模式的进程被抢占，处于内核模式的进程会一直运行，直到其退出内核模式、阻塞或者自动释放对 CPU 的控制。这种方式根本不会导致竞争条件的产生。Windows XP、Windows 2000 和传统 UNIX 均为非抢占内核。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Peterson-算法&quot;&gt;&lt;a href=&quot;#Peterson-算法&quot; class=&quot;headerlink&quot; title=&quot;Peterson 算法&quot;&gt;&lt;/a&gt;Peterson 算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Peterson 算法&lt;/strong&gt; 是对基于软件的临界区问题的经典解答，但由于现代计算机体系结构执行基本语言指令的不同方式，该算法在此类机器上不能正确执行。&lt;/li&gt;
&lt;li&gt;Peterson 算法仅适用于两个进程（P0和P1），它们都在临界区和剩余区间交替执行。以下当使用 Pi 表示一个进程时，使用 Pj 表示另一个（j == 1-i）。&lt;/li&gt;
&lt;li&gt;Peterson 算法需要在进程间共享两个数据项：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int turn&lt;/code&gt;：指定哪个进程可以进入临界区，若 turn == i，则 Pi 被允许&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean flag[2]&lt;/code&gt;：&lt;code&gt;flag[i]&lt;/code&gt; 表示进程 i 已发出进入临界区请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Peterson 算法中进程 Pi 的结构如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flag[i] = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    turn = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (flag[j] &amp;amp;&amp;amp; turn == j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flag[i] = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Peterson 算法正确性的证明：&lt;ul&gt;
&lt;li&gt;互斥：只有当 &lt;code&gt;flag[j] == FALSE&lt;/code&gt; 或 &lt;code&gt;turn == i&lt;/code&gt; 时 Pi 才进入临界区。假设 Pi 和 Pj 同时进入临界区，则 &lt;code&gt;flag[0] == flag[1] == TRUE&lt;/code&gt;，因为 turn 只能为 0 或 1，所以只有一个进程（假设 &lt;code&gt;turn == i&lt;/code&gt;）Pi 能够跳出 While 语句。此外，只要 Pi 在临界区内，&lt;code&gt;flag[i] == TRUE &amp;amp;&amp;amp; turn == i&lt;/code&gt; 就始终成立，所以 Pi 在临界区执行期间，Pj 将始终等待或执行剩余区内容。&lt;/li&gt;
&lt;li&gt;发展和有限等待：进程 Pi 仅在 &lt;code&gt;flag[j] == True&lt;/code&gt; 且 &lt;code&gt;turn == j&lt;/code&gt; 的情况下才会被阻塞，若 Pj 不准备进入临界区，则 &lt;code&gt;flag[j] == True&lt;/code&gt;，此时 Pi 可以进入；若 Pj 当前也在请求进入临界区，则 &lt;code&gt;flag[j] == True&lt;/code&gt;，此时由 turn 决定哪个进程进入临界区。假设此时 Pj 进入临界区，当 Pj 退出临界区时会设置 &lt;code&gt;flag[j]&lt;/code&gt; 为 False 使 Pi 进入临界区；如果 Pj 剩余区执行速度非常快，又重新申请进入临界区，此时 Pj 设置 &lt;code&gt;flag[j]&lt;/code&gt; 为 TRUE，同时 turn 被设置为 i。因此 Pi 一定会进入临界区（发展），并且最多需要等待一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Bakery-算法（补充）&quot;&gt;&lt;a href=&quot;#Bakery-算法（补充）&quot; class=&quot;headerlink&quot; title=&quot;Bakery 算法（补充）&quot;&gt;&lt;/a&gt;Bakery 算法（补充）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Bakery 算法适用于 n 个进程的临界区问题。&lt;/li&gt;
&lt;li&gt;在进入临界区之前，进程需要申请一个号码，拥有最小号码的进程会被允许进入临界区。如果两个进程 Pi 和 Pj 申请到的号码相同（申请号码不是临界区，因此可能获得相同号码），则比较进程编号 i 和 j，编号小的先执行。&lt;/li&gt;
&lt;li&gt;进程可申请到的号码始终是递增的。定义元组比较为 &lt;code&gt;(a, b) &amp;lt; (c, d) if a &amp;lt; c || a == c &amp;amp;&amp;amp; b &amp;lt; d&lt;/code&gt;，定义最大值函数 &lt;code&gt;max(a0, a1, ..., an-1)&lt;/code&gt; 为 a0 ~ an-1 中的最大值。&lt;/li&gt;
&lt;li&gt;Bakery 算法使用的共享数据有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boolean choosing[n]&lt;/code&gt;：&lt;code&gt;choosing[i] == TRUE&lt;/code&gt; 表明进程 Pi 当前正在申请进入临界区或者正在临界区中执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int number[n]&lt;/code&gt;：&lt;code&gt;number[i]&lt;/code&gt; 为进程 Pi 当前申请到的号码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bakery 算法流程如下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    choosing[i] = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    number[i] = max(number[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], number[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], ..., number[n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    choosing[i] = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; n; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 此循环保证所有比当前进程持更高优先级的进程已离开临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (chossing[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (number[j] != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (number[j], j) &amp;lt; (number[i], i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    number[i] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Bakery 算法正确性证明：&lt;ul&gt;
&lt;li&gt;首先，元组的大小比较和取号规则（只增）保证了全部进程都可维持一个严格递增的顺序，而不会出现两个进程地位相等的情况。&lt;/li&gt;
&lt;li&gt;互斥：假设进程 Pi 已进入临界区，则 for 循环保证了，当前所有进程，号码比 Pi 的号码小的进程均已不在临界区，而号码比 Pi 大的进程将因为 &lt;code&gt;number[i] != 0&lt;/code&gt; 而被阻塞在它们自己的 for 循环中，因此仅有 Pi 可进入临界区。互斥条件满足。&lt;/li&gt;
&lt;li&gt;发展：假设一个进程 Pj 执行完临界区，则其进入剩余区之前将使 &lt;code&gt;number[j] == 0&lt;/code&gt;，此时所有在等待进入临界区的进程中，按元组比较最小的那个进程将因为 &lt;code&gt;number[j] == 0&lt;/code&gt; 而跳出 while 循环，此后它将跳过剩余的 for 循环（因为其它进程的元组均大于它）并进入临界区，而其它进程都将继续等待。因此在剩余区的进程（Pj）不会影响到进入临界区申请的选择。&lt;/li&gt;
&lt;li&gt;有限等待：假设一个进程 Pi 已经申请到号码 &lt;code&gt;number[i]&lt;/code&gt;，此时所有后申请进入临界区的进程 Pj 都会有 &lt;code&gt;number[j] &amp;gt; number[i]&lt;/code&gt;，且在 Pi 执行完临界区之前，Pj 都会因为 &lt;code&gt;number[i] != 0&lt;/code&gt; 且 &lt;code&gt;number[i] &amp;lt; number[j]&lt;/code&gt; 而阻塞。因此进程 Pi 至多等待 n-1 个进程即可进入临界区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;硬件同步&quot;&gt;&lt;a href=&quot;#硬件同步&quot; class=&quot;headerlink&quot; title=&quot;硬件同步&quot;&gt;&lt;/a&gt;硬件同步&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;无论软硬件方式，解决临界区问题都需要 &lt;strong&gt;锁（lock）&lt;/strong&gt; ，所有解决方案都基于锁，且锁的设计可能非常复杂。进程在进入临界区之前获得锁，退出临界区时释放锁。&lt;/li&gt;
&lt;li&gt;硬件特性可以简化编程并提高效率。现代计算机系统提供了特殊硬件指令以允许程序 &lt;strong&gt;原子（atomically）&lt;/strong&gt; 检查和修改字地内容或交换两个字地内容。以下的 &lt;code&gt;TestAndSet()&lt;/code&gt; 和 &lt;code&gt;Swap()&lt;/code&gt; 函数均为原子操作，即硬件保证了它们作为一个完整过程执行而不会被抢占。它们的定义如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;boolean &lt;span class=&quot;title&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(boolean *target)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean rv = *target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *target = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; rv;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(boolean *a, boolean *b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean temp = *a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *a = *b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;仅使用 &lt;code&gt;TestAndSet()&lt;/code&gt; 或仅使用 &lt;code&gt;Swap()&lt;/code&gt; 都可以解决互斥问题。以下是单独使用这二者实现的互斥，但均未满足有限等待的要求：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// TestAndSet Lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( TestAndSetLock(&amp;amp;&lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;FALSE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Swap Lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    key = &lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(key == &lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Swap(&amp;amp;&lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt;, &amp;amp;key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;lock&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;FALSE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;TRUE&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;TestAndSet()&lt;/code&gt; 或 &lt;code&gt;Swap()&lt;/code&gt; 也可以解决有限等待问题，以下是使用 &lt;code&gt;TestAndSet()&lt;/code&gt; 实现的有限等待互斥，代码为进程 Pi 的结构，来自原书（英文版）第 199 页。可以看出，剩余区前的 while 循环保证一个进程 Pi 强制拉取了排在其后的进程 Pj 进入临界区（如果有的话），这保证了有限等待。使用到的共享数据有：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boolean waiting[n]&lt;/code&gt;：&lt;code&gt;waiting[i] == TRUE&lt;/code&gt; 表明进程 i 已申请进入临界区并正在等待选择&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean lock&lt;/code&gt;：lock 是进程间共享的锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    waiting[i] = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    key = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (waiting[i] &amp;amp;&amp;amp; key)    &lt;span class=&quot;comment&quot;&gt;// 进程排队&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        key = TestAndSet(&amp;amp;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    waiting[i] = FALSE;          &lt;span class=&quot;comment&quot;&gt;// 进程标注自己已进入临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    j = (i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((j != i) &amp;amp;&amp;amp; !waiting[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j = (j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (j == i)                  &lt;span class=&quot;comment&quot;&gt;// 当前无其他进程排队则释放锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lock = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        waiting[j] = FALSE;      &lt;span class=&quot;comment&quot;&gt;// 强制拉取后一个进程进入临界区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩余区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(TRUE);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/23/os-concepts-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（三）：CPU 调度&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（五）：进程同步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/24/os-concepts-4/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第六章进程互斥部分的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（三）：CPU 调度</title>
    <link href="http://forec.github.io/2016/11/23/os-concepts-3/"/>
    <id>http://forec.github.io/2016/11/23/os-concepts-3/</id>
    <published>2016-11-23T13:49:05.000Z</published>
    <updated>2016-11-24T10:51:38.095Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第五章（CPU 进程调度），内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;CPU 调度是多道程序操作系统的基础，在进程之间切换 CPU 可以提高计算机的吞吐率。&lt;/li&gt;
&lt;li&gt;进程执行由 CPU 执行和 I/O 等待 &lt;strong&gt;周期（cycle）&lt;/strong&gt; 组成，进程在这两个状态之间切换。进程执行从 &lt;strong&gt;CPU区间（CPU burst）&lt;/strong&gt; 开始，之后在 CPU 区间和 &lt;strong&gt;I/O 区间&lt;/strong&gt; 交换。&lt;/li&gt;
&lt;li&gt;CPU 区间的长度随进程和计算机的不同而变化，通常具有大量短 CPU 区间和少量长 CPU 区间。I/O &lt;strong&gt;约束（bound）&lt;/strong&gt; 程序具有很多短 CPU 区间，CPU 约束程序具有更多的长 CPU 区间。&lt;/li&gt;
&lt;li&gt;每当 CPU 空闲时，操作系统必须从就绪队列中选择一个能够执行的进程并为之分配 CPU。进程选择由 &lt;strong&gt;短期调度程序&lt;/strong&gt; 或 CPU 调度程序执行。就绪队列不一定是先进先出（FIFO）队列，也可以被实现为优先队列、树、无序链表等。队列中的记录通常为进程控制块（PCB）。&lt;/li&gt;
&lt;li&gt;在下面四种情况中，CPU 调度需要做出决策：&lt;ul&gt;
&lt;li&gt;某个进程从运行状态切换到等待状态（如等待 I/O 或调用 wait 等待子进程）&lt;/li&gt;
&lt;li&gt;某个进程终止&lt;/li&gt;
&lt;li&gt;某个进程从运行状态切换到就绪状态（如出现中断）&lt;/li&gt;
&lt;li&gt;某个进程从等待状态切换到就绪状态（如 I/O 完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在上面四种情况中，如果调度程序只在前两种情况发生时运行，则调度方案是 &lt;strong&gt;非抢占（nonpreemptive）调度&lt;/strong&gt; ，否则该调度方案是 &lt;strong&gt;抢占（preemptive）调度&lt;/strong&gt; 。简单的说，非抢占调度指，一旦 CPU 被分配给一个进程，除非该进程终止或者切换到了等待状态，否则该进程不会释放分配的 CPU 资源，这部分 CPU 资源也无法被分配给其它进程；抢占调度指，分配给一个进程的 CPU 资源可能在该进程运行期间被重新分配给其他进程，此时这部分资源所属的原来的进程会被切换到就绪状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分派程序（dispatcher）&lt;/strong&gt; 是一个用来将 CPU 控制权交付给由短期调度程序选择出的要执行的进程的模块。每次进程切换时都会调用分派程序，它应当尽可能快。分派程序停止一个进程并启动另一个要花费的时间称为 &lt;strong&gt;分派延迟（dispatch latency）&lt;/strong&gt; 。它的功能包括：&lt;ul&gt;
&lt;li&gt;切换上下文&lt;/li&gt;
&lt;li&gt;切换到用户模式&lt;/li&gt;
&lt;li&gt;跳转到用户程序的合适位置，以重新启动程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;调度算法&quot;&gt;&lt;a href=&quot;#调度算法&quot; class=&quot;headerlink&quot; title=&quot;调度算法&quot;&gt;&lt;/a&gt;调度算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;不同的 CPU 调度算法依据不同的属性来选择进程，可通过以下准则衡量调度算法的特点和优势：&lt;ul&gt;
&lt;li&gt;CPU 利用率（utilization）：调度算法应使 CPU 尽可能忙，40%（轻负荷）~90%（重负荷）&lt;/li&gt;
&lt;li&gt;吞吐量（throughput）：一个时间单元内所完成的进程的数量，对于长、短进程，吞吐量也有所不同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;周转时间（turnaround time）&lt;/strong&gt; ：一个特定进程 &lt;strong&gt;从进程提交到进程完成所需的时间&lt;/strong&gt; ，该时间为所有时间段之和，包括等待载入内存、在就绪队列中等待、在 CPU 上执行和 I/O 等待时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待时间（waiting time）&lt;/strong&gt; ：进程在 &lt;strong&gt;就绪队列&lt;/strong&gt; 中等待所花费的时间之和&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应时间（response time）&lt;/strong&gt; ：对交互系统而言需要考虑响应时间，该准则指的是从提交请求到产生第一响应的时间（开始响应所需要的时间，而不是输出响应所需要的时间）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要使 CPU 利用率和吞吐量最大化，而周转时间、等待时间和响应时间最小化。多数情况下需要优化平均值，少数情况需要优化最小值或最大值。例如对于分时系统，为保证所有用户得到更好服务，需要尽可能使最大响应时间最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;先到先服务&quot;&gt;&lt;a href=&quot;#先到先服务&quot; class=&quot;headerlink&quot; title=&quot;先到先服务&quot;&gt;&lt;/a&gt;先到先服务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最简单的 CPU 调度算法是 &lt;strong&gt;先到先服务（first-come，first-served，FCFS）&lt;/strong&gt; 调度算法：先请求 CPU 的进程先分配到 CPU，该算法可用 FIFO 队列实现，且平均等待时间通常较长。&lt;/li&gt;
&lt;li&gt;当系统中存在一个 CPU 约束进程和多个 I/O 约束进程时，可能出现 CPU 约束进程占用 CPU，同时其他进程处理完 I/O 请求并在就绪队列中等待，此时 I/O 设备空闲。当 CPU 约束进程结束、转移到 I/O 区间后，这些 I/O 约束进程很快会执行完计算任务（仅有很短的 CPU 区间）并移回 I/O 区间，此时 CPU 空闲。之后该状态会反复，即多个进程等待一个长进程释放 CPU，此现象称为 &lt;strong&gt;护航效果（convoy effect）&lt;/strong&gt; 。这将导致 CPU 和设备利用率变得更低。&lt;/li&gt;
&lt;li&gt;FCFS 调度时非抢占的，因此不适合分时系统，允许一个进程保持过长的 CPU 时间是非常严重的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;最短作业优先&quot;&gt;&lt;a href=&quot;#最短作业优先&quot; class=&quot;headerlink&quot; title=&quot;最短作业优先&quot;&gt;&lt;/a&gt;最短作业优先&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最短作业优先（shortest-job-first，SJF）&lt;/strong&gt; 调度算法：当 CPU 空闲时，调度程序选择需要 CPU 区间最短的进程执行，如果有多个进程的下一次 CPU 区间长度相同，则在这些进程间使用 FCFS。即，先比较需要的 CPU 区间长度，长度越短优先级越高，长度相同时，到达时间越早优先级越高。&lt;/li&gt;
&lt;li&gt;SJF 调度算法可证明为 &lt;em&gt;最佳&lt;/em&gt; 的，对于给定的一组进程， &lt;strong&gt;SJF 算法的平均等待时间最小&lt;/strong&gt; 。这一点的证明可以考虑贪心算法。&lt;/li&gt;
&lt;li&gt;因为无法获知进程下个 CPU 区间的长度，一种替代方法是近似 SJF 调度，即通过先验长度 &lt;em&gt;预测&lt;/em&gt; 下一个 CPU 区间长度。我们认为，下一个 CPU 区间长度与此前的相似，可视作此前 CPU 区间测量长度的 &lt;strong&gt;指数平均（exponential average）&lt;/strong&gt; ：设 &lt;code&gt;t_n&lt;/code&gt; 为某进程第 n 个 CPU 区间的长度，则该进程下一个 CPU 区间的预测值 &lt;code&gt;τ_n+1 = αt_n + (1-α)τ_n&lt;/code&gt;，这里 &lt;code&gt;0 ≤ α ≤ 1&lt;/code&gt;。&lt;code&gt;τ_n&lt;/code&gt;代表着过去的历史，而 &lt;code&gt;t_n&lt;/code&gt; 为最近的信息，参数 &lt;code&gt;α&lt;/code&gt; 控制了最近和过去历史在预测中的相对加权。&lt;/li&gt;
&lt;li&gt;SJF 算法可能是抢占的或非抢占的。对于抢占 SJF 调度算法，当一个新进程到达就绪队列且当前正在执行的进程剩余时间比新进程所需 CPU 时间长，则新进程抢占 CPU。抢占 SJF 调度也称为 &lt;strong&gt;最短剩余时间优先（shortest-remaining-time-first）调度&lt;/strong&gt; ，与之相反的，新进程始终等待原有进程运行结束的 SJF 调度为非抢占 SJF 调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;优先级调度&quot;&gt;&lt;a href=&quot;#优先级调度&quot; class=&quot;headerlink&quot; title=&quot;优先级调度&quot;&gt;&lt;/a&gt;优先级调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SJF 实际是通用 &lt;strong&gt;优先级（priority）调度算法&lt;/strong&gt; 的一个特例。每个进程与一个优先级关联，具有最高优先级的进程会被先分配，具有相同优先级的进程按 FCFS 顺序调度。SJF 算法属于简单优先级算法，其优先级为进程预测 CPU 区间的倒数，CPU 区间长度越大则优先级越小。&lt;/li&gt;
&lt;li&gt;通常按照 &lt;em&gt;高&lt;/em&gt; 优先级和 &lt;em&gt;低&lt;/em&gt; 优先级讨论调度，优先级通常为某个固定区间的数字，如 0 ~ 7，对于不同的系统，0 可以是最高，也可以是最低优先级。&lt;/li&gt;
&lt;li&gt;优先级调度算法可以是抢占的或者非抢占的，对于抢占的优先级调度算法，具有更高优先级的新到达进程会抢占 CPU。&lt;/li&gt;
&lt;li&gt;主要问题： &lt;strong&gt;无穷阻塞（indefinite blocking）&lt;/strong&gt; 或 &lt;strong&gt;饥饿（starvation）&lt;/strong&gt; ，此调度算法会导致低优先级进程无穷等待 CPU。&lt;/li&gt;
&lt;li&gt;解决饥饿： &lt;strong&gt;老化（aging）&lt;/strong&gt; 技术可以逐渐增加在系统中等待时间过长的进程的优先级，即每过一段时间递减等待进程的优先级的值，最终低优先级的进程会成为高优先级的进程并得以执行。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;动态优先级例题&lt;/em&gt; ：假设某系统采用基于动态优先级的抢占式调度算法，且优先数越大的进程优先级越高，系统为所有新建进程赋予优先级值 0，当一个进程在就绪队列中等待 CPU 时，其优先级值变化速率为 α；当进程获得 CPU 并执行时，执行过程中优先级值变化速率为 β：&lt;ul&gt;
&lt;li&gt;若 β &amp;gt; α &amp;gt; 0，则调度算法相当于：FCFS&lt;/li&gt;
&lt;li&gt;若 α &amp;lt; β &amp;lt; 0，则调度算法相当于：FCLS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;轮转法（RR）&quot;&gt;&lt;a href=&quot;#轮转法（RR）&quot; class=&quot;headerlink&quot; title=&quot;轮转法（RR）&quot;&gt;&lt;/a&gt;轮转法（RR）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;轮转法（round-robin，RR）&lt;/strong&gt; 调度算法是 &lt;em&gt;专门为分时系统设计&lt;/em&gt; 的，类似 FCFS 调度，但强制通过抢占切换进程。该调度算法定义一个较小的 &lt;strong&gt;时间单元（time quantum）&lt;/strong&gt; 或时间切片，通常在 10 ~ 100 ms之间。就绪队列是环形的，并保持 FIFO 性质， &lt;strong&gt;新到达的进程会被添加到队列末尾&lt;/strong&gt; 。调度算法从就绪队列的头部移出进程 A，为其分配 CPU 并执行，同时也会设置一个定时器，当进程 A 执行时间到达一个时间单元时，如果进程 A 仍未结束，则将被就绪队列的下一个进程 B 抢占，进程 A 再次被加入就绪队列。注意，因为就绪队列为环形链表，队列头指针现在已经跳转到进程 B，所以进程 A 已成为整个队列的最后一个进程。&lt;/li&gt;
&lt;li&gt;使用 RR 策略调度的平均等待时间通常比较长。&lt;/li&gt;
&lt;li&gt;RR 算法的性能很大程度上依赖时间单元的大小。考虑极端情况：&lt;ul&gt;
&lt;li&gt;时间单元（时间片）非常大，则 RR 算法等价于 FCFS 算法&lt;/li&gt;
&lt;li&gt;时间单元非常小，则 RR 算法称为 &lt;strong&gt;处理器共享（processor sharing）&lt;/strong&gt; ，此时 n 个进程看起来就像运行在各自独立的 CPU 上，每个 CPU 的运行速度是真实 CPU 的 1/n。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通常希望 &lt;em&gt;时间单元比上下文切换时间长&lt;/em&gt; ，例如上下文切换时间为时间片的 10%，则约有 10% 的 CPU 时间浪费在上下文切换上。现代操作系统时间片通常为 10 ~ 100ms，而上下文切换时间通常少于 10μs。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;周转时间依赖于时间片大小&lt;/em&gt; ：若绝大多数进程能在一个时间单元内完成，则平均周转时间会改善。&lt;/li&gt;
&lt;li&gt;根据经验，80% 的 CPU 区间应当小于时间片。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;多级队列调度&quot;&gt;&lt;a href=&quot;#多级队列调度&quot; class=&quot;headerlink&quot; title=&quot;多级队列调度&quot;&gt;&lt;/a&gt;多级队列调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在进程容易分组的情况下（如划分为 &lt;strong&gt;前台（交互）&lt;/strong&gt; 进程和 &lt;strong&gt;后台（批处理）&lt;/strong&gt; 进程），可使用 &lt;strong&gt;多级队列（multilevel queue）调度算法&lt;/strong&gt; 。该算法将就绪队列划分为多个独立队列，进程按自身属性被 &lt;strong&gt;永久地&lt;/strong&gt; 分配到一个队列，每个队列使用自己的调度算法。例如，前台队列可能使用 RR 算法（分时系统），而后台队列使用 FCFS 算法。&lt;/li&gt;
&lt;li&gt;队列之间必须存在调度，通常采用 &lt;em&gt;固定优先级抢占调度&lt;/em&gt; 。例如，前台队列要比后台队列具有绝对优先级。&lt;/li&gt;
&lt;li&gt;举例：存在 4 个队列的多级队列调度算法，按优先级排列为：系统进程 &amp;gt; 交互进程 &amp;gt; 交互编辑进程 &amp;gt; 批处理进程。队列之间存在绝对优先级，只有系统进程、交互进程、交互编辑进程队列均为空时，批处理队列内的进程才可运行；在批处理队列有进程运行时，更高优先级队列进入新进程会抢占批处理进程。&lt;/li&gt;
&lt;li&gt;队列之间可划分时间片，每个队列有一定的 CPU 时间用于调度进程，例如前台队列可以将 80% 的 CPU 时间用于进程间的 RR 调度，后台队列可以有 20% 的 CPU 时间采用 FCFS 算法调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;多级反馈队列调度&quot;&gt;&lt;a href=&quot;#多级反馈队列调度&quot; class=&quot;headerlink&quot; title=&quot;多级反馈队列调度&quot;&gt;&lt;/a&gt;多级反馈队列调度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多级反馈队列（multilevel feedback queue）调度算法&lt;/strong&gt; 允许进程在队列之间移动，根据不同 CPU 区间来区分进程。&lt;/li&gt;
&lt;li&gt;如果进程使用过多 CPU 时间，则它会被转移到更低优先级队列。这种方法将 I/O 约束和交互进程留在更高优先级队列。&lt;/li&gt;
&lt;li&gt;在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列，这种老化阻止了饥饿的发生。&lt;/li&gt;
&lt;li&gt;考虑如下的多级反馈队列调度程序，它包含三个队列（0~2），优先级从高到低，只有队列 0 空，队列 1、2 内的进程才可执行，到达队列 0 的进程可以抢占队列 1、2 的进程。进入就绪队列的进程被放入队列 0，队列 0 中每个进程有 8 ms 时间片，如果该进程不能在这个时间片内完成，则它将被移动到队列 1 的尾部；当队列 0 为空时，队列 1 的头部进程会得到一个 16 ms 的时间片，若该进程不能在此时间片内完成，则将被抢占并放置到队列 2 的尾部。&lt;/li&gt;
&lt;li&gt;多级反馈队列调度程序由以下参数定义：&lt;ul&gt;
&lt;li&gt;队列数量&lt;/li&gt;
&lt;li&gt;每个队列各自的调度算法&lt;/li&gt;
&lt;li&gt;何时升级到更高优先级队列&lt;/li&gt;
&lt;li&gt;何时降级到更低优先级队列&lt;/li&gt;
&lt;li&gt;进程在需要服务时应当进入哪个队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多级反馈调度程序是最通用的 CPU 调度算法，但也最复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;高响应比优先（补充）&quot;&gt;&lt;a href=&quot;#高响应比优先（补充）&quot; class=&quot;headerlink&quot; title=&quot;高响应比优先（补充）&quot;&gt;&lt;/a&gt;高响应比优先（补充）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高响应比优先（highest response-ratio next，HRRN）算法&lt;/strong&gt; ：非抢占调度，响应比定义为 &lt;code&gt;R = (W+T)/T = 1+W/T&lt;/code&gt;，其中 &lt;code&gt;W&lt;/code&gt; 是某个进程在就绪队列中的等待时间，&lt;code&gt;T&lt;/code&gt; 是该进程的 CPU 区间长度。&lt;/li&gt;
&lt;li&gt;具有最高响应比的进程会被调度。HRRN 算法同时考虑了等待时间和 CPU 区间。&lt;/li&gt;
&lt;li&gt;缺陷：为每个进程计算响应比需要消耗系统资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;多处理器调度&quot;&gt;&lt;a href=&quot;#多处理器调度&quot; class=&quot;headerlink&quot; title=&quot;多处理器调度&quot;&gt;&lt;/a&gt;多处理器调度&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;存在多个 CPU 使 &lt;strong&gt;负载分配（load sharing）&lt;/strong&gt; 成为可能，多处理器调度只考虑处理器同构的系统，并可以将任何处理器用于任何队列内的任何进程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非对称多处理（asymmetric multiprocessing）&lt;/strong&gt; ：使一个处理器（主服务器）处理所有的调度决定、I/O处理以及其他系统活动，其它处理器只执行用户代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称多处理（symmetric multiprocessing，SMP）&lt;/strong&gt; ：每个处理器自我调度，所有进程可能处于一个共同的就绪队列，或每个处理器拥有自己的私有就绪队列。调度通过每个处理器检查共同就绪队列并选择一个进程执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理器亲和性（processor affinity）&lt;/strong&gt; ：多数 SMP 系统试图避免将进程从一个处理器移动到另一个处理器，而是努力让一个进程在同一个处理器上运行。一个操作系统使用策略使一个进程保持在同一个处理器上运行，但不能做任何保证时，称为 &lt;strong&gt;软亲和性（soft affinity）&lt;/strong&gt; ；有的操作系统，如 Linux，提供一个支持 &lt;strong&gt;硬亲和性（hard affinity）&lt;/strong&gt; 的系统调用保证了进程无法转移到其它处理器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡（load balancing）&lt;/strong&gt; 保证了所有处理器的工作负载平衡以完全利用多处理器的优点，它仅在每个 CPU 有私有就绪队列的情况下才有必要。它和处理器的亲和性相悖。有两种方法可实现：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推送迁移（push migration）&lt;/strong&gt; ：一个特定的进程间歇性的检查每个处理器的负载，假如当前夫在不均衡，则将过载处理器上进程推送到空闲处理器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拉取迁移（pull migration）&lt;/strong&gt; ：一个空闲处理器从一个忙处理器拉取一个处于等待状态的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/22/os-concepts-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（二）：进程与线程&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/24/os-concepts-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（四）：进程互斥&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/23/os-concepts-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/23/os-concepts-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/23/os-concepts-3/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第五章（CPU 进程调度），内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>顶点云（应用）服务器逻辑实现</title>
    <link href="http://forec.github.io/2016/11/23/zenith-cloud-6/"/>
    <id>http://forec.github.io/2016/11/23/zenith-cloud-6/</id>
    <published>2016-11-23T10:42:08.000Z</published>
    <updated>2016-12-23T17:33:01.791Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;分析、设计云存储服务器的执行逻辑，包括用户验证登录、活动连接加入与释放、代理操作等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;服务器结构分析&quot;&gt;&lt;a href=&quot;#服务器结构分析&quot; class=&quot;headerlink&quot; title=&quot;服务器结构分析&quot;&gt;&lt;/a&gt;服务器结构分析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;服务器可按初始化、监听、fork 出线程处理用户请求并继续监听流程处理。在对用户请求新建分支处理时，按照此前 &lt;a href=&quot;http://blog.forec.cn/2016/11/13/zenith-cloud-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;认证、传输协议设计&lt;/a&gt; 设计的登录、传输线程接入流程处理。&lt;/li&gt;
&lt;li&gt;服务器应当维护一个主要的监听器，一个已登录用户列表以及对数据库操作的接口，其数据结构如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Server &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    listener      net.Listener&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loginUserList []cs.User&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    db            *sql.DB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;服务器应当封装如下方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) InitDB() &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// 初始化数据库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) BroadCastToAll(message &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;// 向全体用户广播消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) BroadCast(u cs.User, message &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// 向指定用户发送消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) CheckBroadCast()      &lt;span class=&quot;comment&quot;&gt;// 用户间通信检查（负责用户之间的短时延通讯）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) AddUser(u cs.User)    &lt;span class=&quot;comment&quot;&gt;// 向在线列表添加用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) RemoveUser(u cs.User) &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// 从在线列表删除用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) Login(t trans.Transmitable) (cs.User, &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;)    &lt;span class=&quot;comment&quot;&gt;// 授权用户登录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) Communicate(conn net.Conn, level &lt;span class=&quot;typename&quot;&gt;uint8&lt;/span&gt;)       &lt;span class=&quot;comment&quot;&gt;// 处理一个接入的未授权请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) Run(ip &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;, port &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;, level &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;)           &lt;span class=&quot;comment&quot;&gt;// 监听指定地址并运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;在工程目录下新建 &lt;code&gt;server&lt;/code&gt; 目录，要编写的模块名为 &lt;code&gt;server&lt;/code&gt;。在该目录下创建文件 &lt;code&gt;server.go&lt;/code&gt;， 以下代码均在该文件中编辑。&lt;/li&gt;
&lt;li&gt;我们的代码中使用到的包通过如下代码导入：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    auth &lt;span class=&quot;string&quot;&gt;&quot;zenith-cloud/authenticate&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conf &lt;span class=&quot;string&quot;&gt;&quot;zenith-cloud/config&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cs &lt;span class=&quot;string&quot;&gt;&quot;zenith-cloud/cstruct&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trans &lt;span class=&quot;string&quot;&gt;&quot;zenith-cloud/transmit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;database/sql&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ &lt;span class=&quot;string&quot;&gt;&quot;github.com/mattn/go-sqlite3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;net&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;strings&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据 &lt;a href=&quot;http://blog.forec.cn/2016/11/12/zenith-cloud-0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;此前对数据库的设计&lt;/a&gt;，我们需要在程序运行过程中维护五个表记录，在程序运行前应当对数据库和对应表的存在加以检查。&lt;/li&gt;
&lt;li&gt;按照设计的数据库表实现的 &lt;code&gt;InitDB()&lt;/code&gt; 代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) InitDB() &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; err error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.db, err = sql.Open(conf.DATABASE_TYPE, conf.DATABASE_PATH)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.db.Exec(&lt;span class=&quot;string&quot;&gt;`create table cuser (uid INTEGER PRIMARY KEY AUTOINCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        username VARCHAR(64), password VARCHAR(128), created DATE)`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.db.Exec(&lt;span class=&quot;string&quot;&gt;`create table ufile (uid INTEGER PRIMARY KEY AUTOINCREMENT, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ownerid INTEGER, cfileid INTEGER, path VARCHAR(256), perlink VARCHAR(128), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        created DATE, shared INTEGER, downloaded INTEGER, filename VARCHAR(128),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        private BOOLEAN, linkpass VARCHAR(4)), isdir BOOLEAN`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.db.Exec(&lt;span class=&quot;string&quot;&gt;`create table cfile (uid INTEGER PRIMARY KEY AUTOINCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        md5 VARCHAR(32), size INTEGER, ref INTEGER, created DATE)`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.db.Exec(&lt;span class=&quot;string&quot;&gt;`create table cmessages (mesid INTEGER PRIMARY KEY AUTOINCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        targetid INTEGER, sendid INTEGER, message VARCHAR(512), created DATE)`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.db.Exec(&lt;span class=&quot;string&quot;&gt;`crete table coperations (oprid INTEGER PRIMARY KEY AUTOINCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        deletedUFileId INTEGER, deletedUFileName VARCHAR(128), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        deletedUFilePath VARCHAR(256), relatedCFileId INTEGER, time DATE)`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;程序将先检查数据库是否存在，不存在则自动创建（&lt;code&gt;sql.Open&lt;/code&gt; 函数会在数据库不存在时自动创建新数据库），之后不管表记录是否存在均新建表（若已存在则不会覆盖）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;消息广播&quot;&gt;&lt;a href=&quot;#消息广播&quot; class=&quot;headerlink&quot; title=&quot;消息广播&quot;&gt;&lt;/a&gt;消息广播&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;消息广播通过每个用户客户端设置的被动监听连接传输&lt;/li&gt;
&lt;li&gt;系统向所有用户广播，只需对所有在线用户均调用 &lt;code&gt;BroadCast()&lt;/code&gt;，具体实现如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) BroadCast(u cs.User, message &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; u.GetInfos() == &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; u.GetInfos().SendBytes([]&lt;span class=&quot;typename&quot;&gt;byte&lt;/span&gt;(message))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) BroadCastToAll(message &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, u := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; s.loginUserList &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s.BroadCast(u, message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;用户之间的通讯需要服务器作为中转。然而，服务器将用户逻辑处理交予 &lt;code&gt;cuser&lt;/code&gt; 结构代理，我们希望用户 &lt;code&gt;cuser&lt;/code&gt; 结构和服务器 &lt;code&gt;server&lt;/code&gt; 结构尽可能避免耦合，因此用户不应当在自己的 &lt;code&gt;dealWithRequests()&lt;/code&gt; 逻辑中调用服务器的 &lt;code&gt;BroadCast()&lt;/code&gt; 方法；另外，用户不应该具有判断另一用户是否在线的权限，因此即使用户具有与 &lt;code&gt;BroadCast()&lt;/code&gt; 类似的方法，它也无法判断是否该立刻将待发送的消息投放给接收方。&lt;/li&gt;
&lt;li&gt;这里采取一个 naive 但是有效的方法：用户发送 &lt;code&gt;send&lt;/code&gt; 指令通讯时，要发送的消息会被存储到 &lt;code&gt;cmessage&lt;/code&gt; 表中，我们在服务器中启动一个守护线程，监视 &lt;code&gt;cmessage&lt;/code&gt; 表，并在固定时间频率时刻检查该表是否有待发送消息，如果有则将可发送的（接收方用户在线）部分消息投放给接收方，并从 &lt;code&gt;cmessage&lt;/code&gt; 表中删除投放成功的消息。我们的检查频率会比较快（如几秒一次），用户之间通讯的延迟将在可忍受范围内，毕竟我们要实现的是云存储系统而非即时通讯系统。用户结构和服务器结构保持了分离，用户也没有具有不该有的权限。&lt;/li&gt;
&lt;li&gt;用于处理用户间通讯交互的方法是 &lt;code&gt;CheckBroadCast()&lt;/code&gt;，其具体实现如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) CheckBroadCast() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chRate := time.Tick(conf.CHECK_MESSAGE_SEPERATE * time.Second)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; queryRows *sql.Rows&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; queryRow *sql.Row&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mesid, uid, messageCount &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message, created &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; err error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;-chRate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, u := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; s.loginUserList &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            queryRow = s.db.QueryRow(fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;`select count (*) from cmessages where&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                targetid=%d`&lt;/span&gt;, u.GetId()))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; queryRow == &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            err = queryRow.Scan(&amp;amp;messageCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            id_list := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, messageCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            queryRows, err = s.db.Query(fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;`select mesid, sendid, message, created&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 from cmessages where targetid=%d`&lt;/span&gt;, u.GetId()))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;query error: &quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; queryRows.Next() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                err = queryRows.Scan(&amp;amp;mesid, &amp;amp;uid, &amp;amp;message, &amp;amp;created)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;scan error: &quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; s.BroadCast(u, fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;&quot;%d%s%s%s%s&quot;&lt;/span&gt;, uid, conf.SEPERATER, message,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    conf.SEPERATER, created)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    id_list = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(id_list, mesid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, id := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; id_list &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                _, err = s.db.Exec(fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;`delete from cmessages where mesid=%d`&lt;/span&gt;, id))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;delete error: &quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;运行&quot;&gt;&lt;a href=&quot;#运行&quot; class=&quot;headerlink&quot; title=&quot;运行&quot;&gt;&lt;/a&gt;运行&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们将从上向下分析服务器的运行逻辑&lt;/li&gt;
&lt;li&gt;服务器应当对指定端口监听并能够对介入请求创建一个新协程处理：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) Run(ip &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;, port &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;, level &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !trans.IsIpValid(ip) || !trans.IsPortValid(port) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; err error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.listener, err = net.Listen(&lt;span class=&quot;string&quot;&gt;&quot;tcp&quot;&lt;/span&gt;, fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;&quot;%s:%d&quot;&lt;/span&gt;, ip, port))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;test server starting with an error, break down...&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; s.listener.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.loginUserList = &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;([]cs.User, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, conf.START_USER_LIST)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sconn, err := s.listener.Accept()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Error accepting&quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Rececive connection request from&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sconn.RemoteAddr().String())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; s.Communicate(sconn, &lt;span class=&quot;typename&quot;&gt;uint8&lt;/span&gt;(level))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;在运行开始时，还应当对在线用户列表做初始化，并将服务器放置在 &lt;code&gt;for&lt;/code&gt; 循环中无线监听。当有请求接入，服务器创建一个新的协程来处理请求。传给协程的参数是对应的连接和安全等级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;处理未授权请求&quot;&gt;&lt;a href=&quot;#处理未授权请求&quot; class=&quot;headerlink&quot; title=&quot;处理未授权请求&quot;&gt;&lt;/a&gt;处理未授权请求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Communicate&lt;/code&gt; 函数用于处理接入服务器但未经授权的请求。服务器要和对方做一定交互以确定远端身份，不合法时要即时断开腾出资源，多次不合法时也要采取防范攻击的措施。鉴于我们设计的云存储仅仅是练习，并不会投入生产中，因此暂不考虑诸如 SYN 洪水攻击等 DDOS 可能性。在后面我会展示 DDOS 攻击对我设计的云存储系统带来的打击。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Communicate&lt;/code&gt; 函数接受与远端的连接以及安全等级。它将按照此前设计的协议与远端交互：&lt;ul&gt;
&lt;li&gt;生成一个随机 token，发送给客户端&lt;/li&gt;
&lt;li&gt;客户端使用此 token 和服务器做一系列交互，并确定是否合法（login 函数）&lt;/li&gt;
&lt;li&gt;返回授权结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Communicate&lt;/code&gt; 函数的 Go 语言实现如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) Communicate(conn net.Conn, level &lt;span class=&quot;typename&quot;&gt;uint8&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; err error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s_token := auth.GenerateToken(level)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    length, err := conn.Write([]&lt;span class=&quot;typename&quot;&gt;byte&lt;/span&gt;(s_token))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;send toekn&quot;&lt;/span&gt;, &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(s_token))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; length != conf.TOKEN_LENGTH(level) ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mainT := trans.NewTransmitter(conn, conf.AUTHEN_BUFSIZE, s_token)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rc, mode := s.Login(mainT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; rc == &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; || mode == -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mainT.Destroy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !mainT.SendBytes(s_token) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; mode == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rc.SetToken(&lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(s_token))        &lt;span class=&quot;comment&quot;&gt;// 为新登录用户设置 token&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s.AddUser(rc)                       &lt;span class=&quot;comment&quot;&gt;// 加入在线用户列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rc.DealWithRequests(s.db)           &lt;span class=&quot;comment&quot;&gt;// 处理用户请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rc.Logout()                         &lt;span class=&quot;comment&quot;&gt;// 登出用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s.RemoveUser(rc)                    &lt;span class=&quot;comment&quot;&gt;// 从在线用户列表移除该用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; mode == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; mainT.SetBuflen(conf.BUFLEN) &amp;amp;&amp;amp; rc.AddTransmit(mainT) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rc.DealWithTransmission(s.db, mainT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; mode != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mainT.Destroy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;Remote client not valid&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上面的代码中，10 行以前均为服务器生成 token 并发送 token。之后，服务器生成了一个 &lt;code&gt;transmitter&lt;/code&gt; 来交给 &lt;code&gt;Login&lt;/code&gt; 函数验证该连接合法性。&lt;code&gt;Login&lt;/code&gt; 函数会返回一个指向用户的指针，以及一个 int 类型的 &lt;code&gt;code&lt;/code&gt;，&lt;code&gt;code&lt;/code&gt; 说明了验证的结果：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;code&lt;/code&gt; 为 0：用户登陆成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;code&lt;/code&gt; 为 1：用户已经登陆，当前连接是用于传输长数据流的连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;code&lt;/code&gt; 为 2：用户已经登录，当前连接是用于被动监听广播的连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;code&lt;/code&gt; 为-1：用户因为某种原因不合法（如密码不匹配，token不一致，数据库出错等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DealWithRequests()&lt;/code&gt; 函数在之前已经介绍过一次，用来代理用户处理请求。该函数内部是一个 &lt;code&gt;for&lt;/code&gt; 循环，不断监听用户发送的命令，当用户选择退出时才会跳出循环。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Login&lt;/code&gt; 函数完成了 &lt;code&gt;Communicate&lt;/code&gt; 函数验证连接是否合法的任务，它的实现会比较复杂，主要难度在对各种异常的容错上。&lt;/li&gt;
&lt;li&gt;将用户添加到在线列表和从在线列表中删除用户的函数非常简单，代码如下，不再解释：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) AddUser(u cs.User) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.loginUserList = cs.AppendUser(s.loginUserList, u)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) RemoveUser(u cs.User) &lt;span class=&quot;typename&quot;&gt;bool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i, uc := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; s.loginUserList &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; uc == u &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            s.loginUserList = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(s.loginUserList[:i], s.loginUserList[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:]...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;校验用户身份&quot;&gt;&lt;a href=&quot;#校验用户身份&quot; class=&quot;headerlink&quot; title=&quot;校验用户身份&quot;&gt;&lt;/a&gt;校验用户身份&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们还剩下最后一部分逻辑没有实现，即对用户登录身份的验证。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Login&lt;/code&gt; 函数非常复杂，因为它需要处理用户的任何不合法行为，以及对用户的登录模式做出判断。用中文将 &lt;code&gt;Login&lt;/code&gt; 的函数流程表达如下：&lt;ol&gt;
&lt;li&gt;服务器按照协议接收用户发送的用户名和密文的头部，共 24 字节，分别对应明文长度、包长度和用户名明文长度&lt;/li&gt;
&lt;li&gt;服务器解析出包长度，并接收到完整的用户名+密码包，若接收时中断则退出&lt;/li&gt;
&lt;li&gt;服务器解析出用户名和密码，若无法解析则退出&lt;/li&gt;
&lt;li&gt;服务器检查已登录用户列表，是否存在该用户名，存在则转入活动连接判断模式，否则转 7 继续进行登录认证&lt;/li&gt;
&lt;li&gt;服务器发现用户已登录，则认为该连接用来传输长数据流，或用来做被动监听&lt;/li&gt;
&lt;li&gt;服务器对比解析出的密码和登录用户的 token 做比对，如果相同，则认为合法，否则退出。若相同，则观察该用户是否已具有 &lt;code&gt;info&lt;/code&gt; 连接（即被动监听连接），若已存在 &lt;code&gt;info&lt;/code&gt; 则认为该连接是长数据流传输，返回用户指针和模式 1；否则将该连接设置为用户的 &lt;code&gt;info&lt;/code&gt; 并返回用户指针和模式 2&lt;/li&gt;
&lt;li&gt;若第 4 步服务器检查登录用户列表并未发现该用户，则认为该用户未登录，此时在数据库中查找该用户，查找不到则退出&lt;/li&gt;
&lt;li&gt;比对查找到的用户密码和用户传输的密码是否相同，不同则退出&lt;/li&gt;
&lt;li&gt;用户密码相同，则统计用户已使用的云存储空间，并将已使用的空间设置到用户结构中&lt;/li&gt;
&lt;li&gt;返回用户指针和 0，表示用户登录成功&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Login&lt;/code&gt; 实现代码如下，大量篇幅用于 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;err&lt;/code&gt; 的处理上：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; (s *Server) Login(t trans.Transmitable) (cs.User, &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// mode : failed=-1, new=0, transmission=1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chRate := time.Tick(&lt;span class=&quot;number&quot;&gt;1e3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; recvL &lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; err error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    recvL, err = t.RecvUntil(&lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;), recvL, chRate)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;1 error:&quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    srcLength := auth.BytesToInt64(t.GetBuf()[:&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    encLength := auth.BytesToInt64(t.GetBuf()[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nmLength := auth.BytesToInt64(t.GetBuf()[&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    recvL, err = t.RecvUntil(encLength, recvL, chRate)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;2 error:&quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; nameApass []&lt;span class=&quot;typename&quot;&gt;byte&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nameApass, err = auth.AesDecode(t.GetBuf()[&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;+encLength], srcLength, t.GetBlock())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;decode error:&quot;&lt;/span&gt;, err.Error())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmt.Println(&lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(nameApass[:nmLength]), &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(nameApass[nmLength:]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pc := cs.UserIndexByName(s.loginUserList, &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(nameApass[:nmLength]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 该连接由已登陆用户建立&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; pc != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;userfined, &quot;&lt;/span&gt;, pc.GetUsername())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;pc token is &quot;&lt;/span&gt;, pc.GetToken())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; pc.GetToken() != &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(nameApass[nmLength:]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fmt.Println(&lt;span class=&quot;string&quot;&gt;&quot;token verify error! not valid!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// background message receiver&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; pc.GetInfos() == &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                pc.SetInfos(t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; pc, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// transmission&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; pc, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 该连接来自新用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    username := &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(nameApass[:nmLength])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    row := s.db.QueryRow(fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;&quot;SELECT * FROM cuser where username=&#39;%s&#39;&quot;&lt;/span&gt;, username))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; row == &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; uid &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; susername &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; spassword &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; screated &lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    err = row.Scan(&amp;amp;uid, &amp;amp;susername, &amp;amp;spassword, &amp;amp;screated)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; || spassword != strings.ToUpper(&lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(nameApass[nmLength:])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rc := cs.NewCUser(&lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;(nameApass[:nmLength]), &lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;(uid), &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; rc == &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rc.SetListener(t)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 统计用户已使用的云存储空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rows, err := s.db.Query(fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;&quot;SELECT cfileid FROM ufile where ownerid=%d&quot;&lt;/span&gt;, uid))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; rows.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; cid, size &lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; totalSize &lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; rows.Next() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        err = rows.Scan(&amp;amp;cid)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; || cid &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        row = s.db.QueryRow(fmt.Sprintf(&lt;span class=&quot;string&quot;&gt;&quot;select size from cfile where uid=%d&quot;&lt;/span&gt;, cid))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; row == &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        err = row.Scan(&amp;amp;size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;constant&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        totalSize += &lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;(size)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rc.SetUsed(&lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;(totalSize))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; rc, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上面的代码基本遵循中文描述的过程，细节方面实现可能有顺序偏差，但大体一致。注意 &lt;code&gt;Login&lt;/code&gt; 中对数据库查询出现错误的不同处理，在不影响用户正常行为逻辑的情况下，无所谓的错误可以用 &lt;code&gt;continue&lt;/code&gt; 跳过。服务器会按一定周期检查有无遗失的文件记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/zenith-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）设计与实现&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/19/zenith-cloud-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）传输、认证单元测试&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/12/03/zenith-cloud-7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顶点云（应用）用户代理&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/23/zenith-cloud-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/23/zenith-cloud-6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/23/zenith-cloud-6/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分析、设计云存储服务器的执行逻辑，包括用户验证登录、活动连接加入与释放、代理操作等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Code" scheme="http://forec.github.io/categories/Code/"/>
    
    
      <category term="Golang" scheme="http://forec.github.io/tags/Golang/"/>
    
      <category term="云存储" scheme="http://forec.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
      <category term="线程" scheme="http://forec.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（二）：进程与线程</title>
    <link href="http://forec.github.io/2016/11/22/os-concepts-2/"/>
    <id>http://forec.github.io/2016/11/22/os-concepts-2/</id>
    <published>2016-11-22T11:02:51.000Z</published>
    <updated>2016-11-27T02:22:50.646Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第三、四章的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;进程（第三章）&quot;&gt;&lt;a href=&quot;#进程（第三章）&quot; class=&quot;headerlink&quot; title=&quot;进程（第三章）&quot;&gt;&lt;/a&gt;进程（第三章）&lt;/h1&gt;&lt;h1 id=&quot;概念与调度&quot;&gt;&lt;a href=&quot;#概念与调度&quot; class=&quot;headerlink&quot; title=&quot;概念与调度&quot;&gt;&lt;/a&gt;概念与调度&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程可看作正在执行的程序，是大多数系统中的工作单元。进程除了包括程序代码（有时也称作 &lt;strong&gt;文本段&lt;/strong&gt; ），还包括用 &lt;strong&gt;程序计数器&lt;/strong&gt; 和处理器寄存器来表示的当前活动。进程通常还包括进程 &lt;strong&gt;堆栈段（stack）&lt;/strong&gt; 和 &lt;strong&gt;数据段（data section）&lt;/strong&gt; ，其中堆栈段保存临时数据如函数参数、返回地址、局部变量，数据段保存全局变量。进程还可能包括 &lt;strong&gt;堆（heap）&lt;/strong&gt; ，堆是进程运行期间动态分配的内存。&lt;/li&gt;
&lt;li&gt;进程在执行中会改变 &lt;strong&gt;状态（state）&lt;/strong&gt; ，每个进程可能处于下列状态：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建（New）&lt;/strong&gt; ：进程正在被创建&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行（Running）&lt;/strong&gt; ：进程正在被执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待（Waiting）&lt;/strong&gt; ：进程在等待某个事件发生（如 I/O 完成或接收到某个信号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪（Ready）&lt;/strong&gt; ：进程等待分配处理器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终止（Terminated）&lt;/strong&gt; ：进程完成执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一次只有 &lt;em&gt;一个进程&lt;/em&gt; 可以在 &lt;em&gt;一个处理器&lt;/em&gt; 上 &lt;em&gt;运行&lt;/em&gt; ，但可以有多个进程处于 &lt;em&gt;就绪&lt;/em&gt; 或 &lt;em&gt;等待&lt;/em&gt; 状态。进程状态转移如下图，图片根据原书内容制作。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/diagram-process-state.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;li&gt;每个进程在操作系统内部用 &lt;strong&gt;进程控制块（process control block，PCB）&lt;/strong&gt; 来表示，它包含了与一个特定进程相关的信息。每个进程控制块包含：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程状态（process state）&lt;/strong&gt; ：可为上述五种状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序计数器（program counter）&lt;/strong&gt; ：指定进程要执行的下条指令地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 寄存器&lt;/strong&gt; ：根据计算机体系结构的不同，寄存器数量、类型也不同，多数包括累加器、索引寄存器、堆栈指针、通用寄存器等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 调度信息（CPU-scheduling information）&lt;/strong&gt; ：包括进程优先级、调度队列的指针和其它调度参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理信息（memory-management information）&lt;/strong&gt; ：根据内存系统，通常包括基址、界限寄存器值、页表或段表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计信息（accounting information）&lt;/strong&gt; ：包括 CPU 时间、实际使用时间、时间界限、统计数据、作业/进程数量等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O 状态信息&lt;/strong&gt; ：包括分配给进程的 I/O 设备列表、打开的文件列表等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程调度器（process scheduler）&lt;/strong&gt; 选择一个可用的进程到 CPU 中执行。进程进入系统时会被加入到 &lt;strong&gt;作业队列（job queue）&lt;/strong&gt; 中，该队列包括系统中所有进程。保留在主存中且准备就绪等待运行的进程被保存在 &lt;strong&gt;就绪队列（ready queue）&lt;/strong&gt; 中，该队列通常用链表实现，头节点指向了链表的第一个和最后一个 PCB 块指针，每个PCB 包括指向就绪队列的下一个 PCB 的指针。有些进程向共享设备（如磁盘）发送 I/O 请求，若磁盘正忙则该进程需要等待。等待特定 I/O 设备的进程列表称为 &lt;strong&gt;设备队列（device queue）&lt;/strong&gt; ，每个设备都有自己的设备队列。&lt;/li&gt;
&lt;li&gt;新进程开始时处于就绪队列，它在就绪队列中等待直到被选中执行或 &lt;strong&gt;派遣（dispatched）&lt;/strong&gt; 。一旦进程被分配 CPU 并开始执行，可能发生以下事件。在前两种情况中，经过一定时间的等待，进程最终会从等待状态切换回就绪状态，并放回到就绪队列中。&lt;ul&gt;
&lt;li&gt;进程发出一个 I/O 请求并被放到 I/O 队列中&lt;/li&gt;
&lt;li&gt;进程创建一个新的子进程并等待其结束&lt;/li&gt;
&lt;li&gt;进程由于中断强制释放 CPU，并被放回到就绪队列中&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/process-scheduling-queue.jpg&quot; width=&quot;400px&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统从队列中选择进程的操作由 &lt;strong&gt;调度程序（scheduler）&lt;/strong&gt; 执行。在批处理系统中，进程被放到大容量存储设备（如磁盘）的缓冲池（作业池）中等待执行。 &lt;strong&gt;长期调度程序（long-term scheduler）&lt;/strong&gt; 或 &lt;strong&gt;作业调度程序（job scheduler）&lt;/strong&gt; 从缓冲池选择进程、装入内存以准备执行，而 &lt;strong&gt;短期调度程序（short-term scheduler）&lt;/strong&gt; 或 &lt;strong&gt;CPU 调度程序&lt;/strong&gt; 从准备执行的进程中选择并分配 CPU。二者的区别主要体现在 &lt;strong&gt;执行的频率不同&lt;/strong&gt; 。短期调度程序非常频繁地执行，为CPU选择新进程，如果短期调度需要 10ms 来确定执行一个运行 100ms 的进程，则 &lt;code&gt;10/(100+10) = 9%&lt;/code&gt; 的CPU时间浪费在了调度工作上；而长期调度程序执行不频繁，可能数分钟调度一次，它控制 &lt;strong&gt;多道程序设计的程度（degree of multiprogramming）&lt;/strong&gt; ，即内存中的进程数量。只有进程离开系统后才可能需要调度长期调度程序。&lt;/li&gt;
&lt;li&gt;有些系统没有/少有长期调度程序，如 UNIX 或 Windows 的分时系统通常没有长期调度程序，它们仅仅简单的将所有新进程放到内存中以供短期调度程序使用。有些系统如分时系统可能引入 &lt;strong&gt;中期调度系统（medium-term scheduler）&lt;/strong&gt; ，它可以将进程从内存（或 CPU 竞争）中移出，从而降低多道程序设计的程度。之后，这些进程可以被重新调入内存并从中断处继续执行。这种行为称为 &lt;strong&gt;交换（swapping）&lt;/strong&gt; 。有时因为内存要求的改变导致可用内存过度使用，此时便需要交换。&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/addition-medium-term-scheduling.jpg&quot; width=&quot;500px&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xktmz.com1.z0.glb.clouddn.com/swapped-state.jpg&quot; width=&quot;500px&quot;&gt;&lt;/li&gt;
&lt;li&gt;将 CPU 切换到另一个进程需要保存当前进程状态并恢复另一个进程的状态，此任务成为 &lt;strong&gt;上下文切换（context switch）&lt;/strong&gt; 。内核会将旧进程的状态保存在其 PCB 中，并装入调度后要执行的并已恢复的新进程的上下文。上下文切换的时间与硬件支持相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进程操作&quot;&gt;&lt;a href=&quot;#进程操作&quot; class=&quot;headerlink&quot; title=&quot;进程操作&quot;&gt;&lt;/a&gt;进程操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程在其执行过程中能通过创建进程系统调用（create-process system call）创建多个新进程。创建进程称为 &lt;strong&gt;父（parent）进程&lt;/strong&gt; ，被创建的新进程称为 &lt;strong&gt;子（children）进程&lt;/strong&gt; 。每个新进程可以再创建其他进程以形成 &lt;strong&gt;进程树（tree）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;多数操作系统根据一个唯一的 &lt;strong&gt;进程标识符（process identifier，pid）&lt;/strong&gt; 来识别进程，通常是整数值。&lt;/li&gt;
&lt;li&gt;一个进程创建子进程时，子进程可能通过以下方式获取资源：&lt;ul&gt;
&lt;li&gt;从操作系统直接获取资源&lt;/li&gt;
&lt;li&gt;获取父进程资源。父进程需要在子进程之间分配或共享资源，父进程可以选择和子进程分享全部资源、分享部分资源、不分享资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程创建时，除了得到各种物理和逻辑资源，初始化数据（或输入）由父进程传递给子进程。&lt;/li&gt;
&lt;li&gt;当进程创建新进程时，存在两种执行可能：&lt;ul&gt;
&lt;li&gt;父进程和子进程并发执行&lt;/li&gt;
&lt;li&gt;父进程等待，直到某个或全部子进程执行完&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新进程的地址空间有两种可能：&lt;ul&gt;
&lt;li&gt;子进程是父进程的副本，具有和父进程相同的程序和数据&lt;/li&gt;
&lt;li&gt;子进程装入另一个新程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 UNIX 中，通过 &lt;code&gt;fork()&lt;/code&gt; 系统调用创建新进程，新进程通过 &lt;strong&gt;复制原来进程的地址空间形成&lt;/strong&gt; 。两个进程（父进程、子进程）均继续执行位于系统调用 &lt;code&gt;fork()&lt;/code&gt; 之后的指令，对于子进程，系统调用 &lt;code&gt;fork()&lt;/code&gt; 返回值为 0，而父进程的返回值为子进程的 pid。&lt;/li&gt;
&lt;li&gt;在系统调用 &lt;code&gt;fork()&lt;/code&gt; 后，一个进程会使用系统调用 &lt;code&gt;exec()&lt;/code&gt; 以使用新程序取代进程内存空间并开始执行。这样两个进程可以相互通信且执行各自程序。如果父进程在子进程运行时需要等待，则采用系统调用 &lt;code&gt;wait()&lt;/code&gt; 将自己移出就绪队列来等待子进程终止。&lt;/li&gt;
&lt;li&gt;以下是 UNIX 系统一个 C 语言例程，来自原书第 92 页。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pid_t&lt;/span&gt; pid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pid = fork();     &lt;span class=&quot;comment&quot;&gt;// fork a child process&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pid &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;     &lt;span class=&quot;comment&quot;&gt;// error occurred&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pid == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;    &lt;span class=&quot;comment&quot;&gt;// child process&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        execlp(&lt;span class=&quot;string&quot;&gt;&quot;/bin/ls&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ls&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;                 &lt;span class=&quot;comment&quot;&gt;// parent process&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;以下是 Win32 API 生成一个单独进程的 C 语言例程，来自原书第 94 页。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    STARTUPINFO si;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PROCESS_INFORMATION pi;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ZeroMemory(&amp;amp;si, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(si));    &lt;span class=&quot;comment&quot;&gt;// allocate memory&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    si.cb = &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(si);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ZeroMemory(&amp;amp;pi, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(pi));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!CreateProcess(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,        &lt;span class=&quot;comment&quot;&gt;// use command line&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;C:\\WINDOWS\\system32\\mspaint.exe&quot;&lt;/span&gt;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, FALSE, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &amp;amp;si, &amp;amp;pi))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;        &lt;span class=&quot;comment&quot;&gt;// create process failed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WaitForSingleObject(pi.hProcess, INFINITE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CloseHandle(pi.hProcess);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CloseHandle(pi.hThread);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;进程终止和通信&quot;&gt;&lt;a href=&quot;#进程终止和通信&quot; class=&quot;headerlink&quot; title=&quot;进程终止和通信&quot;&gt;&lt;/a&gt;进程终止和通信&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程完成执行最后的语句并使用系统调用 &lt;code&gt;exit()&lt;/code&gt; 时进程终止，此时进程可以返回状态值（通常为整数）给父进程（通过&lt;code&gt;wait()&lt;/code&gt;获取），所有进程资源也会被操作系统是放。&lt;/li&gt;
&lt;li&gt;进程通过系统调用（如 Win32 的 &lt;code&gt;TerminateProcess()&lt;/code&gt;）可以终止另一个进程，通常只有被终止进程的父进程才能执行该操作。父进程终止子进程的原因如：&lt;ul&gt;
&lt;li&gt;子进程使用了超出其所分配的资源&lt;/li&gt;
&lt;li&gt;子进程所分配的任务已不需要&lt;/li&gt;
&lt;li&gt;父进程退出（在有的系统中，如果父进程终止，则其所有子进程也终止，此现象称为 &lt;strong&gt;级联终止（cascading termination）&lt;/strong&gt; 。而在 UNIX 中，若父进程终止，其所有子进程会以 init 进程作为父进程，因此子进程仍然有一个父进程来收集状态和执行统计。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统内并发执行的进程可以为 &lt;em&gt;独立进程&lt;/em&gt; 或 &lt;em&gt;协作进程&lt;/em&gt; 。如果一个进程不能影响其他进程，也不能被其他进程所影响，则该进程是 &lt;strong&gt;独立（independent）&lt;/strong&gt; 的，否则该进程是 &lt;strong&gt;协作（cooperating）&lt;/strong&gt; 的。进程协作的原因有很多，如：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;信息共享（information sharing）&lt;/strong&gt; ：多个用户需要同一个共享文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高运算速度（computation speedup）&lt;/strong&gt; ：要使一个特定任务快速运行，则需要将其分成子任务以并行执行，这需要计算机有多个处理单元（CPU或 I/O通道）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块化（modularity）&lt;/strong&gt; ：需要按模块化方式构造系统&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方便&lt;/strong&gt; ：单个用户可同时执行多个任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程写作需要 &lt;strong&gt;进程间通信机制（interprocess communication， IPC）&lt;/strong&gt; 来允许进程相互交换数据，其包括两种基本模式：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享内存（shared memory）&lt;/strong&gt; ：通信进程需要建立内存共享区域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息传递（massage passing）&lt;/strong&gt; ：在分布式环境中非常有用，通信进程之间必须有 &lt;strong&gt;通信线路（communication link）&lt;/strong&gt; 。对于 &lt;strong&gt;直接通信&lt;/strong&gt; ，采用对称寻址，每个进程必须明确地命名通信的接收者或发送者； &lt;strong&gt;间接通信&lt;/strong&gt; 中，通过 &lt;strong&gt;邮箱（mailboxes）&lt;/strong&gt; 或 &lt;strong&gt;端口（ports）&lt;/strong&gt; 来发送和接收消息，每个邮箱都有唯一的标识符，两个进程仅在其共享至少一个邮箱时可相互通信，一个进程可通过许多不同的邮箱和其他进程通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于使用邮箱的间接通信，通信线路有如下属性：&lt;ul&gt;
&lt;li&gt;只有在两个进程共享一个邮箱时才能建立通信线路&lt;/li&gt;
&lt;li&gt;一个线路可以与两个或更多的进程相关联&lt;/li&gt;
&lt;li&gt;两个通信进程之间可有多个不同线路，每个线路对应一个邮箱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若多个进程共享同一个邮箱，例如进程 P1、P2、P3均共享邮箱 A，进程 P1 发送一个消息到 A，进程 P2 和 P3 同时对邮箱 A 执行 &lt;code&gt;receive()&lt;/code&gt;，则结果取决于所选用地方案：&lt;ul&gt;
&lt;li&gt;允许一个线路最多只能与两个进程相关联&lt;/li&gt;
&lt;li&gt;一次最多允许一个进程执行 &lt;code&gt;receive()&lt;/code&gt; 操作&lt;/li&gt;
&lt;li&gt;允许系统随意选择一个进程接收消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由操作系统所拥有的邮箱是独立存在的，不属于某个特定的进程。创建新邮箱的进程默认为邮箱拥有者，通过系统调用，拥有权和接收特权可能传递给其他进程。&lt;/li&gt;
&lt;li&gt;消息传递可以是 &lt;strong&gt;阻塞（blocking）&lt;/strong&gt; 或者 &lt;strong&gt;非阻塞（nonblocking）&lt;/strong&gt; ，也称为 &lt;strong&gt;同步（synchronous）&lt;/strong&gt; 或 &lt;strong&gt;异步（asynchronous）&lt;/strong&gt; 。&lt;ul&gt;
&lt;li&gt;阻塞发送：发送进程阻塞直到消息被接收进程或邮箱接收&lt;/li&gt;
&lt;li&gt;非阻塞发送：发送进程可直接发送消息并继续操作&lt;/li&gt;
&lt;li&gt;阻塞接收：接收者阻塞直到有可用消息&lt;/li&gt;
&lt;li&gt;非阻塞接收：接收者可以直接收到一个有效消息或空消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IPC 系统示例，Windows XP：Windows XP 的消息传递工具称为 &lt;strong&gt;本地过程调用（local procedure call，LPC）&lt;/strong&gt; 工具，在位于同一机器的两个进程之间通信。Windows XP 使用了端口对象以建立、维持两个进程之间的链接。通信工作如下，如果客户端要发送更大的消息，则可通过 &lt;strong&gt;区段对象（section object）&lt;/strong&gt; 来构建共享内存传递消息。注意，LPC 不是 Win32 API 的一部分，所以对应用程序不可见。&lt;ul&gt;
&lt;li&gt;客户端打开系统的连接端口对象句柄&lt;/li&gt;
&lt;li&gt;客户端发送连接请求&lt;/li&gt;
&lt;li&gt;服务器创建两个私有通信端口，并返回其中之一的句柄给客户端&lt;/li&gt;
&lt;li&gt;客户端和服务器使用相应端口句柄以发送消息或回调，并等待回答&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例程，C 程序调用 POSIX 系统下的共享内存 API，来自原书（英文版）第 104 页。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;sys/shm.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; segment_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *shared_memory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// the size(bytes) of shared memory segment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size = &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt;;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// allocate a shared memory segment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    segment_id = shmget(IPC_PRIVATE, size, S_IRUSR | S_IWUSR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// attach the shared memory segment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shared_memory = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *) shmat(segment_id, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// write a message to the shared memory segment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;sprintf&lt;/span&gt;(shared_memory, &lt;span class=&quot;string&quot;&gt;&quot;Hi there!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// print out the string from shared memory&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;*%s\n&quot;&lt;/span&gt;, shared_memory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// detach the shared memory segment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shmdt(shared_memory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// remove the shared memory segment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shmctl(segment_id, IPC_RMID, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;管道&quot;&gt;&lt;a href=&quot;#管道&quot; class=&quot;headerlink&quot; title=&quot;管道&quot;&gt;&lt;/a&gt;管道&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管道（pipe）&lt;/strong&gt; 是一条在进程间以字节流方式传送数据的通信通道，由OS核心的缓冲区（通常几十KB）来实现，为单向。&lt;/li&gt;
&lt;li&gt;管道常用于命令行所指定的输入输出重定向和管道命令，使用前要建立相应的管道。管道逻辑上可以看作管道文件，物理上则是由文件系统的高速缓存区构成。&lt;/li&gt;
&lt;li&gt;管道分为 &lt;em&gt;有名管道&lt;/em&gt; 和 &lt;em&gt;无名管道&lt;/em&gt; ，按先进先出（FIFO）的方式传送消息，且只能单向传送消息。&lt;/li&gt;
&lt;li&gt;管道的发送和接受可使用如下操作：&lt;ul&gt;
&lt;li&gt;发送进程利用文件系统的系统调用 &lt;code&gt;write(fd[1], buf, size)&lt;/code&gt; 把 buf 中长度为 size 字符的消息送入管道入口 &lt;code&gt;fd[1]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;接收进程利用文件系统的系统调用 &lt;code&gt;read(fd[0], buf, size)&lt;/code&gt;从管道出口 &lt;code&gt;fd[0]&lt;/code&gt; 读出 size 字符的消息放入 buf 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管道应用例程，来自李文生老师的操作系统幻灯片。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid,fd[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;], s[&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pipe(fd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((pid = fork()) == -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pid==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;sprintf&lt;/span&gt;(buf, &lt;span class=&quot;string&quot;&gt;&quot;this is an example\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        write(fd[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],buf,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        read(fd[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], s, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s&quot;&lt;/span&gt;,s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;线程（第四章）&quot;&gt;&lt;a href=&quot;#线程（第四章）&quot; class=&quot;headerlink&quot; title=&quot;线程（第四章）&quot;&gt;&lt;/a&gt;线程（第四章）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;线程是 CPU 使用的基本单元，由线程ID、程序计数器、寄存器集合和栈组成。它和 &lt;strong&gt;属于同一进程&lt;/strong&gt; 的其他线程共享代码段、数据段和其他操作系统资源（打开文件、信号等）。传统 &lt;strong&gt;重量级（heavyweight）&lt;/strong&gt; 的进程只有单个控制线程，若进程有多个控制线程，则可同时做多个任务。&lt;/li&gt;
&lt;li&gt;多线程编程优点：&lt;ul&gt;
&lt;li&gt;响应度高&lt;/li&gt;
&lt;li&gt;资源共享：线程默认共享它们所属进程的资源和内存，它允许一个应用程序在同一地址空间有多个不同的活动线程&lt;/li&gt;
&lt;li&gt;经济：线程创建所需的内存和资源较进程少很多&lt;/li&gt;
&lt;li&gt;多处理器体系结构的利用：每个进程能并行运行在不同处理器上，加强了并发功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;多线程模型&quot;&gt;&lt;a href=&quot;#多线程模型&quot; class=&quot;headerlink&quot; title=&quot;多线程模型&quot;&gt;&lt;/a&gt;多线程模型&lt;/h2&gt;&lt;p&gt;有两种方法提供线程支持：用户层的 &lt;strong&gt;用户线程（user threads）&lt;/strong&gt; 和内核层的 &lt;strong&gt;内核线程（kernel threads）&lt;/strong&gt; 。用户线程受到内核的 &lt;em&gt;支持&lt;/em&gt; ，但不需内核管理；内核线程 &lt;em&gt;由操作系统直接支持和管理&lt;/em&gt; 。当代所有操作系统均支持内核线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多对一模型（Many-to-One）&lt;/strong&gt; ：将多个用户级线程映射到一个内核线程。 &lt;em&gt;线程管理是由线程库在用户空间进行的&lt;/em&gt; ，效率较高； &lt;strong&gt;若一个线程执行了阻塞系统调用，则整个进程都会阻塞&lt;/strong&gt; ，因为任一时刻只有一个线程能访问内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一对一模型（One-to-One）&lt;/strong&gt; ：将每个用户线程映射到一个内核线程，该模型在一个线程执行系统调用时，能允许另一个线程继续执行，所以它提供了更好的并发性能；缺点在于每个用户线程需要创建一个对应的内核线程，因此限制了系统支持的线程数量。Linux 和 Windows 系列系统实现了一对一模型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多对多模型（Many-to-Many）&lt;/strong&gt; ：复用了许多用户线程到同样数量或者更小数量的内核线程上，开发人员可创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。一个流行的多对多模型的变种允许将一个用户线程绑定到某个内核线程上，这个变种有时称为 &lt;strong&gt;二级模型（two0level model）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;线程库&quot;&gt;&lt;a href=&quot;#线程库&quot; class=&quot;headerlink&quot; title=&quot;线程库&quot;&gt;&lt;/a&gt;线程库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程库（thread library）&lt;/strong&gt; 为程序员提供创建和管理线程的 API。有两种方法来实现：&lt;ul&gt;
&lt;li&gt;在用户空间提供一个没有内核支持的库，此库的所有代码和数据结构均存在用户空间中，调用库中的一个函数只是导致用户空间中一个本地函数的调用，而非系统调用&lt;/li&gt;
&lt;li&gt;执行一个由操作系统直接支持的内核级的库，库的代码和数据结构存储在内核空间中，调用库中的一个 API 会导致对内核的系统调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目前主要的三种线程库有：POSIX Pthread、Win32 和 Java。&lt;/li&gt;
&lt;li&gt;Pthread 创建、执行线程的一个 C程序样例如下，例程来自原书（英文版）第 133 页。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;                      &lt;span class=&quot;comment&quot;&gt;// shared by thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;runner&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *param)&lt;/span&gt;&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_t&lt;/span&gt; tid;        &lt;span class=&quot;comment&quot;&gt;// pid&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_attr_t&lt;/span&gt; attr;  &lt;span class=&quot;comment&quot;&gt;// set of thread attributes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (argc != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (atoi(argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// initialize the default attributes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_attr_init(&amp;amp;attr);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// create the thread&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_create(&amp;amp;tid, &amp;amp;attr, runner, argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// wait for the thread to exit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_join(tid, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;sum = %d\n&quot;&lt;/span&gt;, sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;runner&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *param)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, upper = atoi(param);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= upper; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sum += i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_exit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Win32 线程库创建线程的例程如下，来自原书（英文版）第 135 页。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DWORD sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;DWORD WINAPI &lt;span class=&quot;title&quot;&gt;Summation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(LPVOID Param)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DWORD Upper = *(DWORD*)Param;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (DWORD i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt;= Upper; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Sum += i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DWORD ThreadId;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HANDLE ThreadHandle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Param;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (argc != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((Param = atoi(argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ThreadHandle = CreateHandle(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,       &lt;span class=&quot;comment&quot;&gt;// default security attributes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,          &lt;span class=&quot;comment&quot;&gt;// default stack size&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Summation,  &lt;span class=&quot;comment&quot;&gt;// thread function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;Param,     &lt;span class=&quot;comment&quot;&gt;// parameter to thread function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,          &lt;span class=&quot;comment&quot;&gt;// default creation flags&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;amp;ThreadId); &lt;span class=&quot;comment&quot;&gt;// returns the thread identifier&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ThreadHandle != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        WaitForSingleObject(ThreadHandle, INFINITE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CloseHandle(ThreadHandle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;sum = %d\n&quot;&lt;/span&gt;, Sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;多线程问题&quot;&gt;&lt;a href=&quot;#多线程问题&quot; class=&quot;headerlink&quot; title=&quot;多线程问题&quot;&gt;&lt;/a&gt;多线程问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在多线程程序中，&lt;code&gt;fork()&lt;/code&gt; 和 &lt;code&gt;exec()&lt;/code&gt; 的语义有所改变：有的 UNIX 系统存在两种形式的 &lt;code&gt;fork()&lt;/code&gt;，如果程序中一个线程调用 &lt;code&gt;fork()&lt;/code&gt;，其中一种情况新进程会复制所有线程，另一种则只复制调用系统调用 &lt;code&gt;fork()&lt;/code&gt; 的线程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt; 工作方式不变， &lt;strong&gt;如果一个线程调用了系统调用 &lt;code&gt;exec()&lt;/code&gt;，则&lt;code&gt;exec()&lt;/code&gt;参数指定的程序会替换整个进程，包括所有线程&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt; 的两种工作方式和应用程序有关：如果调用 &lt;code&gt;fork()&lt;/code&gt; 后立刻调用 &lt;code&gt;exec()&lt;/code&gt;，则没必要复制所有线程，因为 &lt;code&gt;exec()&lt;/code&gt; 会替换整个进程，此时应当只复制调用的线程，否则应当复制所有线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程取消（thread cancellation）&lt;/strong&gt; 指线程完成之前终止线程任务，要取消的线程通常称为 &lt;strong&gt;目标线程（target thread）&lt;/strong&gt; ，目标线程的取消可在如下两种情况下发生：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;异步取消（asynchronous cancellation）&lt;/strong&gt; ：一个线程立刻终止目标线程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延迟取消（deferred cancellation）&lt;/strong&gt; ：目标线程不断检查它是否应当终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果资源已分配给要取消的线程或要取消的线程正在更新与其他线程所共享的数据，则取消会非常麻烦。采用延迟取消时，只有当目标线程检查它在安全的点时才会取消，Pthread 称这些点为 &lt;strong&gt;取消点（cancellation point）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;信号处理： &lt;strong&gt;信号（signal）&lt;/strong&gt; 在 UNIX中用来通知进程某个特定事件发生，根据需要通知信号的来源和事件理由，无论信号为异步还是同步，它们都具有同样的模式：&lt;ul&gt;
&lt;li&gt;信号由特定事件产生&lt;/li&gt;
&lt;li&gt;产生信号要发送给进程&lt;/li&gt;
&lt;li&gt;信号一旦被发送就必须被处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步信号的例子包括访问违例内存或者除 0，同步信号发送到执行操作而产生信号的同一进程；如果一个信号由运行进程之外的事件产生，则进程异步接收这一信号，如使用Ctrl + C 终止或定时器到期。异步信号通常被发送到另一个进程。每个信号可能由两种可能的处理程序中的一种来处理：&lt;ul&gt;
&lt;li&gt;默认信号处理程序&lt;/li&gt;
&lt;li&gt;用户定义的信号处理程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Windows 并不提供对信号的支持，但它们能通过 &lt;strong&gt;异步过程调用（asynchronous procedure call，APC）&lt;/strong&gt; 来模拟。APC 工具允许用户线程指定一个函数以便在用户线程受到特定事件通知时能被调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;线程池和特定数据&quot;&gt;&lt;a href=&quot;#线程池和特定数据&quot; class=&quot;headerlink&quot; title=&quot;线程池和特定数据&quot;&gt;&lt;/a&gt;线程池和特定数据&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果允许所有并发请求都通过新线程来处理，则没法限制在系统中并发执行的线程的数量。可使用 &lt;strong&gt;线程池（thread pool）&lt;/strong&gt; 解决：在进程开始时创建一定数量的线程，并放入池中等待工作，当服务器收到请求则唤醒池中一个线程（如果有线程可用），并将要处理的请求传递给该线程；一旦一个线程完成了服务，它会返回池中等待工作。&lt;/li&gt;
&lt;li&gt;线程池优点主要有：&lt;ul&gt;
&lt;li&gt;使用现有线程处理请求比等待新创建线程更快&lt;/li&gt;
&lt;li&gt;线程池限制了在任何时候可以使用的线程数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有些情况下线程自己需要维持一定数据的副本，这类数据称为 &lt;strong&gt;线程特定数据（thread-specific data）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/22/os-concepts-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（一）：概念导读&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/23/os-concepts-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（三）：CPU 调度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/22/os-concepts-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/22/os-concepts-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/22/os-concepts-2/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版第三、四章的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（一）：概念导读</title>
    <link href="http://forec.github.io/2016/11/22/os-concepts-1/"/>
    <id>http://forec.github.io/2016/11/22/os-concepts-1/</id>
    <published>2016-11-22T02:07:44.000Z</published>
    <updated>2016-11-24T13:06:12.510Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版前两章的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;绪论（第一章）&quot;&gt;&lt;a href=&quot;#绪论（第一章）&quot; class=&quot;headerlink&quot; title=&quot;绪论（第一章）&quot;&gt;&lt;/a&gt;绪论（第一章）&lt;/h1&gt;&lt;h2 id=&quot;定义操作系统&quot;&gt;&lt;a href=&quot;#定义操作系统&quot; class=&quot;headerlink&quot; title=&quot;定义操作系统&quot;&gt;&lt;/a&gt;定义操作系统&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作系统（operating system）&lt;/strong&gt; 是管理计算机硬件的一个程序，它同时作为用户和硬件的中间层，为应用程序提供了基础。&lt;/li&gt;
&lt;li&gt;一个计算机系统可被大致划分为四个部件： &lt;em&gt;硬件（hardware）&lt;/em&gt; 、 &lt;em&gt;操作系统&lt;/em&gt; 、 &lt;em&gt;应用程序（application programs）&lt;/em&gt; 、 &lt;em&gt;用户（users）&lt;/em&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件（hardware）&lt;/strong&gt; 包括： &lt;strong&gt;中央处理器（central processing unit）&lt;/strong&gt; 、 &lt;strong&gt;存储器（memory）&lt;/strong&gt; 和 &lt;strong&gt;输入输出（I/O）设备&lt;/strong&gt; 。操作系统控制并协调多个用户的多道程序。&lt;/li&gt;
&lt;li&gt;从计算机的视角看，操作系统类似一个 &lt;strong&gt;资源管理器（resource allocator）&lt;/strong&gt; ，它扮演了硬件资源管理者的角色。另一个略微有所不同的角度是，操作系统是一个控制程序，这个 &lt;strong&gt;控制程序（control program）&lt;/strong&gt; 管理用户程序的执行以防止错误的发生和对计算机不合法的使用。&lt;/li&gt;
&lt;li&gt;计算机系统最基本的目的是执行用户程序，并让用户问题的解决变得更容易。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;操作系统组织&quot;&gt;&lt;a href=&quot;#操作系统组织&quot; class=&quot;headerlink&quot; title=&quot;操作系统组织&quot;&gt;&lt;/a&gt;操作系统组织&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机用于启动的初始化程序被称作 &lt;strong&gt;引导程序（bootstrap program）&lt;/strong&gt; ，它被存储在只读存储器（ROM）或电擦除只读存储器（EEPROM），也就是常说的固件。&lt;/li&gt;
&lt;li&gt;一个事件的发生通常通过硬件或软件的 &lt;strong&gt;中断（interrupt）&lt;/strong&gt; 来触发。硬件可能在任何时候通过向 CPU 发送一个信号来 &lt;strong&gt;触发（trigger）&lt;/strong&gt; 中断，该信号通常经由总线传递。软件可能通过执行被称作 &lt;strong&gt;系统调用（system call）&lt;/strong&gt; 的特殊指令来触发中断。&lt;/li&gt;
&lt;li&gt;计算机程序必须在主存（也被称作 &lt;strong&gt;随机访问存储器（random-access memory）&lt;/strong&gt; ）中执行。主存是 CPU 能直接访问的唯一的大容量存储，它通常由被称作 &lt;strong&gt;动态随机访问存储器（dynamic random-access memory，DRAM）&lt;/strong&gt; 的半导体器件实现。主存是 &lt;em&gt;易失（volatile）&lt;/em&gt; 存储，当电源关闭或其它问题出现时，其内容会丢失。因此多数计算机系统提供了 &lt;strong&gt;二级存储（secondary storage）&lt;/strong&gt; 作为主存的扩展，二级存储设备通常是 &lt;strong&gt;磁盘（magnetic disk）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;操作系统对每一个设备控制器均设置有一个 &lt;strong&gt;设备驱动（device driver）&lt;/strong&gt; ，要启动一个 I/O 操作需经过如下步骤：&lt;ul&gt;
&lt;li&gt;设备驱动设置设备控制器内部对应的寄存器&lt;/li&gt;
&lt;li&gt;设备控制器检查其内部寄存器并确定要执行的行为&lt;/li&gt;
&lt;li&gt;设备控制器启动数据传输，数据 &lt;strong&gt;从设备发送给本地缓存&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;一旦数据传输结束，设备控制器通过触发一个中断通知设备驱动&lt;/li&gt;
&lt;li&gt;设备驱动将控制权交还给操作系统；如果 I/O 操作是读行为，则携带读取的数据或者指向数据的指针；如果 I/O 操作是其他行为，则返回状态信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大量数据移动通常使用 &lt;strong&gt;直接存储器访问（direct memory access，DMA）&lt;/strong&gt; 。在为 I/O 设备设置缓冲区、指针、计数器后，设备控制器将整块数据直接从它的缓冲区发送到主存（或相反方向）而不经过 CPU。传输一块数据只会触发一次 CPU 中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;计算机系统体系与结构&quot;&gt;&lt;a href=&quot;#计算机系统体系与结构&quot; class=&quot;headerlink&quot; title=&quot;计算机系统体系与结构&quot;&gt;&lt;/a&gt;计算机系统体系与结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多处理器系统（multiprocessor system）&lt;/strong&gt; ，也被称作 &lt;strong&gt;并行系统（parallel system）&lt;/strong&gt; 或 &lt;strong&gt;轻耦合系统（lightly coupled system）&lt;/strong&gt; 有以下三个主要优点：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;增加吞吐量（throughput）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性价比高&lt;/strong&gt; ：相比多个单处理器系统，因为多处理器系统可以共享 &lt;strong&gt;外围设备（peripherals）&lt;/strong&gt; 、 &lt;strong&gt;大容量存储器（mass storage）&lt;/strong&gt; 和电源，因此花费更少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加可靠性（reliability）&lt;/strong&gt; ：单处理器出现故障只会减缓系统而不会导致系统终止。根据存活硬件均衡提供服务的能力被称作 &lt;strong&gt;故障弱化（graceful degradation）&lt;/strong&gt; 。有些系统具有 &lt;strong&gt;容错能力（fault tolerant）&lt;/strong&gt; ，当任何一个单件出错时，系统能够继续运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多处理器系统主要有两种类型：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非对称多处理器（asymmetric multiprocessing）&lt;/strong&gt; ：每个处理器被赋予一定特殊作业，一个主处理器用于控制系统，其它的处理器要么从主处理器获取信息，要么执行预定义的作业。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称多处理器（symmetric multiprocessing，SMP）&lt;/strong&gt; ：每个处理器均可执行操作系统中的所有作业，处理器之间不存在主从关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多道程序（multiprogramming）&lt;/strong&gt; 通过组织作业（代码或数据）增加了 CPU 的利用率（utilization），CPU 无论何时均有一个作业在执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分时（time sharing）&lt;/strong&gt; ，或者 &lt;strong&gt;多工（multitasking）&lt;/strong&gt; 是多道程序在逻辑上的扩展，CPU 在多个程序间跳转执行，因为跳转速度很快，对于用户而言就可以与各个同时运行的程序交互。 分时需要 &lt;strong&gt;交互式（interactive）&lt;/strong&gt; 的计算机系统，用户和系统之间应该可以直接交流，且 &lt;strong&gt;响应时间（response time）&lt;/strong&gt; 应当足够短。&lt;/li&gt;
&lt;li&gt;一个被装入主存并执行的程序被称作 &lt;strong&gt;进程（process）&lt;/strong&gt; 。分时和多道程序需要主存中同时保持多个作业，因为主存通常不足以同时容纳这些作业，所以它们在执行前被存放在硬盘的 &lt;strong&gt;作业池（job pool）&lt;/strong&gt; 中，它容纳了所有等待分配主存的进程。&lt;/li&gt;
&lt;li&gt;如果多个作业因为主存空间不足而无法同时装载，那么系统要在作业间进行 &lt;strong&gt;作业调度（job scheduling）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;在分时系统中，操作系统必须保证响应时间，这一点有时通过进程在主存和硬盘之间的 &lt;strong&gt;交换（swapping）&lt;/strong&gt; 完成。一个更普遍的方式是 &lt;strong&gt;虚拟内存（virtual memory）&lt;/strong&gt; ，它使用户可以运行远大于 &lt;strong&gt;物理内存（physical memory）&lt;/strong&gt; 的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;操作系统运行&quot;&gt;&lt;a href=&quot;#操作系统运行&quot; class=&quot;headerlink&quot; title=&quot;操作系统运行&quot;&gt;&lt;/a&gt;操作系统运行&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;现代操作系统均为 &lt;strong&gt;中断驱动（interrupt driven）&lt;/strong&gt; ，事件几乎都通过中断或陷阱来触发。&lt;/li&gt;
&lt;li&gt;一个 &lt;strong&gt;陷阱（trap）&lt;/strong&gt; 或者说 &lt;strong&gt;异常（exception）&lt;/strong&gt; ，是软件产生的中断。触发的原因要么是错误的产生（例如除 0 操作或为例内存访问），要么是用户程序执行了对操作系统服务的特殊请求。&lt;/li&gt;
&lt;li&gt;为了保证操作系统程序正确执行，我们需要区分系统程序段和用户程序段。因此设置了两个独立的操作 &lt;strong&gt;模式（modes）&lt;/strong&gt; ： &lt;strong&gt;用户模式（user mode）&lt;/strong&gt; 和 &lt;strong&gt;内核/管理/系统/特权模式（kernel/supervisor/system/privileged mode）&lt;/strong&gt; 。计算机硬件中需要加入一个 &lt;strong&gt;模式位（mode bit）&lt;/strong&gt; 用于说明当前的模式为内核（0）还是用户（1）。&lt;/li&gt;
&lt;li&gt;在系统启动时，硬件系统处于内核模式。之后操作系统被加载并且在用户模式中执行用户应用。当一个陷阱或者中断发生，硬件将从用户模式切换到内核模式。&lt;/li&gt;
&lt;li&gt;我们将一些机器指令指定为可能产生有害作用的 &lt;strong&gt;特权指令（privileged instructions）&lt;/strong&gt; ，硬件只允许特权指令在内核模式中运行。一旦系统调用被执行，它将被硬件视为一个软中断，中断向量将被传递给系统内部的一个服务程序，并且模式位切换至内核模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时器（timer）&lt;/strong&gt; 可使计算机在一定时间后被中断。在将控制权交还给用户之前，操作系统必须保证定时器已被设置，一旦定时器触发中断，控制权将自动交还给操作系统，操作系统会将该中断视作一个致命的错误（fatal error）或者给这个程序更多的执行时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序是被动的实体，而进程是主动（active）的实体。&lt;/li&gt;
&lt;li&gt;一个进程要完成任务需要如下资源：CPU，存储器，文件和 I/O 设备。一个单线程的进程有一个 &lt;strong&gt;程序计数器（program counter）&lt;/strong&gt; 指定下一条要执行的指令，多线程的进程有多个程序计数器。&lt;/li&gt;
&lt;li&gt;进程是系统中的工作单元。通过在单 CPU 的复用，所有的进程都有机会并行执行。&lt;/li&gt;
&lt;li&gt;操作系统需要对进程管理及以下相关行为负责：&lt;ul&gt;
&lt;li&gt;创建或删除用户或系统进程&lt;/li&gt;
&lt;li&gt;挂起或继续进程&lt;/li&gt;
&lt;li&gt;为进程同步提供机制&lt;/li&gt;
&lt;li&gt;为进程通信提供机制&lt;/li&gt;
&lt;li&gt;为死锁的处理提供机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;操作系统结构（第二章）&quot;&gt;&lt;a href=&quot;#操作系统结构（第二章）&quot; class=&quot;headerlink&quot; title=&quot;操作系统结构（第二章）&quot;&gt;&lt;/a&gt;操作系统结构（第二章）&lt;/h1&gt;&lt;h2 id=&quot;操作系统服务&quot;&gt;&lt;a href=&quot;#操作系统服务&quot; class=&quot;headerlink&quot; title=&quot;操作系统服务&quot;&gt;&lt;/a&gt;操作系统服务&lt;/h2&gt;&lt;p&gt;操作系统应提供如下服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户接口（user interface）&lt;/strong&gt; ，包括：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;命令行接口（command-line interface，CLI）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;批处理接口（batch interface）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图形化用户接口（graphical user interface，GUI）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序执行（program execution）&lt;/strong&gt; ：操作系统要能够将程序加载到主存并执行程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入/输出操作（I/O operations）&lt;/strong&gt; ：运行中的程序可能需要涉及到文件或 I/O 设备的读写操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件系统控制（file-system manipulation）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信（communications）&lt;/strong&gt; ：通信可能通过 &lt;em&gt;共享内存（shared memory）&lt;/em&gt; 或 &lt;em&gt;消息传递（message passing）&lt;/em&gt; 实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误检测（error detection）&lt;/strong&gt; ：操作系统应当能始终检测到可能的错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源分配（resource allocation）&lt;/strong&gt; ：一些资源需要特殊的分配行为（如 CPU、主存和文件存储），有的还需要请求和释放代码（如 I/O 设备）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计（accounting）&lt;/strong&gt; ：操作系统需要对每个用户使用了多少不同的计算机资源做统计&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全防护（protection and security）&lt;/strong&gt; ：保证所有对系统资源的请求都得以控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;用户接口和系统调用&quot;&gt;&lt;a href=&quot;#用户接口和系统调用&quot; class=&quot;headerlink&quot; title=&quot;用户接口和系统调用&quot;&gt;&lt;/a&gt;用户接口和系统调用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;有的操作系统将命令解释器（command interpreter）作为系统内核的一部分，有的（如 Windows XP 和 UNIX）将命令解释器作为一个特殊的程序。在存在多个可选命令解释器的系统中，它们通常被称作 &lt;strong&gt;壳（shell）&lt;/strong&gt; 。命令解释器的主要功能是获取并执行下一条用户指定的指令，有两种执行的方式：&lt;ul&gt;
&lt;li&gt;命令解释器本身包含了执行命令的代码：可执行命令的数量决定了命令解释器的大小&lt;/li&gt;
&lt;li&gt;通过系统程序实现多数指令：命令解释器本身并不理解指令的含义，它仅仅通过命令指定一个文件，将其装载至主存并执行。例如 &lt;code&gt;rm file.txt&lt;/code&gt; 将程序 &lt;code&gt;rm&lt;/code&gt; 加载并传入参数 &lt;code&gt;file.txt&lt;/code&gt; 执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图形用户接口提供了一个桌面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用（system call）&lt;/strong&gt; 为系统服务提供了一个接口。多数程序开发者并不接触这一细节等级的代码，他们通常使用 &lt;strong&gt;应用程序接口（application programming interface，API）&lt;/strong&gt; 来编写程序。API 为应用程序开发者提供了一组函数，最常见的三组 API 如：Windows 系统的 Win32 API、基于 POSIX 系统的 POSIX API 和 Java API。使用 API 的背后实际涉及了系统调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用和中断的异同点&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;二者均有索引（系统调用编号-系统调用表、中断向量表），二者的执行均需切换到内核模式&lt;/li&gt;
&lt;li&gt;二者触发条件不同：系统调用是主动请求（会被硬件视为软中断），中断是外部触发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断和陷阱的不同点&lt;/strong&gt; ：&lt;ul&gt;
&lt;li&gt;二者起点不同：陷阱是正在执行的程序主动发起的，中断是外部错误或动作产生&lt;/li&gt;
&lt;li&gt;二者处理方式不同：程序的陷阱（异常）在响应后将停止执行，而程序在中断时保存断点，中断处理结束后从断点恢复执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多数程序设计语言的运行时支持系统（一系列包含在编译器链接库中的函数）提供了 &lt;strong&gt;系统调用接口（system-call interface）&lt;/strong&gt; ，它们将程序代码和操作系统提供的系统调用链接起来。每个系统调用都有一个对应的编号，系统调用接口维护了一个编号-系统调用的索引，它们截取应用程序调用的 API，调用操作系统内核中相关的系统调用，并返回系统调用状态及其他返回值。&lt;/li&gt;
&lt;li&gt;向操作系统传递参数有三种方法：通过寄存器传递、内存的块/表、压入/弹出堆栈。&lt;/li&gt;
&lt;li&gt;系统调用可被大致分为五类： &lt;strong&gt;进程控制（process control）&lt;/strong&gt; 、 &lt;strong&gt;文件管理（file manipulation）&lt;/strong&gt; 、 &lt;strong&gt;设备管理（device manipulation）&lt;/strong&gt; 、 &lt;strong&gt;信息维护（information maintenance）&lt;/strong&gt; 和 &lt;strong&gt;通信（communications）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;一个单任务系统： MS-DOS，它在计算机启动时运行一个命令解释器，当运行程序时，它将程序装入内存，并修改命令解释器的大部分内容来为新程序提供尽可能多的空间。之后将指令指针设为程序的第一条指令并运行程序，要么产生错误引起中断（此错误代码会被保存），要么程序执行一个系统调用以终止。最终命令解释器剩余部分程序继续执行，并从磁盘重新装入命令解释器的其他部分。这些步骤完成后，命令解释器会想用户/下一程序提供上一次运行的结果（保存的错误代码）。&lt;/li&gt;
&lt;li&gt;多任务系统：FreeBSD，用户登录到系统时，从用户选择的 Shell 开始执行。为了启动新进程，Shell 执行 &lt;code&gt;fork()&lt;/code&gt; 系统调用，所选择的程序通过 &lt;code&gt;exec()&lt;/code&gt; 装入内存并执行。根据命令发布方式，Shell 要么等待进程结束，要么在后台执行进程并继续响应用户输入。&lt;/li&gt;
&lt;li&gt;两种通信模型：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息传递模型（message-passing model）&lt;/strong&gt; ：通信进程通过彼此之间交换消息传递信息，直接/间接通过一个共同的邮箱。通信实体可能是同一主机的不同进程，也可能是通过网络相连的另一主机的进程。进程之间通过 &lt;strong&gt;主机名（host name）&lt;/strong&gt; 和 &lt;strong&gt;进程名（process name）&lt;/strong&gt; 作为标识符区分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享内存模型（shared-memory model）&lt;/strong&gt; ：进程使用 &lt;code&gt;shared memory create&lt;/code&gt; 和 &lt;code&gt;shared memory attach&lt;/code&gt; 系统调用来获得其它进程所拥有内存区域的访问权。操作系统通常需要组织一个进程访问另一个进程的内存，要使用共享内存模型，需要两/多个进程都同意取消这一限制。数据的形式和位置由进程协商决定，不受操作系统控制，进程必须保证它们不会同时向同一地方写入。&lt;/li&gt;
&lt;li&gt;区别：消息传递对交换少量数据更有效，对于计算机之间的通信也比共享内存更容易实现；共享内存允许最大速度通信（本地可以内存速度），并且比较方便，但需要保护和同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;操作系统设计和实现&quot;&gt;&lt;a href=&quot;#操作系统设计和实现&quot; class=&quot;headerlink&quot; title=&quot;操作系统设计和实现&quot;&gt;&lt;/a&gt;操作系统设计和实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统程序（system program）&lt;/strong&gt; 为开发程序和执行程序提供了一个方便的环境，它们可分为：&lt;ul&gt;
&lt;li&gt;文件管理（file management）&lt;/li&gt;
&lt;li&gt;状态信息（status information）&lt;/li&gt;
&lt;li&gt;文件修改（file modification）&lt;/li&gt;
&lt;li&gt;程序语言支持（programming-language support）&lt;/li&gt;
&lt;li&gt;程序装入和执行（program loading and execution）&lt;/li&gt;
&lt;li&gt;通信（communications）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统设计目标：分为 &lt;em&gt;用户&lt;/em&gt; 目标 和 &lt;em&gt;系统&lt;/em&gt; 目标&lt;ul&gt;
&lt;li&gt;用户目标：系统应当方便、容易使用、容易学习、可靠、安全、快速&lt;/li&gt;
&lt;li&gt;系统目标：操作系统应该容易设计、实现和维护，应该灵活、可靠、高效而没有错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略（policy）&lt;/strong&gt; 和 &lt;strong&gt;机制（mechanism）&lt;/strong&gt; 的区分：机制决定如何做（ &lt;em&gt;how&lt;/em&gt; to do），而策略决定做什么（ &lt;em&gt;what&lt;/em&gt; will be done）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;操作系统结构&quot;&gt;&lt;a href=&quot;#操作系统结构&quot; class=&quot;headerlink&quot; title=&quot;操作系统结构&quot;&gt;&lt;/a&gt;操作系统结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简单结构：利用最小的空间提供最多的功能，没有被划分为模块，如 MS-DOS 和最初的 UNIX。应用程序能够访问最底层的、基本的设备驱动，因此易受恶意程序的伤害。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分层方法（Layered Approach）&lt;/strong&gt; ：采用自顶向下方法，将总的功能和特征划分为模块。模块化的其中方法是分层方法：将操作系统分为若干层（级），最底层（层0）为硬件，最高层（层N）为用户接口，分层结构类似一个同心圆。分层法最大的 &lt;strong&gt;优点在于构造和调试的简单化&lt;/strong&gt; （每层只能利用较低层的功能和服务、每层为高层隐藏了一定数据结构、操作和硬件存在），主要困难在于 &lt;strong&gt;对层的详细定义&lt;/strong&gt; 和 &lt;strong&gt;相比其他方法的低效&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;微内核（microkernels）&lt;/strong&gt; ：将操作系统中所有非基本部分从内核中移走，将它们实现为系统程序或用户程序，从而得到更小的内核。微内核通常包括最小的进程、内存管理和通信功能。Windows NT 系统采用了分层微内核，有些 UNIX 系统也采用了此种方式。&lt;ul&gt;
&lt;li&gt;微内核的主要功能是使客户程序和运行在用户空间的各种服务之间通信，客户程序和服务之间不会直接交互，而是通过微内核的 &lt;strong&gt;消息传递&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;因为新服务可在用户空间增加而不需修改内核，因此 &lt;strong&gt;便于扩充操作系统&lt;/strong&gt; ；因为大多数服务作为用户而不是内核进程运行，因此提供了 &lt;strong&gt;更好的安全性和可靠性&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;因为使用消息传递，系统功能总开销增加，因此 &lt;strong&gt;系统性能下降&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块（modules）&lt;/strong&gt; ：用面向对象技术生成模块化的内核，动态加载模块。内核可以提供核心服务，也可动态实现特定功能。该方法和微内核方法类似，核心模块只有核心功能以及其他模块加载、通信的相关信息，但模块方法中， &lt;strong&gt;模块之间不需要调用消息传递来通信&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;示例：Mac OS X操作系统的结构，底层为 Mach 微内核，提供内存管理、远程程序调用（remote process call，RPC）和进程间通信（IPC）工具；BSD 提供 BSD 命令行接口，支持网络、文件系统、POSIX API 实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;虚拟机和系统生成&quot;&gt;&lt;a href=&quot;#虚拟机和系统生成&quot; class=&quot;headerlink&quot; title=&quot;虚拟机和系统生成&quot;&gt;&lt;/a&gt;虚拟机和系统生成&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;虚拟机的基本思想是单个计算机（CPU、内存、硬盘、网卡等）硬件抽象为几个不同的执行部件。&lt;/li&gt;
&lt;li&gt;虚拟机除了提供与基本硬件相同的接口外，不提供额外功能。每个进程都有一个与底层机器完全相同的（虚拟）副本。&lt;/li&gt;
&lt;li&gt;虚拟机为每个虚拟系统提供 &lt;strong&gt;小型磁盘（minidisk）&lt;/strong&gt; ，系统在物理磁盘上为小型磁盘分配所需要的磁道来实现。所有小型磁盘的大小之和必须小于可用的物理磁盘。&lt;/li&gt;
&lt;li&gt;底层物理机器有两种模式：用户模式和内核模式，虚拟机软件本身在物理机器上运行在用户模式中，而虚拟机在虚拟系统中运行在内核模式，每个虚拟系统有虚拟用户模式和虚拟内核模式，这两种模式均运行在物理用户模式。&lt;/li&gt;
&lt;li&gt;虚拟的 I/O 操作可能需要更少（脱机操作）或更多（解释执行）的时间。&lt;/li&gt;
&lt;li&gt;优点：可用于研究、开发操作系统；不同系统资源具有完全的保护，各个虚拟机之间完全独立。&lt;/li&gt;
&lt;li&gt;操作系统通常设计成能运行在一类计算机上，对于某类特定的计算机场所，配置生成系统的过程称为 &lt;strong&gt;系统生成（system generation，SYSGEN）&lt;/strong&gt; 。需要考虑的信息有：使用什么CPU、多少可用内存、哪些可用设备、需要什么操作系统选项和参数值。这些信息确定后，系统管理员可用这些信息修改操作系统的源代码副本以完全重新编译操作系统；或者创建一个表，从预先编译过的库中选取模块，将这些模块连接起来生成操作系统；或者构造一个完全由表驱动的系统，所有代码都是系统的组成部分， &lt;strong&gt;选择发生在执行时而不是编译时&lt;/strong&gt; ，现代多数操作系统均为此种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;系统引导&quot;&gt;&lt;a href=&quot;#系统引导&quot; class=&quot;headerlink&quot; title=&quot;系统引导&quot;&gt;&lt;/a&gt;系统引导&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;装入内核以启动计算机的过程称为 &lt;strong&gt;引导（booting）&lt;/strong&gt; 系统，多数计算机中均有一小块代码，称为 &lt;strong&gt;引导程序（bootstrap program）&lt;/strong&gt; 或 &lt;strong&gt;引导装载程序（bootstrap loader）&lt;/strong&gt; ，这段代码将定位内核，将其装入内存并开始执行。引导程序被存放在只读存储器中。&lt;/li&gt;
&lt;li&gt;对于大型操作系统（多数通用操作系统），引导程序存储在固件中，操作系统保存在磁盘上。引导程序运行诊断程序，从磁盘固定位置（0区块）读取整个引导块到内存，并执行这个 &lt;strong&gt;引导块（boot block）&lt;/strong&gt; 中的代码。这个引导块足够复杂，它将一个完整的操作系统装载到内存开始执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;专栏目录：&lt;a href=&quot;http://blog.forec.cn/columns/cs-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机理论基础&lt;/a&gt;&lt;br&gt;此专栏的上一篇文章：&lt;a href=&quot;http://blog.forec.cn/2015/11/14/Computer-Organization-Architecture6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计组与体系结构笔记（六）：输入/输出与存储系统&lt;/a&gt;&lt;br&gt;此专栏的下一篇文章：&lt;a href=&quot;http://blog.forec.cn/2016/11/22/os-concepts-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;操作系统（二）：进程与线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：《操作系统概念 英文第七版》，恐龙书，英文名《Operating System Concepts》，作者 Abraham Silberschatz、Peter Baer Galvin、Greg Gagne&lt;/p&gt;
&lt;p&gt;原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章&lt;a href=&quot;http://blog.forec.cn/2016/11/22/os-concepts-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始出处&lt;/a&gt;(&lt;a href=&quot;http://blog.forec.cn/2016/11/22/os-concepts-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.forec.cn/2016/11/22/os-concepts-1/&lt;/a&gt;) 、作者信息（&lt;a href=&quot;http://forec.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forec&lt;/a&gt;）和本声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整理《Operating System Concepts》 第七版前两章的理论和概念，内容均为原书的摘录，由我 &lt;strong&gt;按个人理解简化、翻译为中文，可能存在一些不准确之处&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机理论基础" scheme="http://forec.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="http://forec.github.io/tags/OS/"/>
    
  </entry>
  
</feed>
