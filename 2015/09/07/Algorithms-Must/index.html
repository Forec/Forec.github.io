<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>排序和字符串匹配 | Forec的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要
排序
字符串匹配">
<meta property="og:type" content="article">
<meta property="og:title" content="排序和字符串匹配">
<meta property="og:url" content="http://forec.github.io/2015/09/07/Algorithms-Must/index.html">
<meta property="og:site_name" content="Forec的博客">
<meta property="og:description" content="摘要
排序
字符串匹配">
<meta property="og:updated_time" content="2016-02-04T13:06:09.753Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序和字符串匹配">
<meta name="twitter:description" content="摘要
排序
字符串匹配">
  
    <link rel="alternative" href="/atom.xml" title="Forec的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xktmz.com1.z0.glb.clouddn.com/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Forec</a></h1>
		</hgroup>

		
		<p class="header-subtitle">奋斗在Code World的在校生</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/forec" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/forect" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto://forec@bupt.edu.cn" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/Data-Structures/" style="font-size: 13.33px;">Data-Structures</a> <a href="/tags/Mistakes/" style="font-size: 10px;">Mistakes</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/字符编码/" style="font-size: 10px;">字符编码</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/计算机组成与体系结构/" style="font-size: 16.67px;">计算机组成与体系结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://fallenwood.github.io">Fallenwood的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.codewars.com/users/Forec">Forec的CodeWars</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">就读于北京邮电大学，代码爱好者。近期自学机器学习。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Forec</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xktmz.com1.z0.glb.clouddn.com/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Forec</h1>
			</hgroup>
			
			<p class="header-subtitle">奋斗在Code World的在校生</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/forec" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/forect" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto://forec@bupt.edu.cn" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Algorithms-Must" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/07/Algorithms-Must/" class="article-date">
  	<time datetime="2015-09-07T10:29:50.000Z" itemprop="datePublished">2015-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      排序和字符串匹配
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Code/">Code</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="u6458_u8981"><a href="#u6458_u8981" class="headerlink" title="摘要"></a>摘要</h1><ul>
<li><a href="http://forec.github.io/2015/09/07/Algorithms-Must/#1">排序</a></li>
<li><a href="http://forec.github.io/2015/09/07/Algorithms-Must/#2">字符串匹配</a></li>
</ul>
<a id="more"></a>
<p></p><h1 id="1">排序</h1><p></p>
<blockquote>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
</blockquote>
<h2 id="u76F4_u63A5_u63D2_u5165_u6392_u5E8F"><a href="#u76F4_u63A5_u63D2_u5165_u6392_u5E8F" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><ul>
<li>与摸扑克牌时整理手中牌的方法相同，每次将一个新的元素插入已排序的元素中。这种方法在待排序序列基本有序的情况下效率很高。复杂度O(n^2)。是稳定的排序法。</li>
<li>代码（java，以整型数据升序排序为例），感谢梁倬宁指正<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; arr.length ; i++ )&#123;</span><br><span class="line">		<span class="keyword">int</span> j, key = arr[i];</span><br><span class="line">		<span class="keyword">for</span> ( j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j] ; j-- )   <span class="comment">// only "key &lt; arr[j]" but not " &lt;= " is stable</span></span><br><span class="line">			arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">		arr[j+<span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u5E0C_u5C14_u6392_u5E8F"><a href="#u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li>希尔排序是对直接插入排序的改进，<strong>比较是希尔排序最主要的操作，而不是交换</strong>。先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成），对每个子序列进行直接插入排序，然后缩减增量再进行排序，直到整个序列中的元素基本有序（增量足够小），再对全体元素进行一次直接插入排序。此时元素基本有序，效率很高。“增量”的选择是希尔排序的重要部分，只要最终步长为1任何步长序列都可以工作（当步长为1时，算法变为插入排序，这就保证了数据一定会被排序）。已知的最好增量序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自9 \times 4^i - 9 \times 2^i + 1和2^{i+2} \times (2^{i+2} - 3) + 1这两个算式。用这样增量序列的希尔排序比插入排序和堆排序都要快，在小数组中速度甚至超过快速排序，但是在涉及大量数据时希尔排序还是比快速排序慢。另一个在大数组中表现优异的步长序列是斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列。希尔排序不是稳定的排序。</li>
<li>代码（java，以整型数据升序排序为例）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[l];</span><br><span class="line">	arr[l] = arr[r];</span><br><span class="line">	arr[r] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> []arr)</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++)  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + gap]; j -= gap)  </span><br><span class="line">                swap(arr,j, j + gap);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u9009_u62E9_u6392_u5E8F"><a href="#u9009_u62E9_u6392_u5E8F" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>每次从待排序的元素中选取最大（最小）的元素放到已排序序列的末尾。复杂度O(n^2)。是不稳定排序。</li>
<li>代码（java，以整型数据升序排序为例）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length - <span class="number">1</span> ; i++ )&#123;</span><br><span class="line">		<span class="keyword">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; arr.length ; j++ )</span><br><span class="line">			<span class="keyword">if</span> ( arr[j] &lt; arr[min] )</span><br><span class="line">				min = j;</span><br><span class="line">		<span class="keyword">if</span> ( min != i )</span><br><span class="line">			swap(arr, i, min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>每次交换相邻的两个元素，若前者大于后者就交换，当第一次对全部元素完成该步骤后，最后一个元素即为最大值，对越来越少的元素重复上述步骤，直到全部数据比较完成。复杂度O(n^^2)。是稳定排序。</li>
<li>代码（Golang，以整型数据升序排序为例）<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> bubbleSort(arr []<span class="typename">int</span>, n <span class="typename">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span> ; j &lt; n-<span class="number">1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u5F52_u5E76_u6392_u5E8F"><a href="#u5F52_u5E76_u6392_u5E8F" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>分治思想，将待排序元素分成两份，之后对每份分别排序，排序完成后再合并成一个序列。排序过程可以递归完成，直到待排序的某个序列为单个元素即可返回。复杂度O(NlogN)。是稳定排序。</li>
<li>代码（java，以整型数据升序排序为例）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( l &lt; r )&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = ( l + r ) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		mergeSort(arr, l, mid);</span><br><span class="line">		mergeSort(arr, mid+<span class="number">1</span> , r);</span><br><span class="line">		<span class="keyword">int</span> l1 = mid - l + <span class="number">1</span>, l2 = r - mid;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="keyword">int</span> [] L = <span class="keyword">new</span> <span class="keyword">int</span>[l1+<span class="number">1</span>], R = <span class="keyword">new</span> <span class="keyword">int</span>[l2+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; l1 ; i++ )</span><br><span class="line">			L[i] = arr[l+i];</span><br><span class="line">		<span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; l2 ; j++)</span><br><span class="line">			R[j] = arr[mid+j+<span class="number">1</span>];</span><br><span class="line">		L[l1] = R[l2] = INF;</span><br><span class="line">			i = j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> k = l ; k &lt;= r ; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span> ( L[i] &lt;= R[j] )</span><br><span class="line">				arr[k] = L[i++];</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				arr[k] = R[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u5806_u6392_u5E8F"><a href="#u5806_u6392_u5E8F" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li><p>利用二叉堆（分为最大堆/大根堆和最小堆/小根堆）管理数据，数据存储形式可以视为完全二叉树，除了最后一层的每一层都是填满的。用数组存储这个堆时，给定某个节点的下标i，其父节点Parent(i)，左孩子Left(i)和右孩子Right(i)分别为i/2，2×i和2×i+1。以最大堆为例，堆中的最大元素存放在根节点当中，在以某个节点为根的子树中，各节点的值均不小于该子树根节点的值，也就是除了根以外的每个节点都满足Parent(i).value &gt;= i.value。堆排序中通常使用最大堆，最小堆一般在构造优先队列时使用。其时间复杂度O(NlogN)，是不稳定排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Parent</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Left</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Right</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆的维护（最大堆为例），维护时自顶向下，将根节点与两个子女比较，如果满足最大堆性质则无需调整， 否则将两个子女中的较大者和根交换，此时原本以被交换的子女为根的子树可能被破坏了最大堆性质，要对该子树维护，递归即可。该操作最坏情况下的复杂度与该操作作用的节点深度有关，对于深度h的节点，复杂度O(h)。<br>下例中的heapsize为当前堆中元素数目，i为需要维护的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapsize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = Left(i), r = Right(i), largest = i;</span><br><span class="line">	<span class="keyword">if</span> ( l &lt;= heapsize &amp;&amp; arr[l] &gt; arr[i] )</span><br><span class="line">		largest = l;</span><br><span class="line">	<span class="keyword">if</span> ( r &lt;= heapsize &amp;&amp; arr[r] &gt; arr[largest] )</span><br><span class="line">		largest = r;</span><br><span class="line">	<span class="keyword">if</span> ( largest != i )&#123;</span><br><span class="line">		swap(arr, i, largest);</span><br><span class="line">		MaxHeapify(arr, largest,heapsize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建堆（最大堆为例），对于一个序列，可以自下而上通过不断维护非叶节点构造。根据Parent(i) = i/2，可以知道长度为n的序列中前n/2个元素为非叶节点。容易理解自下向上的维护可以保证整棵树的性质成立。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = (arr.length-<span class="number">1</span>) / <span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i--)</span><br><span class="line">		MaxHeapify(arr, i,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序（最大堆为例），先对待排序序列建堆，之后每次取出根节点元素（该元素为堆中剩余元素最大值），并用堆中最后一个元素代替它，再维护根节点。即每取出一个元素，堆中元素数量减一，但性质得以保持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	BuildHeap(arr);</span><br><span class="line">	<span class="keyword">int</span> heapsize = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = heapsize ; i &gt;= <span class="number">2</span> ; i--)&#123;</span><br><span class="line">		swap(arr, <span class="number">1</span>, i);</span><br><span class="line">		MaxHeapify(arr, <span class="number">1</span>,--heapsize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u5FEB_u901F_u6392_u5E8F"><a href="#u5FEB_u901F_u6392_u5E8F" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>快速排序同样基于分治思想，对于开始的待排序序列，选取一个“标准元素”，每个元素都和这个标准元素比较，大的放在一边，小的放在另一边。之后将这个标准元素两边（一边都比它大，一边都比它小）分别作为待排序序列重复上述操作，直到每个待排序序列为一个元素，递归结束后即为有序序列。时间复杂度O(NlogN)，为不稳定排序。快速排序用途最为广泛并且容易编写。</li>
<li>代码实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cmp = arr[r];</span><br><span class="line">	<span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> j = l ; j &lt; r ; j++ )</span><br><span class="line">		<span class="keyword">if</span> ( arr[j] &lt; cmp )</span><br><span class="line">			swap(arr, ++i, j);</span><br><span class="line">		swap(arr, i+<span class="number">1</span>, r);</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> []arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( l &lt; r )&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = Partition(arr, l, r);</span><br><span class="line">		QuickSort(arr, l, mid-<span class="number">1</span>);</span><br><span class="line">		QuickSort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="u7EBF_u6027_u65F6_u95F4_u6392_u5E8F"><a href="#u7EBF_u6027_u65F6_u95F4_u6392_u5E8F" class="headerlink" title="线性时间排序"></a>线性时间排序</h2><blockquote>
<p>上面的排序方法均采用比较操作，这类排序算法被称作比较排序。线性时间排序均采用非比较操作。应用不多，不介绍。</p>
</blockquote>
<ul>
<li>计数排序</li>
<li><a href="http://forec.github.io/2015/09/09/Data-Structure-example1/#8">基数排序</a>，有链表实现的代码。</li>
<li>桶排序</li>
</ul>
<hr>
<p></p><h1 id="2">字符串匹配</h1><p></p>
<blockquote>
<p>字符串匹配算法较多，暴力实现最容易编写并且效率不低，同样时间复杂度的算法还有Sunday，Robin-Karp和Bitap。相比下BF无需预处理，更容易编写。他们的时间复杂度都为O(N*M)，N为源文本长度，M为要匹配的字符串长度。</p>
</blockquote>
<h2 id="Brute_Force"><a href="#Brute_Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><blockquote>
<p>暴力搜索，将源文本的每个字符元作为匹配字符串的起点比较，若出现匹配则返回，否则将下一字符元作为起点。</p>
</blockquote>
<ul>
<li>代码（C语言。java调用indexOf或者contains方法即可）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BruteForce</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">const</span> <span class="keyword">char</span> *tofind )</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ( source == <span class="string">'\0'</span> || tofind == <span class="string">'\0'</span> )  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>( source ) &lt; <span class="built_in">strlen</span>( tofind ) )</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> *s = source, *p = source, *q = tofind;</span><br><span class="line">    <span class="keyword">while</span> ( *p != <span class="string">'\0'</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> ( *p == *q )&#123;  </span><br><span class="line">            p++;  </span><br><span class="line">            q++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            p = ++s;  </span><br><span class="line">            q = tofind;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> ( *q == <span class="string">'\0'</span> )  </span><br><span class="line">            <span class="keyword">return</span> ( p - source ) - ( q - tofind ); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>比Brute Force更快捷，并且实现起来也同样简单的是KMP算法，它需要O(M)的时间用于预处理要匹配的字符串，匹配的时间复杂度只有O(N)。同样复杂度的还有Boyer Moore算法，其效率稍高，但实现复杂。KMP可以满足多数情况的需求。</p>
</blockquote>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul>
<li>KMP先对要匹配的字符串预处理，当发现某个位置作为开头与源文本匹配不成功时，不会像朴素算法一样将<strong>源文本</strong>紧邻的下一个字符元作为字符串开头匹配，而是将<strong>要匹配的字符串</strong>目前匹配到的位置跳到下一个可能匹配成功的地方。</li>
<li>这里有一篇非常清楚、简明的文章，<a href="http://kb.cnblogs.com/page/176818/" target="_blank" rel="external">字符串匹配的KMP算法</a>，很容易明白KMP的原理。</li>
<li>代码实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">( <span class="keyword">char</span> * toFind )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( j &lt; <span class="built_in">strlen</span>( toFind ) - <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( k == -<span class="number">1</span> || toFind[k] == toFind[j] )</span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k = next[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">( <span class="keyword">char</span> * source, <span class="keyword">char</span> * toFind )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    GetNext( toFind );</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; <span class="built_in">strlen</span>( source ) )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( j == -<span class="number">1</span> || source[i] == toFind[j] )&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        <span class="keyword">if</span> ( j == <span class="built_in">strlen</span>( toFind ) )</span><br><span class="line">            <span class="keyword">return</span> i - <span class="built_in">strlen</span>( toFind ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章<a href="http://forec.github.io/2015/09/07/Algorithms-Must/">原始出处</a>(<a href="http://forec.github.io/2015/09/07/Algorithms-Must/">http://forec.github.io/2015/09/07/Algorithms-Must/</a>) 、作者信息（<a href="http://forec.github.io/">Forec</a>）和本声明。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/09/08/Data-Structure-basis1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          基础数据结构（需求和树相关）
        
      </div>
    </a>
  
  
    <a href="/2015/09/07/九月计划/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">九月计划</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Algorithms-Must" data-title="排序和字符串匹配" data-url="http://forec.github.io/2015/09/07/Algorithms-Must/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"forec"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Forec
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>