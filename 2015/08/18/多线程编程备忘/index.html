<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>多线程编程备忘 | Forec&#39;s Notes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="线程" />
    
    <meta name="description" content="操作系统中的进程和线程，C/C++，Java，Python中多线程的备忘">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程编程备忘">
<meta property="og:url" content="http://forec.github.io/2015/08/18/多线程编程备忘/index.html">
<meta property="og:site_name" content="Forec's Notes">
<meta property="og:description" content="操作系统中的进程和线程，C/C++，Java，Python中多线程的备忘">
<meta property="og:image" content="http://7xktmz.com1.z0.glb.clouddn.com/multi-thread.jpg">
<meta property="og:updated_time" content="2016-11-04T15:20:41.329Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多线程编程备忘">
<meta name="twitter:description" content="操作系统中的进程和线程，C/C++，Java，Python中多线程的备忘">
    

    
        <link rel="alternate" href="/atom.xml" title="Forec&#39;s Notes" type="application/atom+xml" />
    

    
        <link rel="icon" href="http://7xktmz.com1.z0.glb.clouddn.com/sitefavicon.png# path to favicon" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css" type="text/css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css" type="text/css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css" type="text/css">

    <link rel="stylesheet" href="/css/style.css" type="text/css">

    <script src="/libs/jquery/2.0.3/jquery.min.js" type="text/javascript"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css" type="text/css">
    
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">关于我</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/columns/index.html">专栏</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/projects/index.html">个人项目列表</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="http://forec.cn">FOREC 的官方网站</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/apis/index.html">API</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js" type="text/javascript"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Code/">Code</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-多线程编程备忘" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        多线程编程备忘
        </h1>
    

            </header>
        
        
            <div class="article-subtitle">
                <a href="/2015/08/18/多线程编程备忘/" class="article-date">
    <time datetime="2015-08-18T01:16:02.000Z" itemprop="datePublished">2015-08-18</time>
</a>
                
    <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <blockquote>
<p>操作系统中的进程和线程，C/C++，Java，Python中多线程的备忘</p>
</blockquote>
<a id="more"></a>
<h1 id="操作系统中的进程和线程（From-CareySon）"><a href="#操作系统中的进程和线程（From-CareySon）" class="headerlink" title="操作系统中的进程和线程（From CareySon）"></a>操作系统中的进程和线程（From <a href="http://www.cnblogs.com/CareySon/archive/2012/05/04/ProcessAndThread.html" target="_blank" rel="external">CareySon</a>）</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>操作系统中进程拥有独立的内存地址空间和一个用于控制的线程，多个线程共享进程的内存地址空间。</li>
<li>进程是组织资源的最小单位，线程是安排CPU执行的最小单位。</li>
<li>线程共享地址空间，而进程共享物理内存，打印机，键盘等资源。<table><tr><td>进程占有的资源</td><td>线程占有的资源</td></tr><tr><td>地址空间，全局变量，打开的文件，子进程，信号量，账户信息</td><td>栈，寄存器，状态  ，程序计数器</td></tr></table></li>
<li>线程的优势  <ol>
<li>在需要多线程互相同步或互斥的并行工作时，分解为不同的线程可以<strong>简化编程模型</strong>。</li>
<li><strong>线程比进程轻量</strong>，创建和销毁的代价更小。</li>
<li><strong>线程在宏观上并行，但微观上串行</strong>。当某些线程等待资源时（例如IO操作），其它线程得以继续执行，避免整个进程阻塞，提高了CPU利用率。</li>
<li>当多CPU或CPU多核心时，微观上线程也是并行的。</li>
</ol>
</li>
</ul>
<h2 id="操作系统实现线程模式"><a href="#操作系统实现线程模式" class="headerlink" title="操作系统实现线程模式"></a>操作系统实现线程模式</h2><h3 id="线程实现在用户空间下"><a href="#线程实现在用户空间下" class="headerlink" title="线程实现在用户空间下"></a>线程实现在用户空间下</h3><ul>
<li>每一个进程中都维护着一个线程表来追踪本进程中的线程，表中包含每个线程独占的资源，如栈，寄存器，状态等。当一个线程完成了其工作或等待需要被阻塞时，其调用系统过程阻塞自身，然后将CPU交由其它线程。</li>
<li>进程表由系统维护，操作系统只能看到进程，而不能看到线程。过去的操作系统大部分是这种实现方式，优势之一在于即使操作系统不支持线程，也可以通过库函数来支持线程。</li>
<li>优势：  <ol>
<li>在用户空间下进行进程切换的速度要远快于在操作系统内核中实现  </li>
<li>在用户空间下实现线程使得程序员可以实现自己的线程调度算法。如进程可以实现垃圾回收器来回收线程。  </li>
<li>当线程数量过多时，由于在用户空间维护线程表，不会占用大量的操作系统空间。    </li>
</ol>
</li>
<li>劣势：  <ol>
<li>当一个进程中的某一个线程进行系统调用时，比如缺页中断而导致线程阻塞，此时操作系统会阻塞整个进程，即使这个进程中其它线程还在工作。  </li>
<li>假如进程中一个线程长时间不释放CPU，因为用户空间并没有时钟中断机制，会导致此进程中的其它线程得不到CPU而持续等待。</li>
</ol>
</li>
</ul>
<h3 id="线程实现在操作系统中"><a href="#线程实现在操作系统中" class="headerlink" title="线程实现在操作系统中"></a>线程实现在操作系统中</h3><ul>
<li>操作系统知道线程的存在，线程表存在操作系统内核中。</li>
<li>所有可能阻塞线程的调用都以系统调用(System Call)的方式实现，相比在用户空间下实现线程造成阻塞的运行时调用(System runtime call)成本会高出很多。当一个线程阻塞时，操作系统可以选择将CPU交给同一进程中的其它线程，或是其它进程中的线程，而在用户空间下实现线程时，调度只能在本进程中执行，直到操作系统剥夺了当前进程的CPU。</li>
<li>线程回收利用：当一个线程需要被销毁时，仅修改标记位，而不是直接销毁其内容，当一个新的线程需要被创建时，也同样修改被“销毁”的线程标记位即可。</li>
</ul>
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><ul>
<li>将上述两种方式混合，用户空间中由进程管理自己的线程，操作系统内核中有一部分内核级别的线程。</li>
</ul>
<hr>
<h1 id="多线程代码备忘"><a href="#多线程代码备忘" class="headerlink" title="多线程代码备忘"></a>多线程代码备忘</h1><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h3 id="Windows下的多线程"><a href="#Windows下的多线程" class="headerlink" title="Windows下的多线程"></a>Windows下的多线程</h3><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ul>
<li><p>需要库文件  </p>
<blockquote>
<p>windows.h   &nbsp;&nbsp;// for HANDLE<br> process.h   &nbsp;&nbsp;// for _beginthreadex()  </p>
</blockquote>
</li>
<li><p>CreateThread（Windows提供的api接口） </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span><br><span class="line">      LPSECURITY_ATTRIBUTES lpsa,</span><br><span class="line">      DWORD cbStack,</span><br><span class="line">      LPTHREAD_START_ROUTINE lpStartAddr,</span><br><span class="line">      LPVOID lpvThreadParam,</span><br><span class="line">      DWORD fdwCreate,</span><br><span class="line">      LPDWORD lpIDThread</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ol>
<li>lpsa是安全属性结构，主要控制该线程句柄是否可为进程的子进程继承使用，默认使用NULL时表示不能继承。若想继承线程句柄，则需要设置该结构体，将结构体的bInheritHandle成员初始化为TRUE。</li>
<li>cbStack表示的线程初始栈的大小，若使用0则表示采用默认大小（1M）。</li>
<li>lpStartAddr表示线程执行的函数地址，多个线程可以使用同一个函数地址。</li>
<li>lpvThreadParam是传给线程函数的参数。</li>
<li>fdwCreate是控制线程的标志，CREATE_SUSPENDED表示线程创建后挂起暂不执行，直到调用ResumeThread()，0表示线程创建之后立即执行。</li>
<li>lpIDThread返回了线程的ID，传入NULL表示不需要返回。</li>
<li>CreateThread的返回值：成功返回新线程的句柄，失败返回NULL。<br>示例：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadTest</span><span class="params">(LPVOID pM)</span></span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CurrentThread:%d\n"</span>, GetCurrentThreadId());  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    HANDLE handle = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadTest,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);  </span><br><span class="line">    WaitForSingleObject(handle,INFINITE);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>_beginthreadex</li>
</ul>
<blockquote>
<p>为什么要用_beginthreadex而不是CreateHandle?<br>简单来说:<br> _beginthreadex在内部调用了CreateThread，在调用CreateHandle之前_beginthreadex做了很多的工作，从而使得<strong>它比CreateThread更安全</strong>。——1999年7月MSJ的《Win32Q&amp;A》<br>  这里有<a href="http://www.cnblogs.com/project/archive/2011/08/21/2147634.html" target="_blank" rel="external">详细的原因</a></p>
</blockquote>
<p> 调用方法和CreateThread相同，需要强制类型转换，线程函数修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">ThreadTest</span><span class="params">(PVOID pM)</span></span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CurrentThread:%d\n"</span>, GetCurrentThreadId());  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        HANDLE handle = (HANDLE)_beginthreadex(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadTest,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">        WaitForSingleObject(handle,INFINITE);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><blockquote>
<p>多线程具有异步性。线程同步的主要任务是使并发执行的各线程之间能够有效的共享资源和相互合作，从而使程序的执行具有可再现性。<strong>同步包括互斥，互斥是一种特殊的同步。</strong></p>
</blockquote>
<h5 id="事件Event"><a href="#事件Event" class="headerlink" title="事件Event"></a>事件Event</h5><ul>
<li>CreateEvent</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span><br><span class="line">         LPSECURITY_ATTRIBUTES lpEventAttributes,</span><br><span class="line">         BOOL bManualReset,</span><br><span class="line">         BOOL bInitialState,</span><br><span class="line">         LPCTSTR lpName</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：  </p>
<ol>
<li>设定安全结构，默认NULL不能继承句柄。</li>
<li>确定事件为手动置位还是自动置位，TRUE表示手动置位，FALSE表示自动置位。自动置位时，对该事件调用WaitForSingleObject()后会自动调用ResetEvent()使事件变成未触发状态。</li>
<li>表示事件的初始状态，TRUR表示已触发。</li>
<li>事件名称，NULL表示匿名事件。</li>
</ol>
<ul>
<li>OpenEvent</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenEvent</span><span class="params">(</span><br><span class="line">         DWORD dwDesiredAccess,</span><br><span class="line">         BOOL bInheritHandle,</span><br><span class="line">         LPCTSTR lpName</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ol>
<li>访问权限，一般使用EVENT_ALL_ACCESS。</li>
<li>事件句柄继承性，一般为TRUE。</li>
<li>事件名称，不同进程中的线程使用名称访问同一事件。<ul>
<li>触发事件：<code>BOOL SetEvent(HANDLE hEvent);</code><br>重置事件：<code>BOOL ResetEvent(HANDLE hEvent);</code><br>销毁事件：<code>CloseHandle(HANDLE hEvent);</code>  </li>
<li>事件脉冲：<code>BOOL PulseEvent(HANDLE hEvent);</code><br>此函数相当于先调用SetEvent()再立刻调用ResetEvent()，对于手动置位事件，所有正处于等待状态下线程都变成可调度状态，对于自动置位事件，所有正处于等待状态下线程只有一个变成可调度状态。函数不稳定，因为在调用时无法确定哪些线程正处于等待状态下。</li>
</ul>
</li>
</ol>
<ul>
<li>Event同步的实例</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line">HANDLE _Lock;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">Test</span><span class="params">(<span class="keyword">void</span> *PM)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> name = *(<span class="keyword">int</span> *)PM;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"This is thread %d which name is %d\n"</span>, GetCurrentThreadId(), name);</span><br><span class="line">    	SetEvent(_Lock);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	HANDLE thrs[<span class="number">10</span>];</span><br><span class="line">    	_Lock = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);  <span class="comment">//自动置位</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    		thrs[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, Test, &amp;i, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    		WaitForSingleObject(_Lock, INFINITE);</span><br><span class="line">    	&#125;</span><br><span class="line">    	CloseHandle(_Lock);</span><br><span class="line">    	system(<span class="string">"pause"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h5><ul>
<li>CreateSemaphore</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,</span><br><span class="line">  LONG lInitialCount,</span><br><span class="line">  LONG lMaximumCount,</span><br><span class="line">  LPCTSTR lpName</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：  </p>
<ol>
<li>安全控制，NULL不能继承句柄。</li>
<li>初始资源数量。</li>
<li>最大并发数量。</li>
<li>信号量名称，NULL为匿名信号量。</li>
</ol>
<ul>
<li>OpenSemaphore</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenSemaphore</span><span class="params">(</span><br><span class="line">          DWORD dwDesiredAccess,</span><br><span class="line">          BOOL bInheritHandle,</span><br><span class="line">          LPCTSTR lpName</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：  </p>
<ol>
<li>访问权限，一般使用SEMAPHORE_ALL_ACCESS。</li>
<li>信号量句柄继承性，一般使用TRUE。</li>
<li>名称。</li>
</ol>
<ul>
<li>ReleaseSemaphore</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseSemaphore</span><span class="params">(</span><br><span class="line">  HANDLE hSemaphore,</span><br><span class="line">  LONG lReleaseCount,  </span><br><span class="line">  LPLONG lpPreviousCount </span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：  </p>
<ol>
<li>信号量句柄。</li>
<li>资源增加个数，大于0，且不超过最大资源数。</li>
<li>用于传出之前的资源计数，NULL为不传出。当前资源数量大于0，表示信号量触发，等于0表示资源耗尽，信号量处于末触发。对信号量调用等待函数时，等待函数会检查信号量的当前资源计数，若大于0，减1后调用线程继续执行。<strong>一个线程可以多次调用等待函数来减小信号量。</strong></li>
</ol>
<ul>
<li>实例：<a href="http://www.cnblogs.com/moodlxs/archive/2012/02/13/2349128.html" target="_blank" rel="external">Dijkstra生产者消费者问题</a></li>
</ul>
<h4 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h4><blockquote>
<p>多个线程必然共享某种资源，线程A在使用某资源时，其它需要使用该资源的线程都要等待。<strong>在一段时间内只允许一个线程访问的资源称为临界资源或独占资源</strong>，计算机中大多数物理设备，进程中的共享变量等待都是临界资源，它们要求被互斥的访问。<strong>进程中访问临界资源的代码称为临界区</strong>。（介绍来自MoreWindows）</p>
</blockquote>
<h5 id="原子操作Interlocked"><a href="#原子操作Interlocked" class="headerlink" title="原子操作Interlocked"></a>原子操作Interlocked</h5><ul>
<li><p>参数自增：<code>LONG__cdeclInterlockedIncrement(LONG volatile* Addend);</code>  </p>
</li>
<li><p>参数自减：<code>LONG__cdeclInterlockedDecrement(LONG volatile* Addend);</code>  </p>
</li>
<li><p><code>LONG__cdec InterlockedExchangeAdd(LONG volatile* Addend, LONG Value);</code><br>反回运算后的值，第二个参数正负代表加减</p>
</li>
<li><code>LONG__cdeclInterlockedExchange(LONG volatile* Target, LONG Value);</code><br>返回<strong>原来的值</strong>，value为新值</li>
<li><p>原子操作部分来自《<a href="http://blog.csdn.net/morewindows/article/details/7429155" target="_blank" rel="external">MoreWindows：原子操作 Interlocked系列函数</a>》，其中对例子中出错的原理解释有问题，原博中对自增语句的三条汇编代码进行了分析：  </p>
<blockquote>
<p>第一条汇编将变量的值从内存中读取到寄存器中，第二条汇编将寄存器中的值与1相加，计算结果仍存入寄存器中，第三条汇编将寄存器中的值写回内存中。由于线程执行的并发性，很可能线程A执行到第二局时，线程B开始执行，线程B将原来的值又写入寄存器中，这样线程A所主要计算的值就被线程B修改了。</p>
</blockquote>
<p>实际上，<strong>线程有自己独立的寄存器集合，切换线程时会保护现场</strong>。真正的原因可能是：1.假如A执行到第二句切换到B，B执行结束后继续执行A，寄存器会恢复到A的值，将B覆盖。 2.A和B读取了同一个值，自增操作后存入内存，相当于只执行了一次。</p>
</li>
</ul>
<h5 id="关键段CRITICAL-SECTION"><a href="#关键段CRITICAL-SECTION" class="headerlink" title="关键段CRITICAL_SECTION"></a>关键段CRITICAL_SECTION</h5><ul>
<li>Init：<code>void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);</code><br>销毁：<code>void DeleteCriticalSection(LPCRITICAL_SECTION  lpCriticalSection);</code><br>进入：<code>void EnterCriticalSection(LPCRITICAL_SECTION  lpCriticalSection);</code><br>离开：<code>void LeaveCriticalSection(LPCRITICAL_SECTION  lpCriticalSection);</code>  </li>
<li>CS关键段<strong>仅可用于互斥，不可用于同步</strong>。其在WinNT.h中声明，结构体定义为：  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _RTL_CRITICAL_SECTION &#123;</span><br><span class="line">        PRTL_CRITICAL_SECTION_DEBUG DebugInfo;</span><br><span class="line">        LONG LockCount;</span><br><span class="line">        LONG RecursionCount;</span><br><span class="line">        HANDLE OwningThread;</span><br><span class="line">        HANDLE LockSemaphore;</span><br><span class="line">        DWORD SpinCount;</span><br><span class="line">    &#125;RTL_CRITICAL_SECTION,*PRTL_CRITICAL_SECTION;</span><br></pre></td></tr></table></figure>
<p>其中，第四个参数<strong>HANDLE OwningThread记录允许进入关键段的线程句柄</strong>，第三个参数RecursionCount表示拥有这个关键段的访问权限的线程对此关键段的获得次数，<strong>如果OwingThread记录的线程再次进入，EnterCriticalSection()函数会更新RecursionCount记录该线程进入的次数，并且立即让该线程进入。</strong>此时其它线程调用EnterCriticalSection()会被切换到等待状态，当LeaveCriticalSection()至当前拥有访问权限的线程进入次数为0时，系统会自动更新关键段并将等待中的线程换回可调度状态。</p>
<ul>
<li>配合使用的旋转锁<br>线程在访问和等待间切换需要较大开销，在EnterCriticalSection()时如果需要等待，线程会先使用spinlock循环一段时间，在此期间如果仍未获得进入权限才会被切换到等待状态。   <ol>
<li>另一种初始化关键段方法：  </li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InitializeCriticalSectionAndSpinCount</span><span class="params">(</span><br><span class="line">          LPCRITICAL_SECTION lpCriticalSection,</span><br><span class="line">          DWORD dwSpinCount</span><br><span class="line">          )</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>修改关键段的旋转锁次数：  </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SetCriticalSectionSpinCount</span><span class="params">(</span><br><span class="line">          LPCRITICAL_SECTION lpCriticalSection,</span><br><span class="line">          DWORD dwSpinCount)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个关键段互斥举例  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line">CRITICAL_SECTION  _Lock;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">stdcall <span class="title">Test</span><span class="params">(<span class="keyword">void</span> *PM)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">char</span> name = *(<span class="keyword">char</span>*)PM;</span><br><span class="line">    	<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    		EnterCriticalSection(&amp;_Lock);</span><br><span class="line">    		<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">	       		<span class="built_in">printf</span>(<span class="string">"Thread:%c\n Leaves:%d\n"</span>,name, tickets--);</span><br><span class="line">	    	LeaveCriticalSection(&amp;_Lock);</span><br><span class="line">	    	Sleep(<span class="number">100</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	InitializeCriticalSection(&amp;_Lock);</span><br><span class="line">    	<span class="keyword">char</span> tar[<span class="number">2</span>] = &#123; <span class="string">'A'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">    	HANDLE _handleT[<span class="number">2</span>];</span><br><span class="line">    	_handleT[<span class="number">0</span>] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, Test, tar, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    	_handleT[<span class="number">1</span>] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, Test, tar+<span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    	WaitForMultipleObjects(<span class="number">2</span>, _handleT, TRUE, INFINITE);</span><br><span class="line">    	DeleteCriticalSection(&amp;_Lock);</span><br><span class="line">    	system(<span class="string">"pause"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="互斥量Mutex"><a href="#互斥量Mutex" class="headerlink" title="互斥量Mutex"></a>互斥量Mutex</h5><ul>
<li><p>CreateMutex  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">(</span><br><span class="line">          LPSECURITY_ATTRIBUTES lpMutexAttributes,</span><br><span class="line">          BOOL bInitialOwner,</span><br><span class="line">          LPCTSTR lpName</span><br><span class="line">        )</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：   </p>
<ol>
<li>第一个参数是安全结构，默认NULL不能继承句柄。  </li>
<li>第二个参数为FALSE时创建Mutex时不指定所有权，若为TRUE则指定为当前的创建线程ID为所有者，其他线程访问需要先ReleaseMutex。</li>
<li>第三个参数用于设置Mutex名，为NULL时表示是匿名互斥量。</li>
</ol>
</li>
<li><p>OpenMutex  </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenMutex</span><span class="params">(</span><br><span class="line">         DWORD dwDesiredAccess,</span><br><span class="line">         BOOL bInheritHandle,</span><br><span class="line">         LPCTSTR lpName</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：  </p>
<ol>
<li>访问权限，一般使用MUTEX_ALL_ACCESS。  </li>
<li>互斥量句柄继承性，多为TRUE。  </li>
<li>名称。一个进程中的线程创建互斥量后，其它进程中的线程可以通过该函数来使用该互斥量。</li>
</ol>
<ul>
<li>请求一个互斥量的访问权：WaitForSingleObject()<br>释放一个互斥量的访问权：ReleaseMutex()<br>销毁互斥量：CloseHandle()  </li>
<li>互斥量是内核对象，和关键段一样，mutex会记录线程访问权限，因此<strong>mutex不能用于线程的同步</strong>。但互斥量可以处理多进程间各个线程的互斥，可以处理遗弃情况：当当前某个占有互斥量的线程在触发互斥量之前意外中止（遗弃），系统会自动将互斥量内部储存占有该互斥量的线程ID重置为0，并且递归计数器重置为0，选择一个等待状态的线程进行调度，此时这个被选中的线程的WaitForSingleObject()会返回WAIT_ABANDONED_0。</li>
</ul>
<h3 id="Linux下的多线程pthread-t"><a href="#Linux下的多线程pthread-t" class="headerlink" title="Linux下的多线程pthread_t"></a>Linux下的多线程pthread_t</h3><h4 id="库函数和编译脚本"><a href="#库函数和编译脚本" class="headerlink" title="库函数和编译脚本"></a>库函数和编译脚本</h4><blockquote>
<p>pthread.h<br>  gcc/g++ filename.c/cpp -o thread -lpthread<br>  遵循POSIX线程接口</p>
</blockquote>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><ul>
<li>pthread_create</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(</span><br><span class="line">        pthread_t *thread,</span><br><span class="line">        pthread_attr_t *attr,</span><br><span class="line">        void *(*func)(void*),</span><br><span class="line">        void *arg</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<p>参数解释：  </p>
<ol>
<li>func为指向新线程运行函数的指针。</li>
<li>arg为传给func的参数。</li>
<li>返回值为0表示成功，错误返回errcode。</li>
</ol>
<h4 id="线程等待和结束"><a href="#线程等待和结束" class="headerlink" title="线程等待和结束"></a>线程等待和结束</h4><ul>
<li>pthread_join 用来等待一个线程结束<br><code>int pthread_join(pthread_t thread,void ** retval);</code><br>其中thread为等待的进程，retval指向一个存储返回值的变量。一个线程不能被多个线程等待，否则第一个接收到信号的线程会成功返回，其它线程返回错误代码ESRCH。</li>
<li>pthread_exit<br><code>extern void pthread_exit __P ((void *__retval)) __attribute__ ((__noreturn__));</code><br>调用此函数线程自发结束</li>
<li>被动结束pthread_cancel<br><code>int pthread_cancel(pthread_t thread);</code><br>此函数调用成功返回0</li>
</ul>
<h4 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a>线程同步</h4><h5 id="互斥量pthread-mutex-t"><a href="#互斥量pthread-mutex-t" class="headerlink" title="互斥量pthread_mutex_t"></a>互斥量pthread_mutex_t</h5><ul>
<li>初始化  <ol>
<li>赋值为常量PTHREAD_MUTEX_INITIALIZER  </li>
<li>动态分配，pthread_mutex_init函数<br><code>int pthread_mutex_init (pthread_mutex_t *__mutex,__const pthread_mutexattr_t *__mutexattr);</code></li>
</ol>
</li>
<li>销毁 <code>int pthread_mutex_destroy (pthread_mutex_t *__mutex);</code></li>
<li>上锁和解锁  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">(pthread_mutex_t *__mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">(pthread_mutex_t *__mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul>
<li>适用：允许多个线程同时读取，但只能有一个线程写入。适用于读的次数远大于写的情况。</li>
<li>初始化和销毁  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(pthread_rwlock_t *__restrict __rwlock,__const pthread_rwlockattr_t *__restrict __attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(pthread_rwlock_t *__rwlock)</span></span>;</span><br></pre></td></tr></table></figure>
<p>成功返回值为0，否则为错误代码。</p>
<ul>
<li>加锁和解锁  <ol>
<li>读加锁：<code>int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)</code></li>
<li>写加锁：<code>int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)</code></li>
<li>解锁：<code>int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)</code>，读写均用此函数</li>
</ol>
</li>
</ul>
<h5 id="条件变量pthread-cond-t"><a href="#条件变量pthread-cond-t" class="headerlink" title="条件变量pthread_cond_t"></a>条件变量pthread_cond_t</h5><blockquote>
<p>一篇简洁的介绍《<a href="http://blog.csdn.net/hiflower/article/details/2195350" target="_blank" rel="external">Linux线程同步-条件变量</a>》<br>和一段具体的使用了mutex和cond的代码《<a href="http://blog.csdn.net/hubi0952/article/details/8039604" target="_blank" rel="external">linux 多线程（条件变量） </a>》</p>
</blockquote>
<hr>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="创建线程-1"><a href="#创建线程-1" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul>
<li>构造方法  <ol>
<li><code>Thread();</code></li>
<li><code>Thread(Runnable target);</code></li>
<li><code>Thread(Runnable target,String name);</code></li>
<li><code>Thread(String name);</code><br>具体方法见 <a href="http://pan.baidu.com/s/1mg5rwPa" target="_blank" rel="external"> JDK API 1.6（百度网盘）</a></li>
</ol>
</li>
<li>启动：<code>void start();</code></li>
<li>休眠：<code>static void sleep();</code></li>
<li>礼让：<code>static void yield();</code></li>
<li>详细方法见JDK API。</li>
</ul>
<h3 id="线程同步-2"><a href="#线程同步-2" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><ul>
<li>对方法使用synchronized关键字修饰。java的每个对象都含有一个内置锁，使用此关键字修饰时内置锁会保护整个方法。<br><code>public synchronized void methodname(){}</code><br>调用方法前需要获得内置锁，否则处于阻塞状态。</li>
<li>可以修饰静态方法，此时调用静态方法会锁住整个类。</li>
<li><a href="http://blog.csdn.net/yaerfeng/article/details/7254734" target="_blank" rel="external">synchronized不同地方的使用方法</a></li>
</ul>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul>
<li>使用synchronized关键字修饰代码块。<br><code>synchronized(object){}</code><br>同步操作开销较高，要尽量减少同步内容，通常同步关键代码块。</li>
</ul>
<h4 id="特殊域变量volatile"><a href="#特殊域变量volatile" class="headerlink" title="特殊域变量volatile"></a>特殊域变量volatile</h4><ul>
<li>volatile关键字为域变量提供了一种免锁机制。使用该关键字时等于告诉虚拟机此域可能被其他线程更新，每次使用该域需要重新计算，不能使用寄存器中的值。</li>
<li>在需要同步的变量前加上volatile，不能修饰final变量。</li>
</ul>
<h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><ul>
<li>JavaSE5.0中加入java.util.concurrent。<br>常用方法：<br><code>ReentrantLock()</code><br><code>lock()</code><br><code>unlock()</code>  </li>
<li>示例：  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> origin = <span class="number">10</span>;</span><br><span class="line">         <span class="keyword">private</span> Lock xlock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">             xlock.lock();</span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                 origin--;</span><br><span class="line">             &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                 xlock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><ul>
<li>使用空间换时间的方式，为每个线程创建一个变量副本。</li>
<li>常用方法：<code>ThreadLocal()</code>,<code>get()</code>,<code>initialValue()</code>,set(T value)`，分别用于：创建一个线程本地变量，返回此线程当前副本中的值，返回副本初始值和设置当前副本值为value。</li>
<li>示例：  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; origin = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">protected</span> Integer <span class="title">initivalValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">             origin.set(origin.get()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        <span class="comment"># your code</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># your code</span></span><br><span class="line">instance = YourThread()</span><br><span class="line">instance.start()</span><br></pre></td></tr></table></figure>
<hr>
<p>原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章<a href="https://forec.github.io/2015/08/18/多线程编程备忘/">原始出处</a>(<a href="https://forec.github.io/2015/08/18/多线程编程备忘/">https://forec.github.io/2015/08/18/多线程编程备忘/</a>) 、作者信息（<a href="https://forec.github.io/">Forec</a>）和本声明。</p>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://forec.github.io/2015/08/18/多线程编程备忘/" data-id="cixmznkbm000g8oew5ozktxjx" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div class="ds-thread" data-thread-key="2015/08/18/多线程编程备忘/" data-title="多线程编程备忘" data-url="http://forec.github.io/2015/08/18/多线程编程备忘/"></div>
    <style>
        #ds-thread #ds-reset .ds-textarea-wrapper {
            background: none;
        }
        #ds-reset .ds-avatar img {
            box-shadow: none;
        }
        #ds-reset .ds-gradient-bg {
            background: #f7f7f7;
        }
        #ds-thread #ds-reset li.ds-tab a {
            border-radius: 3px;
        }
        #ds-thread #ds-reset .ds-post-button {
            color: white;
            border: none;
            box-shadow: none;
            background: #d32;
            text-shadow: none;
            font-weight: normal;
            font-family: 'Microsoft Yahei';
        }
        #ds-thread #ds-reset .ds-post-button:hover {
            color: white;
            background: #DE594C;
        }
        #ds-thread #ds-reset .ds-post-button:active {
            background: #d32;
        }
        #ds-smilies-tooltip ul.ds-smilies-tabs li a.ds-current {
            color: white;
            background: #d32;
            box-shadow: none;
            text-shadow: none;
            font-weight: normal;
        }
    </style>

    
    </section>

                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/Forec" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="google-plus-circle" href="https://plus.google.com/u/0/103559279723380829001" target="_blank">
                        <i class="icon fa fa-google-plus-circle"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="https://www.facebook.com/MrForec" target="_blank">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="twitter" href="https://twitter.com/MrForec" target="_blank">
                        <i class="icon fa fa-twitter"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="/atom.xml" target="_blank">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="mail-forward" href="mailto:forec@bupt.edu.cn" target="_blank">
                        <i class="icon fa fa-mail-forward"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2015/09/07/九月计划/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            九月计划
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2015/08/14/ANSI-Unicode备忘/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">Angry 的编码问题</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/01/06/os-concepts-13/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xktmz.com1.z0.glb.clouddn.com/os-concepts-13.jpg)" alt="操作系统（十三）：I/O 输入系统" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/计算机理论基础/">计算机理论基础</a></p>
                            <p class="item-title"><a href="/2017/01/06/os-concepts-13/" class="title">操作系统（十三）：I/O 输入系统</a></p>
                            <p class="item-date"><time datetime="2017-01-06T04:17:33.000Z" itemprop="datePublished">2017-01-06</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/01/05/os-concepts-12/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xktmz.com1.z0.glb.clouddn.com/os-concepts-12.jpg)" alt="操作系统（十二）：大容量存储器结构" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/计算机理论基础/">计算机理论基础</a></p>
                            <p class="item-title"><a href="/2017/01/05/os-concepts-12/" class="title">操作系统（十二）：大容量存储器结构</a></p>
                            <p class="item-date"><time datetime="2017-01-05T15:23:30.000Z" itemprop="datePublished">2017-01-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/12/03/zenith-cloud-7/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xktmz.com1.z0.glb.clouddn.com/zenith-cloud-7.png)" alt="顶点云（应用）用户代理" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Code/">Code</a></p>
                            <p class="item-title"><a href="/2016/12/03/zenith-cloud-7/" class="title">顶点云（应用）用户代理</a></p>
                            <p class="item-date"><time datetime="2016-12-03T13:44:07.000Z" itemprop="datePublished">2016-12-03</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/11/30/efficient-haskell-io/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xktmz.com1.z0.glb.clouddn.com/efficient-haskell-io.jpg)" alt="Haskell 中的高效 I/O" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Language/">Language</a></p>
                            <p class="item-title"><a href="/2016/11/30/efficient-haskell-io/" class="title">Haskell 中的高效 I/O</a></p>
                            <p class="item-date"><time datetime="2016-11-30T14:54:30.000Z" itemprop="datePublished">2016-11-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/11/24/os-concepts-7/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xktmz.com1.z0.glb.clouddn.com/os-concepts-7.jpg)" alt="操作系统（七）：死锁" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/计算机理论基础/">计算机理论基础</a></p>
                            <p class="item-title"><a href="/2016/11/24/os-concepts-7/" class="title">操作系统（七）：死锁</a></p>
                            <p class="item-date"><time datetime="2016-11-24T14:16:22.000Z" itemprop="datePublished">2016-11-24</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Code/">Code</a><span class="category-list-count">27</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Configuration/">Configuration</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Language/">Language</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机理论基础/">计算机理论基础</a><span class="category-list-count">15</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Access/" style="font-size: 10px;">Access</a> <a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/CVM/" style="font-size: 10px;">CVM</a> <a href="/tags/Data-Structures/" style="font-size: 11.82px;">Data-Structures</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Emacs/" style="font-size: 10px;">Emacs</a> <a href="/tags/Golang/" style="font-size: 16.36px;">Golang</a> <a href="/tags/Hadoop/" style="font-size: 10.91px;">Hadoop</a> <a href="/tags/Haskell/" style="font-size: 13.64px;">Haskell</a> <a href="/tags/Mistakes/" style="font-size: 12.73px;">Mistakes</a> <a href="/tags/OS/" style="font-size: 19.09px;">OS</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Qt/" style="font-size: 10px;">Qt</a> <a href="/tags/Raspberry/" style="font-size: 10px;">Raspberry</a> <a href="/tags/Safety/" style="font-size: 10px;">Safety</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/sicp/" style="font-size: 10.91px;">sicp</a> <a href="/tags/云存储/" style="font-size: 15.45px;">云存储</a> <a href="/tags/函数式编程/" style="font-size: 14.55px;">函数式编程</a> <a href="/tags/图分割/" style="font-size: 10.91px;">图分割</a> <a href="/tags/字符编码/" style="font-size: 10.91px;">字符编码</a> <a href="/tags/机器学习/" style="font-size: 18.18px;">机器学习</a> <a href="/tags/线程/" style="font-size: 17.27px;">线程</a> <a href="/tags/计组与体系结构/" style="font-size: 13.64px;">计组与体系结构</a>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://forec.cn">Forec的官方网站</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>京ICP备16060806号-1 &copy; 2017 Forec</p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'forec'};
    (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js" type="text/javascript"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js" type="text/javascript"></script>
    


<!-- Custom Scripts -->
<script src="/js/main.js" type="text/javascript"></script>

    </div>
</body>
</html>
