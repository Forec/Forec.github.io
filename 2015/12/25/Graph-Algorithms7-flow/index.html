<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>最大流（一） | Forec的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="简述最大流问题，给出一种解决最大流的最简单方法，及在二分图匹配中的应用。">
<meta property="og:type" content="article">
<meta property="og:title" content="最大流（一）">
<meta property="og:url" content="http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/index.html">
<meta property="og:site_name" content="Forec的博客">
<meta property="og:description" content="简述最大流问题，给出一种解决最大流的最简单方法，及在二分图匹配中的应用。">
<meta property="og:image" content="http://7xktmz.com1.z0.glb.clouddn.com/%E6%9C%80%E5%A4%A7%E6%B5%81.jpg">
<meta property="og:updated_time" content="2015-12-25T12:10:07.334Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="最大流（一）">
<meta name="twitter:description" content="简述最大流问题，给出一种解决最大流的最简单方法，及在二分图匹配中的应用。">
  
    <link rel="alternative" href="/atom.xml" title="Forec的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xktmz.com1.z0.glb.clouddn.com/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Forec</a></h1>
		</hgroup>

		
		<p class="header-subtitle">奋斗在Code World的在校生</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/forec" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/forect" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto://forec@bupt.edu.cn" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/Data-Structures/" style="font-size: 13.33px;">Data-Structures</a> <a href="/tags/Mistakes/" style="font-size: 10px;">Mistakes</a> <a href="/tags/OS/" style="font-size: 10px;">OS</a> <a href="/tags/字符编码/" style="font-size: 10px;">字符编码</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/计算机组成与体系结构/" style="font-size: 16.67px;">计算机组成与体系结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://fallenwood.github.io">Fallenwood的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.codewars.com/users/Forec">Forec的CodeWars</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">就读于北京邮电大学，代码爱好者。近期自学机器学习。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Forec</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xktmz.com1.z0.glb.clouddn.com/%E5%A4%B4%E5%83%8F.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Forec</h1>
			</hgroup>
			
			<p class="header-subtitle">奋斗在Code World的在校生</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/forec" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/forect" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto://forec@bupt.edu.cn" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Graph-Algorithms7-flow" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/25/Graph-Algorithms7-flow/" class="article-date">
  	<time datetime="2015-12-25T00:43:42.000Z" itemprop="datePublished">2015-12-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      最大流（一）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/">Algorithms</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Code/">Code</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>简述最大流问题，给出一种解决最大流的最简单方法，及在二分图匹配中的应用。</p>
</blockquote>
<a id="more"></a>
<h1 id="u6D41_u7F51_u7EDC"><a href="#u6D41_u7F51_u7EDC" class="headerlink" title="流网络"></a>流网络</h1><ul>
<li>流网络G=（V，E）是一个有向图，E中的每条边（u，v）均有一个非负容量c（u，v）&gt;=0，对于不属于E中的边（u，v），则c（u，v）=0。流网络中有源点s和汇点t，方便起见假设每个顶点都处在从源点s到汇点t的某条路径上，也就是说对每个V中的顶点v，都有s～&gt;v~&gt;t的路径存在。因此，图G为连通图，并且|E|&gt;=|V|-1。流网络具备三个基本性质。<ul>
<li>容量限制：对于所有V中的顶点u,v，都有f(u,v) &lt;= c(u,v)。</li>
<li>反对称性：对于所有V中的顶点u,v，都有f(u,v) = -f(v,u)。</li>
<li>流守恒性：对所有V中的非s、t顶点u，都有Sum{ f(u,v)，v为V中全部顶点 }= 0。<br>f(u,v)称为从顶点u到顶点v的流，它可以为正、负或零。流f的值的定义为|f| = Sum{ f(s,v)，v为V中所有顶点 }，也就是从源点s出发的总流量，|f|表示流的值，而不是绝对值。</li>
</ul>
</li>
<li>流网络性质的解释：容量限制说明从一个顶点到另一个顶点的网络流不能超过设定的容量。反对称性说明从顶点u到顶点v的流是其反向流的负值。流守恒性说明从非源点或非汇点的顶点出发的总网络流为0，也可以说，除s和t外，进入一个顶点的总流为0，可以阐述为流进等于流出。</li>
<li>最大流问题：给出一个具有源点s和汇点t的流网络G，找出从s到t的最大流值。举个例子说明，下图是一个简单的流网络，从源点s到汇点t的最大流为5，将有向边想象成城市间的公路，该流网络就转化为城市间的物流问题。另外，图中不存在双向边，假如为图中权值为6的有向边配备一条“反向通道”，该反向通道的权值为3，也就是城市间可以相互运输，则可以利用<strong>抵消处理</strong>将反向通道剔除。因为运输同一种物品，从u到v运送6个，从v到u运送3个，实质相当于从u到v运送6-3=3个，因此任意顶点间流传输问题都可以通过抵消转化为单向传输问题：只沿正向流的方向传输。<img src="http://7xktmz.com1.z0.glb.clouddn.com/%E6%9C%80%E5%A4%A7%E6%B5%81.jpg" width="200px"></li>
<li>多个源点或多个汇点：考虑上一篇差分约束系统，我们通过构造了一个额外的源点s0得到了差分约束系统的最短路模型。在最大流问题中，如果出现多个源点或者多个汇点，可以为其增加一个超级源点s0或超级汇点t0,并将s0和所有源点si相连，权值为正无穷，将所有汇点ti和超级汇点t0相连，权值为正无穷。问题就转化为从超级源点s0到超级汇点t0的最大流问题。</li>
<li>隐含求和记号简化流网络的表达：使用函数f，f的任意自变量都可以是顶点的集合，表示的值为自变量代表的元素所有可能求和情况，例如f(X,Y) = Sum{ f(x,y) ，x in X and y in Y }。因此流守恒可以表示为f(u,V) = 0，流的值|f| = f(s,V) = f(V,t)。对于下面几个恒等式，建议参考基尔霍夫第一第二定律证明。（1）对于所有的X包含于V，f(X, X) = 0，（2）对所有X，Y包含于V，f(X, Y) = -f(Y,X)，（3）对所有X,Y,Z包含于V，其中X and Y = None，有<code>f(X or Y, Z) = f(X, Z)+f(Y, Z)</code>，<code>f(Z, X or Y) = f(Z, X)+f(Z, Y)</code>。</li>
</ul>
<h1 id="Ford-Fulkerson_u65B9_u6CD5"><a href="#Ford-Fulkerson_u65B9_u6CD5" class="headerlink" title="Ford-Fulkerson方法"></a>Ford-Fulkerson方法</h1><h2 id="u65B9_u6CD5_u89E3_u91CA_u548C_u5B9A_u7406"><a href="#u65B9_u6CD5_u89E3_u91CA_u548C_u5B9A_u7406" class="headerlink" title="方法解释和定理"></a>方法解释和定理</h2><ul>
<li><p>最大流问题的Ford-Fulkerson方法包含多种不同运行时间的实现，其依赖于三种流网络中常见的思想：残留网络（residual network），增广路径（augmenting path）和割（cut）。Ford-Fulkerson方法是一种迭代方法，开始时对所有V中的u，v有f(u,v)=0，即初始状态时流的值为0。每次迭代可以通过寻找一条“增广路径”来增加流值。增广路径时从源点s到汇点t的一条路径，沿着该路径可以向现有流量压入更多流值。反复进行该过程，直到所有增广路径都被寻找出。后面将证明算法的正确性。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">FORD-FULKERSON-METHORD</span><span class="params">(G, s, t)</span></span></span><br><span class="line">	initialize flow f to <span class="number">0</span></span><br><span class="line">	while there exists an augmenting path <span class="tag">p</span></span><br><span class="line">		do augment flow f along <span class="tag">p</span></span><br><span class="line">	return f</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>残留网络</strong>：给定一个流网络G和一个流f，该流网络在此流基础上的残留网络Gf由可以容纳更多网络流的边组成。举例来说，有一个流网络G=（V,E），源点s汇点t，设f是G中的一个流，考察V中一对顶点u，v，在不超过容量c(u,v)的条件下，从u到v可以压入额外的网络流量，就是(u,v)的残留容量，即<code>cf(u,v) = c(u,v) - f(u,v)</code>。在残留网络Gf中，每条残留边都能容纳一个严格为正的网络流。定义Ef为残留网络的边集，Ef中的边既可以是E中的边，也可以是它们的反向边。如果E中存在边（u，v）并且f(u,v)<c(u,v)，则cf(u,v) =="" c(u,v)-f(u,v)=""> 0，并且若f(u,v)&gt;0，则f(v,u)<0，此时cf(v,u) =="" c(v,u)="" -="" f(v,u)="">0，因此(u,v)的反向边(v,u)也存在于Ef中。对于一对顶点(u,v)，只有在初始网络中存在连接两个顶点的边，则残留网络中才能出现连接这两点的边，因此|Ef| &lt;= 2|E|。残留网络中的流和初始网络中的流的关系为|f+f’| = |f|+|f’|。</0，此时cf(v,u)></c(u,v)，则cf(u,v)></p>
</li>
<li><strong>增广路径</strong>：增广路径p是残留网络Gf中从s到t的一条简单路径，增广路径上的每条边(u, v)可以容纳从u到v的某额外正网络流。称能够沿一条增广路径p的每条边传输的网络流的最大量为p的残留容量，cf(p) = min{ cf(u,v), (u,v) in p }。在已有流f的基础上加上fp，则可以得到G的另一个流，且新流的流值更接近最大值，因为|fp|为正，|f| + |fp|&gt;|f|。</li>
<li><strong>流网络的割</strong>：Ford-Fulkerson方法沿增广路径反复增加流，直到找到最大流。流网络G=(V,E)的割（S，T）将V划分为S和T=V-S两部分，这里的划分类似于最小生成树中的点集划分，但此处针对的是有向图而非无向图。对于一个流f，穿过割（S，T）的净流量被定义为f(S,T)，割(S,T)的容量为c(S, T)，一个网络的最小割是网络中所有割中具有最小容量的割。对于最大流问题介绍中的图片，假如将左侧的s和距离其最近的顶点划分为S，剩下的两个顶点（含t）划分为T，则通过该割的<strong>净流量</strong>为2+3=5，2是图中最顶部顶点向t提供的流，3是s向图中最底部顶点提供的流。该割的<strong>容量</strong>为3+1+6=10。通过割的净流量可能包括顶点间的负网络流，但割的容量完全由非负值组成，即通过割（S，T）的净流由双向的正网络流组成，用从S到T的正网络流减去从T到S的正网络流；而割（S，T）的容量仅由从S到T的边计算而得，从T到S的边在计算c（S，T）时不包含在内。可以证明，<strong>流经任意割的净流都是相同的，且f(S,T) = |f|</strong>。证明如下：根据流守恒性，f(S-s,V) = 0，因此f(S,T) = f(S,V)-f(S,S) = f(S,V) = f(s,V)+f(S-s,V) = f(s,V) = |f|。还可以证明，<strong>对一个流网络G中任意流f来说，其值的上界为G的任意割的容量</strong>，即|f|=f(S, T) = Sum{ f(u, v), u in S, v in T } &lt;= Sum{ c(u, v), u in S, v in T } = c(S，T)。从该式可以直接得出一个结论，<strong>网络的最大流必定不超过此网络最小割的容量</strong>。</li>
<li><strong>最大流最小割定理</strong>：如果f是具有源点s和汇点t的流网络G=（V，E）中的一个流，则下列条件等价：（1）f是G的一个最大流，（2）残留网络Gf不包含增广路径，（3）对G的某个割（S，T），有|f|=c（S，T）。结合上面提到的网络的最大流不超过此网络最小割的容量，可以得出<strong>网络的最大流等于某一最小割的容量</strong>。证明如下。<ul>
<li>(1)-&gt;(2)：假设f是G的最大流，而Gf包含一条增广路径p，因此流的和f+fp是G的一个流，并且由增广路径的定义，f+fp的流值严格大于|f|，这与假设矛盾。</li>
<li>(2)-&gt;(3)：假设Gf不包含增广路径，即Gf不包含从s到v的路径。定义S={ v in V且Gf中从s到v存在路径 }，T=V-S。对于这样的割（S，T），s在S中，t在T中，并且对每对顶点(u, v)，都有f(u,v) = c(u,v)，否则(u,v)属于Ef，v就属于了集合S，这和前提矛盾。因此|f| = f(S, T) = c(S, T)。</li>
<li>(3)-&gt;(1)：对所有割（S，T），都有f&lt;=c(S,T)，因此条件|f| = c(S, T)说明此时f是一个最大流。</li>
</ul>
</li>
</ul>
<h2 id="u57FA_u672C_u7684Ford-Fulkerson_u7B97_u6CD5_u5B9E_u73B0"><a href="#u57FA_u672C_u7684Ford-Fulkerson_u7B97_u6CD5_u5B9E_u73B0" class="headerlink" title="基本的Ford-Fulkerson算法实现"></a>基本的Ford-Fulkerson算法实现</h2><ul>
<li><p>在Ford-Fulkerson方法的每次迭代中，找出任意增广路径p，并把沿p每条边的流f加上其残留容量cf（p）。下面的实现中，通过更新有边相连的每对顶点间的网络流来计算最大流。如果一对顶点间在任意方向都没有边相连，则隐含假设该对顶点间的f = 0。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FORD-FULKERSON(<span class="keyword">G</span>, s, t)</span><br><span class="line">	<span class="keyword">for</span> each edge(<span class="keyword">u</span>, v) <span class="keyword">in</span> <span class="literal">E</span>(<span class="keyword">G</span>):</span><br><span class="line">		f[<span class="keyword">u</span>][v] &lt;- 0</span><br><span class="line">		f[v][<span class="keyword">u</span>] &lt;- 0</span><br><span class="line">	<span class="keyword">while</span> there exists a path p from s to t <span class="keyword">in</span> the residual network Gf:</span><br><span class="line">		<span class="keyword">cf</span>(p) &lt;- min&#123; <span class="keyword">cf</span>(<span class="keyword">u</span>, v): (<span class="keyword">u</span>, v) is <span class="keyword">in</span> p &#125;</span><br><span class="line">		<span class="keyword">for</span> each edge(<span class="keyword">u</span>, v) <span class="keyword">in</span> p:</span><br><span class="line">			f[<span class="keyword">u</span>][v] &lt;- f[<span class="keyword">u</span>][v] + <span class="keyword">cf</span>(p)</span><br><span class="line">			f[v][<span class="keyword">u</span>] &lt;- -f[<span class="keyword">u</span>][v]</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述基本实现方法，运行时间取决于如何确定第四行中的增广路径，如果选择不好，在边权有无理数的情况下算法可能不会终止：流的值随着求和运算不断增加，但始终无法收敛到流的最大值。若采用广度优先搜索来选择增广路径，则算法运行时间为多项式复杂度。通常情况下算法处理的问题中权值都为整数，如果是有理数可以按照一定比例转化为整数。在整数条件下，该种实现Ford-Fulkerson算法的运行时间为O(E|f<em>|)，其中f</em>是算法求出的最大流，原因在于第7行的循环为E次，寻找一条增广路径需要的深度优先搜索为E复杂度，而while最多执行f<em>次，每次至少增加流值1个单位。在f</em>较小时可以取得不错的运行效果，但当流网络中的最大流f*很大，例如我们将上面示例图中除了中间那条权值为1的边之外的其他边，权值都设为1000000，显然最大流为2000000,但增广路径会在权值为1的边上往返出现，因此一共要运行2000000×5次。</p>
</li>
</ul>
<h2 id="Edmonds-Karp_u7B97_u6CD5"><a href="#Edmonds-Karp_u7B97_u6CD5" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><ul>
<li>如果在第四行用BFS实现对增广路径p的计算，即若增广路径时残留网络中从s到t的最短路径（每条边设为单位距离），则能改进Ford-Fulkerson的界，该种实现方法为Edmonds-Karp算法，运行时间为O(VE^2)。令R（u，v）表示每条边为单位长度的图Gf中，从u到v的最短路径长度。下证时间复杂度。</li>
<li><strong>对具有源点s和汇点t的流网络G=（V，E）运行Edmonds-Karp算法，对所有非源非汇点顶点v，残留网络Gf中的最短路径长度R（u，v）随着每个流的增加而单调递增</strong>。假设这个顶点v的流增加引起了从s到v的最短路径的减少，下面会推出矛盾。假设f是第一次流增加之前的流，该增加导致了某个最短路径距离的减小；设f’时增加以后的流。设v是在流增加时最小距离Rf’（u，v）被减小的顶点，因此Rf’（s，v）&lt; Rf（s，v）。设p=s～&gt;u-&gt;v是Gf’中从s到v的最短路径，因此（u，v）在Ef’中，且Rf’（s，u）=Rf’（s，v）-1。顶点u到s的距离不会因为v的流增加而减小，因此Rf’（s，u）&gt;=Rf（s，u）。可以断言（u，v）不属于Ef，否则根据三角不等式有Rf（s，v）&lt;=Rf（s，u）+1 &lt;= Rf’（s，u）+1 = Rf’（s，v），这和假设Rf’（s，v）&lt;Rf(s,v)矛盾。因此，如果有（u，v）不在Ef中而在Ef’中，只有流从v向u增加。Edmonds-Karp算法总是沿着最短路径增加流，因此Gf中从s到u的最短路径以（v，u）作为最后一条边。因此Rf（s，v）=Rf（s，u）-1&lt;=Rf’（s，u）-1=Rf’（s，v）-2。因为开始假设Rf’（s，v）&lt;Rf（s，v），因此假设矛盾。</li>
<li><strong>对具有源点s和汇点t的一个流网络G=（V，E）运行Edmonds-Karp算法，对流进行增加的全部次数为O(VE)</strong>。在一个残留网络Gf中，如果其增广路径p的残留容量是边（u，v）的残留容量，即cf（p）=cf（u，v），称此边（u，v）对增广路径p关键。在沿增广路径p增流后，路径p上的任何关键边都从残留网络中消失。此外，任何增广路径上都至少有一条关键边。下证|E|条边中每一条都可以至多|V|/2-1次成为关键边。设u，v为V中顶点，且它们之间由E中的一条边相连，由于增广路径为最短路径，因此（u，v）第一次作为关键边时，有Rf（s，v）=f（s，u）+1。一旦对流增加，边（u，v）立刻从残留网络中消失，直到从v到u的边出现增流，才会使（u，v）再次出现在增广路径上。假设此时G的流为f’，则Rf’（s，u）=Rf’（s，v）+1，又Rf（s，v）&lt;=Rf’（s，v），得Rf’（s，u）=Rf’（s，v）+1&gt;=Rf（s，v）+1=Rf（s，u）+2。因此对于边（u，v），从其成为关键边到再次成为关键边，源点到u的最短距离至少增加2，初始时从源点到u的距离至少为0。因此在u变为从s不可达之前，距离至多为|V|-2（排除s和t），因此在（u，v）第一次成为关键边后，至多还能成为关键边(|V|-2)/2次，总计至多|V|/2次。在残留网络中可能有O（E）对顶点间有边相连，因此全部关键边的数目规模为O（VE）。</li>
</ul>
<h2 id="Edmonds-Karp_u90BB_u63A5_u8868_u5B9E_u73B0"><a href="#Edmonds-Karp_u90BB_u63A5_u8868_u5B9E_u73B0" class="headerlink" title="Edmonds-Karp邻接表实现"></a>Edmonds-Karp邻接表实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> INF <span class="number">0x7fffffff</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N <span class="number">101</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">int</span> visited[N], pre[N];</span><br><span class="line"><span class="keyword">int</span> V, E, s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;V, &amp;E);</span><br><span class="line">	<span class="keyword">int</span> i, j, u, v, w;</span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; E; i++ )&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w );</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">map</span>[v][u] != <span class="number">0</span> )</span><br><span class="line">			<span class="built_in">map</span>[v][u] -= w;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="built_in">map</span>[u][v] = w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;s, &amp;t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cf</span><span class="params">( <span class="keyword">int</span> source, <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = end, min = INF;</span><br><span class="line">	<span class="keyword">while</span> ( p != source )&#123;</span><br><span class="line">		min = ( min &gt; <span class="built_in">map</span>[pre[p]][p] ? <span class="built_in">map</span>[pre[p]][p] : min );</span><br><span class="line">		p = pre[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">BFS</span><span class="params">( <span class="keyword">int</span> source, <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> * <span class="built_in">stack</span> = ( <span class="keyword">int</span> * ) <span class="built_in">malloc</span> ( <span class="keyword">sizeof</span>( <span class="keyword">int</span> ) * V ), i;</span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">	<span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">stack</span>[rear++] = source;</span><br><span class="line">	visited[source] = <span class="number">1</span>;</span><br><span class="line">	pre[source] = source;</span><br><span class="line">	<span class="keyword">while</span> ( front != rear )&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="built_in">stack</span>[front++];</span><br><span class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; V ; i++ )&#123;</span><br><span class="line">			<span class="keyword">if</span> ( !visited[i] &amp;&amp; <span class="built_in">map</span>[s][i] )&#123;</span><br><span class="line">				<span class="built_in">stack</span>[rear++] = i;</span><br><span class="line">				visited[i] = <span class="number">1</span>;</span><br><span class="line">				pre[i] = s;</span><br><span class="line">				<span class="keyword">if</span> ( i == end)&#123;</span><br><span class="line">					<span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">( <span class="keyword">int</span> source, <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ( BFS( source, end ) )&#123;</span><br><span class="line">		<span class="keyword">int</span> cfp = cf( source, end );</span><br><span class="line">		flow += cfp;</span><br><span class="line">		<span class="keyword">int</span> p = end;</span><br><span class="line">		<span class="keyword">while</span> ( p != source )&#123;</span><br><span class="line">			<span class="built_in">map</span>[pre[p]][p] = <span class="built_in">map</span>[pre[p]][p] - cfp;</span><br><span class="line">			<span class="built_in">map</span>[p][pre[p]] += cfp;</span><br><span class="line">			p = pre[p];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"maxFlow:%d\n"</span>, maxFlow(s,t));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u8F6C_u5316_u4E3A_u6700_u5927_u6D41_u95EE_u9898_u7684_u6700_u5927_u65E0_u5411_u4E8C_u5206_u56FE_u5339_u914D_u95EE_u9898"><a href="#u8F6C_u5316_u4E3A_u6700_u5927_u6D41_u95EE_u9898_u7684_u6700_u5927_u65E0_u5411_u4E8C_u5206_u56FE_u5339_u914D_u95EE_u9898" class="headerlink" title="转化为最大流问题的最大无向二分图匹配问题"></a>转化为最大流问题的最大无向二分图匹配问题</h1><ul>
<li>最大无向二分图匹配问题：给定一个无向图G=（V，E），一个匹配是编辑E的子集，令匹配为M，满足对所有V中顶点v，M中至多有一条边和v相关联。若M中有边和v关联，则称v被匹配，否则v是无匹配的。最大匹配是求解最大势的匹配，即让|M|最大。假定顶点集合V可以被划分为L和R两部分，L和R不相交，且E中的所有边均为一个顶点在L中，另一个顶点在R中，则该图为二分图。方便起见假设该图每个顶点都至少有一条关联的边。</li>
<li>为该无向二分图建立流网络，其中最大流对应最大匹配的数量。二分图G对应的流网络G’=（V’，E’）定义如下：设源点s和汇点t不属于V，在V’中向V加入超级源点s和超级汇点t，从s引出|L|条有向边，分别指向L中的每个顶点，R中的每个顶点也均引出一条指向t的有向边。此外在G中，L和R之间的|E|条边，均在G’中成为自L指向R的|E|条有向边。<strong>所有边均赋予单位容量</strong>。因为V中每个顶点都至少有一条关联边，因此|E|&gt;=|V|/2，所以|E|&lt;=|E’|=|E|+|V|&lt;=3|E|，因此|E’|的规模为O(E)。</li>
</ul>
<hr>
<p>原创作品，允许转载，转载时无需告知，但请务必以超链接形式标明文章<a href="http://forec.github.io/2015/12/25/Graph-Algorithms-flow/">原始出处</a>(<a href="http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/">http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/</a>) 、作者信息（<a href="http://forec.github.io/">Forec</a>）和本声明。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/28/parameter-error/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          C语言的一种错误传参做法
        
      </div>
    </a>
  
  
    <a href="/2015/12/24/Graph-Algorithms6/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">差分约束系统</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Graph-Algorithms7-flow" data-title="最大流（一）" data-url="http://forec.github.io/2015/12/25/Graph-Algorithms7-flow/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Forec
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>